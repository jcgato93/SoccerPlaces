<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>fullcalendar.js - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/darkfish.js"></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../Gemfile.html">Gemfile</a>
  
    <li><a href="../../Gemfile_lock.html">Gemfile.lock</a>
  
    <li><a href="../../README_md.html">README</a>
  
    <li><a href="../../Rakefile.html">Rakefile</a>
  
    <li><a href="../../app/assets/config/manifest_js.html">manifest.js</a>
  
    <li><a href="../../app/assets/javascripts/application_js.html">application.js</a>
  
    <li><a href="../../app/assets/javascripts/cable_js.html">cable.js</a>
  
    <li><a href="../../app/assets/javascripts/home_coffee.html">home.coffee</a>
  
    <li><a href="../../app/assets/javascripts/reservations_coffee.html">reservations.coffee</a>
  
    <li><a href="../../app/assets/javascripts/rols_coffee.html">rols.coffee</a>
  
    <li><a href="../../app/assets/javascripts/soccer_courts_coffee.html">soccer_courts.coffee</a>
  
    <li><a href="../../app/assets/stylesheets/application_css.html">application.css</a>
  
    <li><a href="../../app/assets/stylesheets/home_scss.html">home.scss</a>
  
    <li><a href="../../app/assets/stylesheets/reservations_scss.html">reservations.scss</a>
  
    <li><a href="../../app/assets/stylesheets/rols_scss.html">rols.scss</a>
  
    <li><a href="../../app/assets/stylesheets/scaffolds_scss.html">scaffolds.scss</a>
  
    <li><a href="../../app/assets/stylesheets/soccer_courts_scss.html">soccer_courts.scss</a>
  
    <li><a href="../../app/views/reservations/_reservation_json_jbuilder.html">_reservation.json.jbuilder</a>
  
    <li><a href="../../app/views/reservations/index_json_jbuilder.html">index.json.jbuilder</a>
  
    <li><a href="../../app/views/reservations/show_json_jbuilder.html">show.json.jbuilder</a>
  
    <li><a href="../../app/views/rols/_rol_json_jbuilder.html">_rol.json.jbuilder</a>
  
    <li><a href="../../app/views/rols/index_json_jbuilder.html">index.json.jbuilder</a>
  
    <li><a href="../../app/views/rols/show_json_jbuilder.html">show.json.jbuilder</a>
  
    <li><a href="../../app/views/soccer_courts/_soccer_court_json_jbuilder.html">_soccer_court.json.jbuilder</a>
  
    <li><a href="../../app/views/soccer_courts/index_json_jbuilder.html">index.json.jbuilder</a>
  
    <li><a href="../../app/views/soccer_courts/show_json_jbuilder.html">show.json.jbuilder</a>
  
    <li><a href="../../config_ru.html">config.ru</a>
  
    <li><a href="../../log/development_log.html">development.log</a>
  
    <li><a href="../../package_json.html">package.json</a>
  
    <li><a href="../../public/404_html.html">404.html</a>
  
    <li><a href="../../public/422_html.html">422.html</a>
  
    <li><a href="../../public/500_html.html">500.html</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/dataTables_bootstrap_css.html">dataTables.bootstrap.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/dataTables_bootstrap_min_css.html">dataTables.bootstrap.min.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/dataTables_bootstrap4_css.html">dataTables.bootstrap4.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/dataTables_bootstrap4_min_css.html">dataTables.bootstrap4.min.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/dataTables_foundation_css.html">dataTables.foundation.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/dataTables_foundation_min_css.html">dataTables.foundation.min.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/dataTables_jqueryui_css.html">dataTables.jqueryui.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/dataTables_jqueryui_min_css.html">dataTables.jqueryui.min.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/dataTables_semanticui_css.html">dataTables.semanticui.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/dataTables_semanticui_min_css.html">dataTables.semanticui.min.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/jquery_dataTables_css.html">jquery.dataTables.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/css/jquery_dataTables_min_css.html">jquery.dataTables.min.css</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/dataTables_bootstrap_js.html">dataTables.bootstrap.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/dataTables_bootstrap_min_js.html">dataTables.bootstrap.min.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/dataTables_bootstrap4_js.html">dataTables.bootstrap4.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/dataTables_bootstrap4_min_js.html">dataTables.bootstrap4.min.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/dataTables_foundation_js.html">dataTables.foundation.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/dataTables_foundation_min_js.html">dataTables.foundation.min.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/dataTables_jqueryui_js.html">dataTables.jqueryui.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/dataTables_jqueryui_min_js.html">dataTables.jqueryui.min.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/dataTables_semanticui_js.html">dataTables.semanticui.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/dataTables_semanticui_min_js.html">dataTables.semanticui.min.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/jquery_dataTables_js.html">jquery.dataTables.js</a>
  
    <li><a href="../../public/DataTables/DataTables-1_10_18/js/jquery_dataTables_min_js.html">jquery.dataTables.min.js</a>
  
    <li><a href="../../public/DataTables/datatables_css.html">datatables.css</a>
  
    <li><a href="../../public/DataTables/datatables_js.html">datatables.js</a>
  
    <li><a href="../../public/DataTables/datatables_min_css.html">datatables.min.css</a>
  
    <li><a href="../../public/DataTables/datatables_min_js.html">datatables.min.js</a>
  
    <li><a href="../../public/Home Page/css/JiSlider_css.html">JiSlider.css</a>
  
    <li><a href="../../public/Home Page/css/bootstrap_css.html">bootstrap.css</a>
  
    <li><a href="../../public/Home Page/css/font-awesome_css.html">font-awesome.css</a>
  
    <li><a href="../../public/Home Page/css/lightbox_css.html">lightbox.css</a>
  
    <li><a href="../../public/Home Page/css/owl_carousel_css.html">owl.carousel.css</a>
  
    <li><a href="../../public/Home Page/css/style_css.html">style.css</a>
  
    <li><a href="../../public/Home Page/index_html.html">index.html</a>
  
    <li><a href="../../public/Home Page/js/JiSlider_js.html">JiSlider.js</a>
  
    <li><a href="../../public/Home Page/js/SmoothScroll_min_js.html">SmoothScroll.min.js</a>
  
    <li><a href="../../public/Home Page/js/bootstrap_js.html">bootstrap.js</a>
  
    <li><a href="../../public/Home Page/js/easing_js.html">easing.js</a>
  
    <li><a href="../../public/Home Page/js/index_js.html">index.js</a>
  
    <li><a href="../../public/Home Page/js/jquery-2_1_4_min_js.html">jquery-2.1.4.min.js</a>
  
    <li><a href="../../public/Home Page/js/jquery_countup_js.html">jquery.countup.js</a>
  
    <li><a href="../../public/Home Page/js/jquery_waypoints_min_js.html">jquery.waypoints.min.js</a>
  
    <li><a href="../../public/Home Page/js/lightbox-plus-jquery_min_js.html">lightbox-plus-jquery.min.js</a>
  
    <li><a href="../../public/Home Page/js/moment-timezone-with-data_js.html">moment-timezone-with-data.js</a>
  
    <li><a href="../../public/Home Page/js/moment_js.html">moment.js</a>
  
    <li><a href="../../public/Home Page/js/move-top_js.html">move-top.js</a>
  
    <li><a href="../../public/Home Page/js/owl_carousel_js.html">owl.carousel.js</a>
  
    <li><a href="../../public/Home Page/js/timer_js.html">timer.js</a>
  
    <li><a href="../../public/JS/Reservations/index_js.html">index.js</a>
  
    <li><a href="../../public/JS/SoccerCourts/index_js.html">index.js</a>
  
    <li><a href="../../public/Login/css/style_css.html">style.css</a>
  
    <li><a href="../../public/Login/index_html.html">index.html</a>
  
    <li><a href="../../public/Login/js/easyResponsiveTabs_js.html">easyResponsiveTabs.js</a>
  
    <li><a href="../../public/Login/js/jquery_min_js.html">jquery.min.js</a>
  
    <li><a href="../../public/apple-touch-icon-precomposed_png.html">apple-touch-icon-precomposed.png</a>
  
    <li><a href="../../public/apple-touch-icon_png.html">apple-touch-icon.png</a>
  
    <li><a href="../../public/bootstrap/css/bootstrap-theme_css.html">bootstrap-theme.css</a>
  
    <li><a href="../../public/bootstrap/css/bootstrap-theme_css_map.html">bootstrap-theme.css.map</a>
  
    <li><a href="../../public/bootstrap/css/bootstrap-theme_min_css.html">bootstrap-theme.min.css</a>
  
    <li><a href="../../public/bootstrap/css/bootstrap-theme_min_css_map.html">bootstrap-theme.min.css.map</a>
  
    <li><a href="../../public/bootstrap/css/bootstrap_css.html">bootstrap.css</a>
  
    <li><a href="../../public/bootstrap/css/bootstrap_css_map.html">bootstrap.css.map</a>
  
    <li><a href="../../public/bootstrap/css/bootstrap_min_css.html">bootstrap.min.css</a>
  
    <li><a href="../../public/bootstrap/css/bootstrap_min_css_map.html">bootstrap.min.css.map</a>
  
    <li><a href="../../public/bootstrap/js/bootstrap_js.html">bootstrap.js</a>
  
    <li><a href="../../public/bootstrap/js/bootstrap_min_js.html">bootstrap.min.js</a>
  
    <li><a href="../../public/bootstrap/js/npm_js.html">npm.js</a>
  
    <li><a href="../../public/favicon_ico.html">favicon.ico</a>
  
    <li><a href="../../public/fullcalendar/CHANGELOG_txt.html">CHANGELOG</a>
  
    <li><a href="../../public/fullcalendar/CONTRIBUTING_txt.html">CONTRIBUTING</a>
  
    <li><a href="../../public/fullcalendar/LICENSE_txt.html">LICENSE</a>
  
    <li><a href="../../public/fullcalendar/demos/agenda-views_html.html">agenda-views.html</a>
  
    <li><a href="../../public/fullcalendar/demos/background-events_html.html">background-events.html</a>
  
    <li><a href="../../public/fullcalendar/demos/basic-views_html.html">basic-views.html</a>
  
    <li><a href="../../public/fullcalendar/demos/default_html.html">default.html</a>
  
    <li><a href="../../public/fullcalendar/demos/external-dragging_html.html">external-dragging.html</a>
  
    <li><a href="../../public/fullcalendar/demos/gcal_html.html">gcal.html</a>
  
    <li><a href="../../public/fullcalendar/demos/js/theme-chooser_js.html">theme-chooser.js</a>
  
    <li><a href="../../public/fullcalendar/demos/json_html.html">json.html</a>
  
    <li><a href="../../public/fullcalendar/demos/json/events_json.html">events.json</a>
  
    <li><a href="../../public/fullcalendar/demos/list-views_html.html">list-views.html</a>
  
    <li><a href="../../public/fullcalendar/demos/locales_html.html">locales.html</a>
  
    <li><a href="../../public/fullcalendar/demos/php/get-events_php.html">get-events.php</a>
  
    <li><a href="../../public/fullcalendar/demos/php/get-timezones_php.html">get-timezones.php</a>
  
    <li><a href="../../public/fullcalendar/demos/php/utils_php.html">utils.php</a>
  
    <li><a href="../../public/fullcalendar/demos/selectable_html.html">selectable.html</a>
  
    <li><a href="../../public/fullcalendar/demos/themes_html.html">themes.html</a>
  
    <li><a href="../../public/fullcalendar/demos/timezones_html.html">timezones.html</a>
  
    <li><a href="../../public/fullcalendar/demos/week-numbers_html.html">week-numbers.html</a>
  
    <li><a href="../../public/fullcalendar/fullcalendar_css.html">fullcalendar.css</a>
  
    <li><a href="../../public/fullcalendar/fullcalendar_js.html">fullcalendar.js</a>
  
    <li><a href="../../public/fullcalendar/fullcalendar_min_css.html">fullcalendar.min.css</a>
  
    <li><a href="../../public/fullcalendar/fullcalendar_min_js.html">fullcalendar.min.js</a>
  
    <li><a href="../../public/fullcalendar/fullcalendar_print_css.html">fullcalendar.print.css</a>
  
    <li><a href="../../public/fullcalendar/fullcalendar_print_min_css.html">fullcalendar.print.min.css</a>
  
    <li><a href="../../public/fullcalendar/gcal_js.html">gcal.js</a>
  
    <li><a href="../../public/fullcalendar/gcal_min_js.html">gcal.min.js</a>
  
    <li><a href="../../public/fullcalendar/lib/jquery-ui_min_js.html">jquery-ui.min.js</a>
  
    <li><a href="../../public/fullcalendar/lib/jquery_min_js.html">jquery.min.js</a>
  
    <li><a href="../../public/fullcalendar/lib/moment_min_js.html">moment.min.js</a>
  
    <li><a href="../../public/fullcalendar/locale-all_js.html">locale-all.js</a>
  
    <li><a href="../../public/fullcalendar/locale/af_js.html">af.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ar-dz_js.html">ar-dz.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ar-kw_js.html">ar-kw.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ar-ly_js.html">ar-ly.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ar-ma_js.html">ar-ma.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ar-sa_js.html">ar-sa.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ar-tn_js.html">ar-tn.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ar_js.html">ar.js</a>
  
    <li><a href="../../public/fullcalendar/locale/bg_js.html">bg.js</a>
  
    <li><a href="../../public/fullcalendar/locale/bs_js.html">bs.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ca_js.html">ca.js</a>
  
    <li><a href="../../public/fullcalendar/locale/cs_js.html">cs.js</a>
  
    <li><a href="../../public/fullcalendar/locale/da_js.html">da.js</a>
  
    <li><a href="../../public/fullcalendar/locale/de-at_js.html">de-at.js</a>
  
    <li><a href="../../public/fullcalendar/locale/de-ch_js.html">de-ch.js</a>
  
    <li><a href="../../public/fullcalendar/locale/de_js.html">de.js</a>
  
    <li><a href="../../public/fullcalendar/locale/el_js.html">el.js</a>
  
    <li><a href="../../public/fullcalendar/locale/en-au_js.html">en-au.js</a>
  
    <li><a href="../../public/fullcalendar/locale/en-ca_js.html">en-ca.js</a>
  
    <li><a href="../../public/fullcalendar/locale/en-gb_js.html">en-gb.js</a>
  
    <li><a href="../../public/fullcalendar/locale/en-ie_js.html">en-ie.js</a>
  
    <li><a href="../../public/fullcalendar/locale/en-nz_js.html">en-nz.js</a>
  
    <li><a href="../../public/fullcalendar/locale/es-do_js.html">es-do.js</a>
  
    <li><a href="../../public/fullcalendar/locale/es-us_js.html">es-us.js</a>
  
    <li><a href="../../public/fullcalendar/locale/es_js.html">es.js</a>
  
    <li><a href="../../public/fullcalendar/locale/et_js.html">et.js</a>
  
    <li><a href="../../public/fullcalendar/locale/eu_js.html">eu.js</a>
  
    <li><a href="../../public/fullcalendar/locale/fa_js.html">fa.js</a>
  
    <li><a href="../../public/fullcalendar/locale/fi_js.html">fi.js</a>
  
    <li><a href="../../public/fullcalendar/locale/fr-ca_js.html">fr-ca.js</a>
  
    <li><a href="../../public/fullcalendar/locale/fr-ch_js.html">fr-ch.js</a>
  
    <li><a href="../../public/fullcalendar/locale/fr_js.html">fr.js</a>
  
    <li><a href="../../public/fullcalendar/locale/gl_js.html">gl.js</a>
  
    <li><a href="../../public/fullcalendar/locale/he_js.html">he.js</a>
  
    <li><a href="../../public/fullcalendar/locale/hi_js.html">hi.js</a>
  
    <li><a href="../../public/fullcalendar/locale/hr_js.html">hr.js</a>
  
    <li><a href="../../public/fullcalendar/locale/hu_js.html">hu.js</a>
  
    <li><a href="../../public/fullcalendar/locale/id_js.html">id.js</a>
  
    <li><a href="../../public/fullcalendar/locale/is_js.html">is.js</a>
  
    <li><a href="../../public/fullcalendar/locale/it_js.html">it.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ja_js.html">ja.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ka_js.html">ka.js</a>
  
    <li><a href="../../public/fullcalendar/locale/kk_js.html">kk.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ko_js.html">ko.js</a>
  
    <li><a href="../../public/fullcalendar/locale/lb_js.html">lb.js</a>
  
    <li><a href="../../public/fullcalendar/locale/lt_js.html">lt.js</a>
  
    <li><a href="../../public/fullcalendar/locale/lv_js.html">lv.js</a>
  
    <li><a href="../../public/fullcalendar/locale/mk_js.html">mk.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ms-my_js.html">ms-my.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ms_js.html">ms.js</a>
  
    <li><a href="../../public/fullcalendar/locale/nb_js.html">nb.js</a>
  
    <li><a href="../../public/fullcalendar/locale/nl-be_js.html">nl-be.js</a>
  
    <li><a href="../../public/fullcalendar/locale/nl_js.html">nl.js</a>
  
    <li><a href="../../public/fullcalendar/locale/nn_js.html">nn.js</a>
  
    <li><a href="../../public/fullcalendar/locale/pl_js.html">pl.js</a>
  
    <li><a href="../../public/fullcalendar/locale/pt-br_js.html">pt-br.js</a>
  
    <li><a href="../../public/fullcalendar/locale/pt_js.html">pt.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ro_js.html">ro.js</a>
  
    <li><a href="../../public/fullcalendar/locale/ru_js.html">ru.js</a>
  
    <li><a href="../../public/fullcalendar/locale/sk_js.html">sk.js</a>
  
    <li><a href="../../public/fullcalendar/locale/sl_js.html">sl.js</a>
  
    <li><a href="../../public/fullcalendar/locale/sq_js.html">sq.js</a>
  
    <li><a href="../../public/fullcalendar/locale/sr-cyrl_js.html">sr-cyrl.js</a>
  
    <li><a href="../../public/fullcalendar/locale/sr_js.html">sr.js</a>
  
    <li><a href="../../public/fullcalendar/locale/sv_js.html">sv.js</a>
  
    <li><a href="../../public/fullcalendar/locale/th_js.html">th.js</a>
  
    <li><a href="../../public/fullcalendar/locale/tr_js.html">tr.js</a>
  
    <li><a href="../../public/fullcalendar/locale/uk_js.html">uk.js</a>
  
    <li><a href="../../public/fullcalendar/locale/vi_js.html">vi.js</a>
  
    <li><a href="../../public/fullcalendar/locale/zh-cn_js.html">zh-cn.js</a>
  
    <li><a href="../../public/fullcalendar/locale/zh-tw_js.html">zh-tw.js</a>
  
    <li><a href="../../public/jquery-3_3_1_min_js.html">jquery-3.3.1.min.js</a>
  
    <li><a href="../../public/robots_txt.html">robots</a>
  
    <li><a href="../../tmp/restart_txt.html">restart</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page public/fullcalendar/fullcalendar.js">

<pre>!
 FullCalendar v3.9.0
 Docs &amp; License: https://fullcalendar.io/
 (c) 2018 Adam Shaw</pre>

<p>(function webpackUniversalModuleDefinition(root, factory) {</p>

<pre>if(typeof exports === &#39;object&#39; &amp;&amp; typeof module === &#39;object&#39;)
        module.exports = factory(require(&quot;moment&quot;), require(&quot;jquery&quot;));
else if(typeof define === &#39;function&#39; &amp;&amp; define.amd)
        define([&quot;moment&quot;, &quot;jquery&quot;], factory);
else if(typeof exports === &#39;object&#39;)
        exports[&quot;FullCalendar&quot;] = factory(require(&quot;moment&quot;), require(&quot;jquery&quot;));
else
        root[&quot;FullCalendar&quot;] = factory(root[&quot;moment&quot;], root[&quot;jQuery&quot;]);</pre>

<p>})(typeof self !== &#39;undefined&#39; ? self : this,
function(<em>WEBPACK_EXTERNAL_MODULE_0</em>,
<em>WEBPACK_EXTERNAL_MODULE_3</em>) { return        / (function(modules) {
// webpackBootstrap /               // The module cache /******/        var
installedModules = {}; /******/ /******/        // The require function
/******/        function <em>webpack_require</em>(moduleId) { /******/
/******/                // Check if module is in cache /******/            
<a href="moduleId">if(installedModules</a>) { /******/                     
return <a href="moduleId">installedModules</a>.exports; /******/           
} /******/                // Create a new module (and put it into the
cache) /******/                var module = <a
href="moduleId">installedModules</a> = { /******/                        i:
moduleId, /******/                        l: false, /******/               
exports: {} /******/                }; /******/ /******/                //
Execute the module function /******/                <a
href="moduleId">modules</a>.call(module.exports, module, module.exports,
<em>webpack_require</em>); /******/ /******/                // Flag the
module as loaded /******/                module.l = true; /******/ /******/
// Return the exports of the module /******/                return
module.exports; /******/        } /******/ /******/ /******/        //
expose the modules object (<em>webpack_modules</em>) /******/       
<em>webpack_require</em>.m = modules; /******/ /******/        // expose
the module cache /******/        <em>webpack_require</em>.c =
installedModules; /******/ /******/        // define getter function for
harmony exports /******/        <em>webpack_require</em>.d =
function(exports, name, getter) { /******/               
if(!<em>webpack_require</em>.o(exports, name)) { /******/                  
Object.defineProperty(exports, name, { /******/                            
configurable: false, /******/                                enumerable:
true, /******/                                get: getter /******/         
}); /******/                } /******/        }; /******/ /******/       
// getDefaultExport function for compatibility with non-harmony modules
/******/        <em>webpack_require</em>.n = function(module) { /******/   
var getter = module &amp;&amp; module.__esModule ? /******/                
function getDefault() { return <a href="'default'">module</a>; } : /******/
function getModuleExports() { return module; }; /******/               
<em>webpack_require</em>.d(getter, &#39;a&#39;, getter); /******/          
return getter; /******/        }; /******/ /******/        //
Object.prototype.hasOwnProperty.call /******/       
<em>webpack_require</em>.o = function(object, property) { return
Object.prototype.hasOwnProperty.call(object, property); }; /******/
/******/        // <em>webpack_public_path</em> /******/       
<em>webpack_require</em>.p = “”; /******/ /******/        // Load entry
module and return exports /******/        return
<em>webpack_require</em>(<em>webpack_require</em>.s = 236); /******/ })
/************************************************************************/
/******/ ([ /* 0 */ /***/ (function(module, exports) {</p>

<p>module.exports = <em>WEBPACK_EXTERNAL_MODULE_0</em>;</p>

<p>/***/ }), /* 1 */, /* 2 */ /***/ (function(module, exports) {</p>

<p>/* derived from: <a
href="https://github.com/Microsoft/tslib/blob/v1.6.0/tslib.js">github.com/Microsoft/tslib/blob/v1.6.0/tslib.js</a></p>

<p>only include the helpers we need, to keep down filesize</p>

<pre>/</pre>

<p>var extendStatics = Object.setPrototypeOf ||</p>

<pre>({ __proto__: [] } instanceof Array &amp;&amp; function (d, b) { d.__proto__ = b; }) ||
function (d, b) { for (var p in b)
    if (b.hasOwnProperty(p))
        d[p] = b[p]; };</pre>

<p>exports.__extends = function (d, b) {</p>

<pre>extendStatics(d, b);
function __() { this.constructor = d; }
d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());</pre>

<p>};</p>

<p>/***/ }), /* 3 */ /***/ (function(module, exports) {</p>

<p>module.exports = <em>WEBPACK_EXTERNAL_MODULE_3</em>;</p>

<p>/***/ }), /* 4 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var moment =
<em>webpack_require</em>(0); var $ = <em>webpack_require</em>(3); /*
FullCalendar-specific DOM Utilities
———————————————————————————————————————-*/ // Given the scrollbar widths of
some other container, create borders/margins on rowEls in order to match
the left // and right space that was offset by the scrollbars. A 1-pixel
border first, then margin beyond that. function compensateScroll(rowEls,
scrollbarWidths) {</p>

<pre>if (scrollbarWidths.left) {
    rowEls.css({
        &#39;border-left-width&#39;: 1,
        &#39;margin-left&#39;: scrollbarWidths.left - 1
    });
}
if (scrollbarWidths.right) {
    rowEls.css({
        &#39;border-right-width&#39;: 1,
        &#39;margin-right&#39;: scrollbarWidths.right - 1
    });
}</pre>

<p>} exports.compensateScroll = compensateScroll; // Undoes compensateScroll
and restores all borders/margins function uncompensateScroll(rowEls) {</p>

<pre class="ruby"><span class="ruby-identifier">rowEls</span>.<span class="ruby-identifier">css</span>({
    <span class="ruby-value">&#39;margin-left&#39;:</span> <span class="ruby-string">&#39;&#39;</span>,
    <span class="ruby-value">&#39;margin-right&#39;:</span> <span class="ruby-string">&#39;&#39;</span>,
    <span class="ruby-value">&#39;border-left-width&#39;:</span> <span class="ruby-string">&#39;&#39;</span>,
    <span class="ruby-value">&#39;border-right-width&#39;:</span> <span class="ruby-string">&#39;&#39;</span>
});
</pre>

<p>} exports.uncompensateScroll = uncompensateScroll; // Make the mouse cursor
express that an event is not allowed in the current area function
disableCursor() {</p>

<pre>$(&#39;body&#39;).addClass(&#39;fc-not-allowed&#39;);</pre>

<p>} exports.disableCursor = disableCursor; // Returns the mouse cursor to its
original look function enableCursor() {</p>

<pre>$(&#39;body&#39;).removeClass(&#39;fc-not-allowed&#39;);</pre>

<p>} exports.enableCursor = enableCursor; // Given a total available height to
fill, have `els` (essentially child rows) expand to accomodate. // By
default, all elements that are shorter than the recommended height are
expanded uniformly, not considering // any other els that are already too
tall. if `shouldRedistribute` is on, it considers these tall rows and //
reduces the available height. function distributeHeight(els,
availableHeight, shouldRedistribute) {</p>

<pre>// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
var flexEls = []; // elements that are allowed to expand. array of DOM nodes
var flexOffsets = []; // amount of vertical space it takes up
var flexHeights = []; // actual css height
var usedHeight = 0;
undistributeHeight(els); // give all elements their natural height
// find elements that are below the recommended height (expandable).
// important to query for heights in a single first pass (to avoid reflow oscillation).
els.each(function (i, el) {
    var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
    var naturalOffset = $(el).outerHeight(true);
    if (naturalOffset &lt; minOffset) {
        flexEls.push(el);
        flexOffsets.push(naturalOffset);
        flexHeights.push($(el).height());
    }
    else {
        // this element stretches past recommended height (non-expandable). mark the space as occupied.
        usedHeight += naturalOffset;
    }
});
// readjust the recommended height to only consider the height available to non-maxed-out rows.
if (shouldRedistribute) {
    availableHeight -= usedHeight;
    minOffset1 = Math.floor(availableHeight / flexEls.length);
    minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
}
// assign heights to all expandable elements
$(flexEls).each(function (i, el) {
    var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
    var naturalOffset = flexOffsets[i];
    var naturalHeight = flexHeights[i];
    var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding
    if (naturalOffset &lt; minOffset) {
        $(el).height(newHeight);
    }
});</pre>

<p>} exports.distributeHeight = distributeHeight; // Undoes distrubuteHeight,
restoring all els to their natural height function undistributeHeight(els)
{</p>

<pre class="ruby"><span class="ruby-identifier">els</span>.<span class="ruby-identifier">height</span>(<span class="ruby-string">&#39;&#39;</span>);
</pre>

<p>} exports.undistributeHeight = undistributeHeight; // Given `els`, a jQuery
set of &lt;td&gt; cells, find the cell with the largest natural width and
set the widths of all the // cells to be that width. // PREREQUISITE: if
you want a cell to take up width, it needs to have a single inner element
w/ display:inline function matchCellWidths(els) {</p>

<pre>var maxInnerWidth = 0;
els.find(&#39;&gt; *&#39;).each(function (i, innerEl) {
    var innerWidth = $(innerEl).outerWidth();
    if (innerWidth &gt; maxInnerWidth) {
        maxInnerWidth = innerWidth;
    }
});
maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance
els.width(maxInnerWidth);
return maxInnerWidth;</pre>

<p>} exports.matchCellWidths = matchCellWidths; // Given one element that
resides inside another, // Subtracts the height of the inner element from
the outer element. function subtractInnerElHeight(outerEl, innerEl) {</p>

<pre>var both = outerEl.add(innerEl);
var diff;
// effin&#39; IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
both.css({
    position: &#39;relative&#39;,
    left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
});
diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
both.css({ position: &#39;&#39;, left: &#39;&#39; }); // undo hack
return diff;</pre>

<p>} exports.subtractInnerElHeight = subtractInnerElHeight; /* Element Geom
Utilities ———————————————————————————————————————-*/ // borrowed from <a
href="https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51">github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51</a>
function getScrollParent(el) {</p>

<pre>var position = el.css(&#39;position&#39;);
var scrollParent = el.parents().filter(function () {
    var parent = $(this);
    return (/(auto|scroll)/).test(parent.css(&#39;overflow&#39;) + parent.css(&#39;overflow-y&#39;) + parent.css(&#39;overflow-x&#39;));
}).eq(0);
return position === &#39;fixed&#39; || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;</pre>

<p>} exports.getScrollParent = getScrollParent; // Queries the outer bounding
area of a jQuery element. // Returns a rectangle with absolute coordinates:
left, right (exclusive), top, bottom (exclusive). // Origin is optional.
function getOuterRect(el, origin) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">offset</span> = <span class="ruby-identifier">el</span>.<span class="ruby-identifier">offset</span>();
<span class="ruby-identifier">var</span> <span class="ruby-identifier">left</span> = <span class="ruby-identifier">offset</span>.<span class="ruby-identifier">left</span> <span class="ruby-operator">-</span> (<span class="ruby-identifier">origin</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">origin</span>.<span class="ruby-identifier">left</span> <span class="ruby-operator">:</span> <span class="ruby-value">0</span>);
<span class="ruby-identifier">var</span> <span class="ruby-identifier">top</span> = <span class="ruby-identifier">offset</span>.<span class="ruby-identifier">top</span> <span class="ruby-operator">-</span> (<span class="ruby-identifier">origin</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">origin</span>.<span class="ruby-identifier">top</span> <span class="ruby-operator">:</span> <span class="ruby-value">0</span>);
<span class="ruby-keyword">return</span> {
    <span class="ruby-value">left:</span> <span class="ruby-identifier">left</span>,
    <span class="ruby-value">right:</span> <span class="ruby-identifier">left</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">el</span>.<span class="ruby-identifier">outerWidth</span>(),
    <span class="ruby-value">top:</span> <span class="ruby-identifier">top</span>,
    <span class="ruby-value">bottom:</span> <span class="ruby-identifier">top</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">el</span>.<span class="ruby-identifier">outerHeight</span>()
};
</pre>

<p>} exports.getOuterRect = getOuterRect; // Queries the area within the
margin/border/scrollbars of a jQuery element. Does not go within the
padding. // Returns a rectangle with absolute coordinates: left, right
(exclusive), top, bottom (exclusive). // Origin is optional. // WARNING:
given element can&#39;t have borders // NOTE: should use
clientLeft/clientTop, but very unreliable cross-browser. function
getClientRect(el, origin) {</p>

<pre>var offset = el.offset();
var scrollbarWidths = getScrollbarWidths(el);
var left = offset.left + getCssFloat(el, &#39;border-left-width&#39;) + scrollbarWidths.left - (origin ? origin.left : 0);
var top = offset.top + getCssFloat(el, &#39;border-top-width&#39;) + scrollbarWidths.top - (origin ? origin.top : 0);
return {
    left: left,
    right: left + el[0].clientWidth,
    top: top,
    bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
};</pre>

<p>} exports.getClientRect = getClientRect; // Queries the area within the
margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive),
top, bottom (exclusive). // Origin is optional. function getContentRect(el,
origin) {</p>

<pre>var offset = el.offset(); // just outside of border, margin not included
var left = offset.left + getCssFloat(el, &#39;border-left-width&#39;) + getCssFloat(el, &#39;padding-left&#39;) -
    (origin ? origin.left : 0);
var top = offset.top + getCssFloat(el, &#39;border-top-width&#39;) + getCssFloat(el, &#39;padding-top&#39;) -
    (origin ? origin.top : 0);
return {
    left: left,
    right: left + el.width(),
    top: top,
    bottom: top + el.height()
};</pre>

<p>} exports.getContentRect = getContentRect; // Returns the computed
left/right/top/bottom scrollbar widths for the given jQuery element. //
WARNING: given element can&#39;t have borders (which will cause
offsetWidth/offsetHeight to be larger). // NOTE: should use
clientLeft/clientTop, but very unreliable cross-browser. function
getScrollbarWidths(el) {</p>

<pre>var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;
var bottomWidth = el[0].offsetHeight - el[0].clientHeight;
var widths;
leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);
bottomWidth = sanitizeScrollbarWidth(bottomWidth);
widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };
if (getIsLeftRtlScrollbars() &amp;&amp; el.css(&#39;direction&#39;) === &#39;rtl&#39;) {
    widths.left = leftRightWidth;
}
else {
    widths.right = leftRightWidth;
}
return widths;</pre>

<p>} exports.getScrollbarWidths = getScrollbarWidths; // The scrollbar width
computations in getScrollbarWidths are sometimes flawed when it comes to //
retina displays, rounding, and IE11. Massage them into a usable value.
function sanitizeScrollbarWidth(width) {</p>

<pre>width = Math.max(0, width); // no negatives
width = Math.round(width);
return width;</pre>

<p>} // Logic for determining if, when the element is right-to-left, the
scrollbar appears on the left side var _isLeftRtlScrollbars = null;
function getIsLeftRtlScrollbars() {</p>

<pre>if (_isLeftRtlScrollbars === null) {
    _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
}
return _isLeftRtlScrollbars;</pre>

<p>} function computeIsLeftRtlScrollbars() {</p>

<pre>var el = $(&#39;&lt;div&gt;&lt;div/&gt;&lt;/div&gt;&#39;)
    .css({
    position: &#39;absolute&#39;,
    top: -1000,
    left: 0,
    border: 0,
    padding: 0,
    overflow: &#39;scroll&#39;,
    direction: &#39;rtl&#39;
})
    .appendTo(&#39;body&#39;);
var innerEl = el.children();
var res = innerEl.offset().left &gt; el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
el.remove();
return res;</pre>

<p>} // Retrieves a jQuery element&#39;s computed CSS value as a
floating-point number. // If the queried value is non-numeric (ex: IE can
return “medium” for border width), will just return zero. function
getCssFloat(el, prop) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">parseFloat</span>(<span class="ruby-identifier">el</span>.<span class="ruby-identifier">css</span>(<span class="ruby-identifier">prop</span>)) <span class="ruby-operator">||</span> <span class="ruby-value">0</span>;
</pre>

<p>} /* Mouse / Touch Utilities ———————————————————————————————————————-*/ //
Returns a boolean whether this was a left mouse click and no ctrl key
(which means right click on Mac) function isPrimaryMouseButton(ev) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">ev</span>.<span class="ruby-identifier">which</span> <span class="ruby-operator">===</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">ev</span>.<span class="ruby-identifier">ctrlKey</span>;
</pre>

<p>} exports.isPrimaryMouseButton = isPrimaryMouseButton; function getEvX(ev)
{</p>

<pre>var touches = ev.originalEvent.touches;
// on mobile FF, pageX for touch events is present, but incorrect,
// so, look at touch coordinates first.
if (touches &amp;&amp; touches.length) {
    return touches[0].pageX;
}
return ev.pageX;</pre>

<p>} exports.getEvX = getEvX; function getEvY(ev) {</p>

<pre>var touches = ev.originalEvent.touches;
// on mobile FF, pageX for touch events is present, but incorrect,
// so, look at touch coordinates first.
if (touches &amp;&amp; touches.length) {
    return touches[0].pageY;
}
return ev.pageY;</pre>

<p>} exports.getEvY = getEvY; function getEvIsTouch(ev) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-regexp">/^touch/</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">ev</span>.<span class="ruby-identifier">type</span>);
</pre>

<p>} exports.getEvIsTouch = getEvIsTouch; function preventSelection(el) {</p>

<pre class="ruby"><span class="ruby-identifier">el</span>.<span class="ruby-identifier">addClass</span>(<span class="ruby-string">&#39;fc-unselectable&#39;</span>)
    .<span class="ruby-identifier">on</span>(<span class="ruby-string">&#39;selectstart&#39;</span>, <span class="ruby-identifier">preventDefault</span>);
</pre>

<p>} exports.preventSelection = preventSelection; function allowSelection(el)
{</p>

<pre class="ruby"><span class="ruby-identifier">el</span>.<span class="ruby-identifier">removeClass</span>(<span class="ruby-string">&#39;fc-unselectable&#39;</span>)
    .<span class="ruby-identifier">off</span>(<span class="ruby-string">&#39;selectstart&#39;</span>, <span class="ruby-identifier">preventDefault</span>);
</pre>

<p>} exports.allowSelection = allowSelection; // Stops a mouse/touch event
from doing it&#39;s native browser action function preventDefault(ev) {</p>

<pre class="ruby"><span class="ruby-identifier">ev</span>.<span class="ruby-identifier">preventDefault</span>();
</pre>

<p>} exports.preventDefault = preventDefault; /* General Geometry Utils
———————————————————————————————————————-*/ // Returns a new rectangle that
is the intersection of the two rectangles. If they don&#39;t intersect,
returns false function intersectRects(rect1, rect2) {</p>

<pre>var res = {
    left: Math.max(rect1.left, rect2.left),
    right: Math.min(rect1.right, rect2.right),
    top: Math.max(rect1.top, rect2.top),
    bottom: Math.min(rect1.bottom, rect2.bottom)
};
if (res.left &lt; res.right &amp;&amp; res.top &lt; res.bottom) {
    return res;
}
return false;</pre>

<p>} exports.intersectRects = intersectRects; // Returns a new point that will
have been moved to reside within the given rectangle function
constrainPoint(point, rect) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> {
    <span class="ruby-value">left:</span> <span class="ruby-constant">Math</span>.<span class="ruby-identifier">min</span>(<span class="ruby-constant">Math</span>.<span class="ruby-identifier">max</span>(<span class="ruby-identifier">point</span>.<span class="ruby-identifier">left</span>, <span class="ruby-identifier">rect</span>.<span class="ruby-identifier">left</span>), <span class="ruby-identifier">rect</span>.<span class="ruby-identifier">right</span>),
    <span class="ruby-value">top:</span> <span class="ruby-constant">Math</span>.<span class="ruby-identifier">min</span>(<span class="ruby-constant">Math</span>.<span class="ruby-identifier">max</span>(<span class="ruby-identifier">point</span>.<span class="ruby-identifier">top</span>, <span class="ruby-identifier">rect</span>.<span class="ruby-identifier">top</span>), <span class="ruby-identifier">rect</span>.<span class="ruby-identifier">bottom</span>)
};
</pre>

<p>} exports.constrainPoint = constrainPoint; // Returns a point that is the
center of the given rectangle function getRectCenter(rect) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> {
    <span class="ruby-value">left:</span> (<span class="ruby-identifier">rect</span>.<span class="ruby-identifier">left</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">rect</span>.<span class="ruby-identifier">right</span>) <span class="ruby-operator">/</span> <span class="ruby-value">2</span>,
    <span class="ruby-value">top:</span> (<span class="ruby-identifier">rect</span>.<span class="ruby-identifier">top</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">rect</span>.<span class="ruby-identifier">bottom</span>) <span class="ruby-operator">/</span> <span class="ruby-value">2</span>
};
</pre>

<p>} exports.getRectCenter = getRectCenter; // Subtracts point2&#39;s
coordinates from point1&#39;s coordinates, returning a delta function
diffPoints(point1, point2) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> {
    <span class="ruby-value">left:</span> <span class="ruby-identifier">point1</span>.<span class="ruby-identifier">left</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">point2</span>.<span class="ruby-identifier">left</span>,
    <span class="ruby-value">top:</span> <span class="ruby-identifier">point1</span>.<span class="ruby-identifier">top</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">point2</span>.<span class="ruby-identifier">top</span>
};
</pre>

<p>} exports.diffPoints = diffPoints; /* <a
href="../../Object.html">Object</a> Ordering by Field
———————————————————————————————————————-*/ function parseFieldSpecs(input)
{</p>

<pre>var specs = [];
var tokens = [];
var i;
var token;
if (typeof input === &#39;string&#39;) {
    tokens = input.split(/\s*,\s*/);
}
else if (typeof input === &#39;function&#39;) {
    tokens = [input];
}
else if ($.isArray(input)) {
    tokens = input;
}
for (i = 0; i &lt; tokens.length; i++) {
    token = tokens[i];
    if (typeof token === &#39;string&#39;) {
        specs.push(token.charAt(0) === &#39;-&#39; ?
            { field: token.substring(1), order: -1 } :
            { field: token, order: 1 });
    }
    else if (typeof token === &#39;function&#39;) {
        specs.push({ func: token });
    }
}
return specs;</pre>

<p>} exports.parseFieldSpecs = parseFieldSpecs; function
compareByFieldSpecs(obj1, obj2, fieldSpecs, obj1fallback, obj2fallback) {</p>

<pre>var i;
var cmp;
for (i = 0; i &lt; fieldSpecs.length; i++) {
    cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i], obj1fallback, obj2fallback);
    if (cmp) {
        return cmp;
    }
}
return 0;</pre>

<p>} exports.compareByFieldSpecs = compareByFieldSpecs; function
compareByFieldSpec(obj1, obj2, fieldSpec, obj1fallback, obj2fallback) {</p>

<pre>if (fieldSpec.func) {
    return fieldSpec.func(obj1, obj2);
}
var val1 = obj1[fieldSpec.field];
var val2 = obj2[fieldSpec.field];
if (val1 == null &amp;&amp; obj1fallback) {
    val1 = obj1fallback[fieldSpec.field];
}
if (val2 == null &amp;&amp; obj2fallback) {
    val2 = obj2fallback[fieldSpec.field];
}
return flexibleCompare(val1, val2) * (fieldSpec.order || 1);</pre>

<p>} exports.compareByFieldSpec = compareByFieldSpec; function
flexibleCompare(a, b) {</p>

<pre>if (!a &amp;&amp; !b) {
    return 0;
}
if (b == null) {
    return -1;
}
if (a == null) {
    return 1;
}
if ($.type(a) === &#39;string&#39; || $.type(b) === &#39;string&#39;) {
    return String(a).localeCompare(String(b));
}
return a - b;</pre>

<p>} exports.flexibleCompare = flexibleCompare; /* Date Utilities
———————————————————————————————————————-*/ exports.dayIDs = [&#39;sun&#39;,
&#39;mon&#39;, &#39;tue&#39;, &#39;wed&#39;, &#39;thu&#39;, &#39;fri&#39;,
&#39;sat&#39;]; exports.unitsDesc = [&#39;year&#39;, &#39;month&#39;,
&#39;week&#39;, &#39;day&#39;, &#39;hour&#39;, &#39;minute&#39;,
&#39;second&#39;, &#39;millisecond&#39;]; // descending // Diffs the two
moments into a Duration where full-days are recorded first, then the
remaining time. // Moments will have their timezones normalized. function
diffDayTime(a, b) {</p>

<pre>return moment.duration({
    days: a.clone().stripTime().diff(b.clone().stripTime(), &#39;days&#39;),
    ms: a.time() - b.time() // time-of-day from day start. disregards timezone
});</pre>

<p>} exports.diffDayTime = diffDayTime; // Diffs the two moments via their
start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a, b) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">moment</span>.<span class="ruby-identifier">duration</span>({
    <span class="ruby-value">days:</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">clone</span>().<span class="ruby-identifier">stripTime</span>().<span class="ruby-identifier">diff</span>(<span class="ruby-identifier">b</span>.<span class="ruby-identifier">clone</span>().<span class="ruby-identifier">stripTime</span>(), <span class="ruby-string">&#39;days&#39;</span>)
});
</pre>

<p>} exports.diffDay = diffDay; // Diffs two moments, producing a duration,
made of a whole-unit-increment of the given unit. Uses rounding. function
diffByUnit(a, b, unit) {</p>

<pre>return moment.duration(Math.round(a.diff(b, unit, true)), // returnFloat=true
unit);</pre>

<p>} exports.diffByUnit = diffByUnit; // Computes the unit name of the largest
whole-unit period of time. // For example, 48 hours will be “days” whereas
49 hours will be “hours”. // Accepts start/end, a range object, or an
original duration object. function computeGreatestUnit(start, end) {</p>

<pre>var i;
var unit;
var val;
for (i = 0; i &lt; exports.unitsDesc.length; i++) {
    unit = exports.unitsDesc[i];
    val = computeRangeAs(unit, start, end);
    if (val &gt;= 1 &amp;&amp; isInt(val)) {
        break;
    }
}
return unit; // will be &quot;milliseconds&quot; if nothing else matches</pre>

<p>} exports.computeGreatestUnit = computeGreatestUnit; // like
computeGreatestUnit, but has special abilities to interpret the source
input for clues function computeDurationGreatestUnit(duration,
durationInput) {</p>

<pre>var unit = computeGreatestUnit(duration);
// prevent days:7 from being interpreted as a week
if (unit === &#39;week&#39; &amp;&amp; typeof durationInput === &#39;object&#39; &amp;&amp; durationInput.days) {
    unit = &#39;day&#39;;
}
return unit;</pre>

<p>} exports.computeDurationGreatestUnit = computeDurationGreatestUnit; //
Computes the number of units (like “hours”) in the given range. // Range
can be a {start,end} object, separate start/end args, or a Duration. //
Results are based on Moment&#39;s .as() and .diff() methods, so results can
depend on internal handling // of month-diffing logic (which tends to vary
from version to version). function computeRangeAs(unit, start, end) {</p>

<pre>if (end != null) {
    return end.diff(start, unit, true);
}
else if (moment.isDuration(start)) {
    return start.as(unit);
}
else {
    return start.end.diff(start.start, unit, true);
}</pre>

<p>} // Intelligently divides a range (specified by a start/end params) by a
duration function divideRangeByDuration(start, end, dur) {</p>

<pre>var months;
if (durationHasTime(dur)) {
    return (end - start) / dur;
}
months = dur.asMonths();
if (Math.abs(months) &gt;= 1 &amp;&amp; isInt(months)) {
    return end.diff(start, &#39;months&#39;, true) / months;
}
return end.diff(start, &#39;days&#39;, true) / dur.asDays();</pre>

<p>} exports.divideRangeByDuration = divideRangeByDuration; // Intelligently
divides one duration by another function divideDurationByDuration(dur1,
dur2) {</p>

<pre>var months1;
var months2;
if (durationHasTime(dur1) || durationHasTime(dur2)) {
    return dur1 / dur2;
}
months1 = dur1.asMonths();
months2 = dur2.asMonths();
if (Math.abs(months1) &gt;= 1 &amp;&amp; isInt(months1) &amp;&amp;
    Math.abs(months2) &gt;= 1 &amp;&amp; isInt(months2)) {
    return months1 / months2;
}
return dur1.asDays() / dur2.asDays();</pre>

<p>} exports.divideDurationByDuration = divideDurationByDuration; //
Intelligently multiplies a duration by a number function
multiplyDuration(dur, n) {</p>

<pre>var months;
if (durationHasTime(dur)) {
    return moment.duration(dur * n);
}
months = dur.asMonths();
if (Math.abs(months) &gt;= 1 &amp;&amp; isInt(months)) {
    return moment.duration({ months: months * n });
}
return moment.duration({ days: dur.asDays() * n });</pre>

<p>} exports.multiplyDuration = multiplyDuration; // Returns a boolean about
whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-constant">Boolean</span>(<span class="ruby-identifier">dur</span>.<span class="ruby-identifier">hours</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">dur</span>.<span class="ruby-identifier">minutes</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">dur</span>.<span class="ruby-identifier">seconds</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">dur</span>.<span class="ruby-identifier">milliseconds</span>());
</pre>

<p>} exports.durationHasTime = durationHasTime; function isNativeDate(input) {</p>

<pre>return Object.prototype.toString.call(input) === &#39;[object Date]&#39; || input instanceof Date;</pre>

<p>} exports.isNativeDate = isNativeDate; // Returns a boolean about whether
the given input is a time string, like “06:40:00” or “06:00” function
isTimeString(str) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">typeof</span> <span class="ruby-identifier">str</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;string&#39;</span> <span class="ruby-operator">&amp;&amp;</span>
    <span class="ruby-regexp">/^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">str</span>);
</pre>

<p>} exports.isTimeString = isTimeString; /* Logging and Debug
———————————————————————————————————————-*/ function log() {</p>

<pre>var args = [];
for (var _i = 0; _i &lt; arguments.length; _i++) {
    args[_i] = arguments[_i];
}
var console = window.console;
if (console &amp;&amp; console.log) {
    return console.log.apply(console, args);
}</pre>

<p>} exports.log = log; function warn() {</p>

<pre>var args = [];
for (var _i = 0; _i &lt; arguments.length; _i++) {
    args[_i] = arguments[_i];
}
var console = window.console;
if (console &amp;&amp; console.warn) {
    return console.warn.apply(console, args);
}
else {
    return log.apply(null, args);
}</pre>

<p>} exports.warn = warn; /* General Utilities
———————————————————————————————————————-*/ var hasOwnPropMethod =
{}.hasOwnProperty; // Merges an array of objects into a single object. //
The second argument allows for an array of property names who&#39;s object
values will be merged together. function mergeProps(propObjs, complexProps)
{</p>

<pre>var dest = {};
var i;
var name;
var complexObjs;
var j;
var val;
var props;
if (complexProps) {
    for (i = 0; i &lt; complexProps.length; i++) {
        name = complexProps[i];
        complexObjs = [];
        // collect the trailing object values, stopping when a non-object is discovered
        for (j = propObjs.length - 1; j &gt;= 0; j--) {
            val = propObjs[j][name];
            if (typeof val === &#39;object&#39;) {
                complexObjs.unshift(val);
            }
            else if (val !== undefined) {
                dest[name] = val; // if there were no objects, this value will be used
                break;
            }
        }
        // if the trailing values were objects, use the merged value
        if (complexObjs.length) {
            dest[name] = mergeProps(complexObjs);
        }
    }
}
// copy values into the destination, going from last to first
for (i = propObjs.length - 1; i &gt;= 0; i--) {
    props = propObjs[i];
    for (name in props) {
        if (!(name in dest)) {
            dest[name] = props[name];
        }
    }
}
return dest;</pre>

<p>} exports.mergeProps = mergeProps; function copyOwnProps(src, dest) {</p>

<pre>for (var name_1 in src) {
    if (hasOwnProp(src, name_1)) {
        dest[name_1] = src[name_1];
    }
}</pre>

<p>} exports.copyOwnProps = copyOwnProps; function hasOwnProp(obj, name) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">hasOwnPropMethod</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">obj</span>, <span class="ruby-identifier">name</span>);
</pre>

<p>} exports.hasOwnProp = hasOwnProp; function applyAll(functions, thisObj,
args) {</p>

<pre>if ($.isFunction(functions)) {
    functions = [functions];
}
if (functions) {
    var i = void 0;
    var ret = void 0;
    for (i = 0; i &lt; functions.length; i++) {
        ret = functions[i].apply(thisObj, args) || ret;
    }
    return ret;
}</pre>

<p>} exports.applyAll = applyAll; function removeMatching(array, testFunc) {</p>

<pre>var removeCnt = 0;
var i = 0;
while (i &lt; array.length) {
    if (testFunc(array[i])) {
        array.splice(i, 1);
        removeCnt++;
    }
    else {
        i++;
    }
}
return removeCnt;</pre>

<p>} exports.removeMatching = removeMatching; function removeExact(array,
exactVal) {</p>

<pre>var removeCnt = 0;
var i = 0;
while (i &lt; array.length) {
    if (array[i] === exactVal) {
        array.splice(i, 1);
        removeCnt++;
    }
    else {
        i++;
    }
}
return removeCnt;</pre>

<p>} exports.removeExact = removeExact; function isArraysEqual(a0, a1) {</p>

<pre>var len = a0.length;
var i;
if (len == null || len !== a1.length) {
    return false;
}
for (i = 0; i &lt; len; i++) {
    if (a0[i] !== a1[i]) {
        return false;
    }
}
return true;</pre>

<p>} exports.isArraysEqual = isArraysEqual; function firstDefined() {</p>

<pre>var args = [];
for (var _i = 0; _i &lt; arguments.length; _i++) {
    args[_i] = arguments[_i];
}
for (var i = 0; i &lt; args.length; i++) {
    if (args[i] !== undefined) {
        return args[i];
    }
}</pre>

<p>} exports.firstDefined = firstDefined; function htmlEscape(s) {</p>

<pre>return (s + &#39;&#39;).replace(/&amp;/g, &#39;&amp;amp;&#39;)
    .replace(/&lt;/g, &#39;&amp;lt;&#39;)
    .replace(/&gt;/g, &#39;&amp;gt;&#39;)
    .replace(/&#39;/g, &#39;&amp;#039;&#39;)
    .replace(/&quot;/g, &#39;&amp;quot;&#39;)
    .replace(/\n/g, &#39;&lt;br /&gt;&#39;);</pre>

<p>} exports.htmlEscape = htmlEscape; function stripHtmlEntities(text) {</p>

<pre>return text.replace(/&amp;.*?;/g, &#39;&#39;);</pre>

<p>} exports.stripHtmlEntities = stripHtmlEntities; // Given a hash of CSS
properties, returns a string of CSS. // Uses property names as-is (no
camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps) {</p>

<pre>var statements = [];
$.each(cssProps, function (name, val) {
    if (val != null) {
        statements.push(name + &#39;:&#39; + val);
    }
});
return statements.join(&#39;;&#39;);</pre>

<p>} exports.cssToStr = cssToStr; // Given an object hash of HTML attribute
names to values, // generates a string that can be injected between &lt;
&gt; in HTML function attrsToStr(attrs) {</p>

<pre>var parts = [];
$.each(attrs, function (name, val) {
    if (val != null) {
        parts.push(name + &#39;=&quot;&#39; + htmlEscape(val) + &#39;&quot;&#39;);
    }
});
return parts.join(&#39; &#39;);</pre>

<p>} exports.attrsToStr = attrsToStr; function capitaliseFirstLetter(str) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">str</span>.<span class="ruby-identifier">charAt</span>(<span class="ruby-value">0</span>).<span class="ruby-identifier">toUpperCase</span>() <span class="ruby-operator">+</span> <span class="ruby-identifier">str</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">1</span>);
</pre>

<p>} exports.capitaliseFirstLetter = capitaliseFirstLetter; function
compareNumbers(a, b) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">b</span>;
</pre>

<p>} exports.compareNumbers = compareNumbers; function isInt(n) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">n</span> <span class="ruby-operator">%</span> <span class="ruby-value">1</span> <span class="ruby-operator">===</span> <span class="ruby-value">0</span>;
</pre>

<p>} exports.isInt = isInt; // Returns a method bound to the given object
context. // Just like one of the jQuery.proxy signatures, but without the
undesired behavior of treating the same method with // different contexts
as identical when binding/unbinding events. function proxy(obj, methodName)
{</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">method</span> = <span class="ruby-identifier">obj</span>[<span class="ruby-identifier">methodName</span>];
<span class="ruby-keyword">return</span> <span class="ruby-identifier">function</span> () {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">method</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">obj</span>, <span class="ruby-identifier">arguments</span>);
};
</pre>

<p>} exports.proxy = proxy; // Returns a function, that, as long as it
continues to be invoked, will not // be triggered. The function will be
called after it stops being called for // N milliseconds. If `immediate` is
passed, trigger the function on the // leading edge, instead of the
trailing. // <a
href="https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714">github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714</a>
function debounce(func, wait, immediate) {</p>

<pre>if (immediate === void 0) { immediate = false; }
var timeout;
var args;
var context;
var timestamp;
var result;
var later = function () {
    var last = +new Date() - timestamp;
    if (last &lt; wait) {
        timeout = setTimeout(later, wait - last);
    }
    else {
        timeout = null;
        if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
        }
    }
};
return function () {
    context = this;
    args = arguments;
    timestamp = +new Date();
    var callNow = immediate &amp;&amp; !timeout;
    if (!timeout) {
        timeout = setTimeout(later, wait);
    }
    if (callNow) {
        result = func.apply(context, args);
        context = args = null;
    }
    return result;
};</pre>

<p>} exports.debounce = debounce;</p>

<p>/***/ }), /* 5 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var moment =
<em>webpack_require</em>(0); var moment_ext_1 =
<em>webpack_require</em>(10); var UnzonedRange = /** @class */ (function ()
{</p>

<pre>function UnzonedRange(startInput, endInput) {
    // TODO: move these into footprint.
    // Especially, doesn&#39;t make sense for null startMs/endMs.
    this.isStart = true;
    this.isEnd = true;
    if (moment.isMoment(startInput)) {
        startInput = startInput.clone().stripZone();
    }
    if (moment.isMoment(endInput)) {
        endInput = endInput.clone().stripZone();
    }
    if (startInput) {
        this.startMs = startInput.valueOf();
    }
    if (endInput) {
        this.endMs = endInput.valueOf();
    }
}
/*
SIDEEFFECT: will mutate eventRanges.
Will return a new array result.
Only works for non-open-ended ranges.
 /
UnzonedRange.invertRanges = function (ranges, constraintRange) {
    var invertedRanges = [];
    var startMs = constraintRange.startMs; // the end of the previous range. the start of the new range
    var i;
    var dateRange;
    // ranges need to be in order. required for our date-walking algorithm
    ranges.sort(compareUnzonedRanges);
    for (i = 0; i &lt; ranges.length; i++) {
        dateRange = ranges[i];
        // add the span of time before the event (if there is any)
        if (dateRange.startMs &gt; startMs) {
            invertedRanges.push(new UnzonedRange(startMs, dateRange.startMs));
        }
        if (dateRange.endMs &gt; startMs) {
            startMs = dateRange.endMs;
        }
    }
    // add the span of time after the last event (if there is any)
    if (startMs &lt; constraintRange.endMs) {
        invertedRanges.push(new UnzonedRange(startMs, constraintRange.endMs));
    }
    return invertedRanges;
};
UnzonedRange.prototype.intersect = function (otherRange) {
    var startMs = this.startMs;
    var endMs = this.endMs;
    var newRange = null;
    if (otherRange.startMs != null) {
        if (startMs == null) {
            startMs = otherRange.startMs;
        }
        else {
            startMs = Math.max(startMs, otherRange.startMs);
        }
    }
    if (otherRange.endMs != null) {
        if (endMs == null) {
            endMs = otherRange.endMs;
        }
        else {
            endMs = Math.min(endMs, otherRange.endMs);
        }
    }
    if (startMs == null || endMs == null || startMs &lt; endMs) {
        newRange = new UnzonedRange(startMs, endMs);
        newRange.isStart = this.isStart &amp;&amp; startMs === this.startMs;
        newRange.isEnd = this.isEnd &amp;&amp; endMs === this.endMs;
    }
    return newRange;
};
UnzonedRange.prototype.intersectsWith = function (otherRange) {
    return (this.endMs == null || otherRange.startMs == null || this.endMs &gt; otherRange.startMs) &amp;&amp;
        (this.startMs == null || otherRange.endMs == null || this.startMs &lt; otherRange.endMs);
};
UnzonedRange.prototype.containsRange = function (innerRange) {
    return (this.startMs == null || (innerRange.startMs != null &amp;&amp; innerRange.startMs &gt;= this.startMs)) &amp;&amp;
        (this.endMs == null || (innerRange.endMs != null &amp;&amp; innerRange.endMs &lt;= this.endMs));
};
// `date` can be a moment, a Date, or a millisecond time.
UnzonedRange.prototype.containsDate = function (date) {
    var ms = date.valueOf();
    return (this.startMs == null || ms &gt;= this.startMs) &amp;&amp;
        (this.endMs == null || ms &lt; this.endMs);
};
// If the given date is not within the given range, move it inside.
// (If it&#39;s past the end, make it one millisecond before the end).
// `date` can be a moment, a Date, or a millisecond time.
// Returns a MS-time.
UnzonedRange.prototype.constrainDate = function (date) {
    var ms = date.valueOf();
    if (this.startMs != null &amp;&amp; ms &lt; this.startMs) {
        ms = this.startMs;
    }
    if (this.endMs != null &amp;&amp; ms &gt;= this.endMs) {
        ms = this.endMs - 1;
    }
    return ms;
};
UnzonedRange.prototype.equals = function (otherRange) {
    return this.startMs === otherRange.startMs &amp;&amp; this.endMs === otherRange.endMs;
};
UnzonedRange.prototype.clone = function () {
    var range = new UnzonedRange(this.startMs, this.endMs);
    range.isStart = this.isStart;
    range.isEnd = this.isEnd;
    return range;
};
// Returns an ambig-zoned moment from startMs.
// BEWARE: returned moment is not localized.
// Formatting and start-of-week will be default.
UnzonedRange.prototype.getStart = function () {
    if (this.startMs != null) {
        return moment_ext_1.default.utc(this.startMs).stripZone();
    }
    return null;
};
// Returns an ambig-zoned moment from startMs.
// BEWARE: returned moment is not localized.
// Formatting and start-of-week will be default.
UnzonedRange.prototype.getEnd = function () {
    if (this.endMs != null) {
        return moment_ext_1.default.utc(this.endMs).stripZone();
    }
    return null;
};
UnzonedRange.prototype.as = function (unit) {
    return moment.utc(this.endMs).diff(moment.utc(this.startMs), unit, true);
};
return UnzonedRange;</pre>

<p>}()); exports.default = UnzonedRange; /* Only works for non-open-ended
ranges.</p>

<pre>/</pre>

<p>function compareUnzonedRanges(range1, range2) {</p>

<pre>return range1.startMs - range2.startMs; // earlier ranges go first</pre>

<p>}</p>

<p>/***/ }), /* 6 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
ParsableModelMixin_1 = <em>webpack_require</em>(208); var Class_1 =
<em>webpack_require</em>(33); var EventDefParser_1 =
<em>webpack_require</em>(49); var EventSource = /** @class */ (function
(_super) {</p>

<pre>tslib_1.__extends(EventSource, _super);
// can we do away with calendar? at least for the abstract?
// useful for buildEventDef
function EventSource(calendar) {
    var _this = _super.call(this) || this;
    _this.calendar = calendar;
    _this.className = [];
    _this.uid = String(EventSource.uuid++);
    return _this;
}
/*
rawInput can be any data type!
 /
EventSource.parse = function (rawInput, calendar) {
    var source = new this(calendar);
    if (typeof rawInput === &#39;object&#39;) {
        if (source.applyProps(rawInput)) {
            return source;
        }
    }
    return false;
};
EventSource.normalizeId = function (id) {
    if (id) {
        return String(id);
    }
    return null;
};
EventSource.prototype.fetch = function (start, end, timezone) {
    // subclasses must implement. must return a promise.
};
EventSource.prototype.removeEventDefsById = function (eventDefId) {
    // optional for subclasses to implement
};
EventSource.prototype.removeAllEventDefs = function () {
    // optional for subclasses to implement
};
/*
For compairing/matching
 /
EventSource.prototype.getPrimitive = function (otherSource) {
    // subclasses must implement
};
EventSource.prototype.parseEventDefs = function (rawEventDefs) {
    var i;
    var eventDef;
    var eventDefs = [];
    for (i = 0; i &lt; rawEventDefs.length; i++) {
        eventDef = this.parseEventDef(rawEventDefs[i]);
        if (eventDef) {
            eventDefs.push(eventDef);
        }
    }
    return eventDefs;
};
EventSource.prototype.parseEventDef = function (rawInput) {
    var calendarTransform = this.calendar.opt(&#39;eventDataTransform&#39;);
    var sourceTransform = this.eventDataTransform;
    if (calendarTransform) {
        rawInput = calendarTransform(rawInput, this.calendar);
    }
    if (sourceTransform) {
        rawInput = sourceTransform(rawInput, this.calendar);
    }
    return EventDefParser_1.default.parse(rawInput, this);
};
EventSource.prototype.applyManualStandardProps = function (rawProps) {
    if (rawProps.id != null) {
        this.id = EventSource.normalizeId(rawProps.id);
    }
    // TODO: converge with EventDef
    if ($.isArray(rawProps.className)) {
        this.className = rawProps.className;
    }
    else if (typeof rawProps.className === &#39;string&#39;) {
        this.className = rawProps.className.split(/\s+/);
    }
    return true;
};
EventSource.uuid = 0;
EventSource.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;
EventSource.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;
return EventSource;</pre>

<p>}(Class_1.default)); exports.default = EventSource;
ParsableModelMixin_1.default.mixInto(EventSource); // Parsing //
——————————————————————————————————————— EventSource.defineStandardProps({</p>

<pre>// manually process...
id: false,
className: false,
// automatically transfer...
color: true,
backgroundColor: true,
borderColor: true,
textColor: true,
editable: true,
startEditable: true,
durationEditable: true,
rendering: true,
overlap: true,
constraint: true,
allDayDefault: true,
eventDataTransform: true</pre>

<p>});</p>

<p>/***/ }), /* 7 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>/* Utility methods for easily listening to events on another object, and
more importantly, easily unlistening from them.</p>

<p>USAGE:</p>

<pre>import { default as ListenerMixin, ListenerInterface } from &#39;./ListenerMixin&#39;</pre>

<p>in class:</p>

<pre>listenTo: ListenerInterface[&#39;listenTo&#39;]
stopListeningTo: ListenerInterface[&#39;stopListeningTo&#39;]</pre>

<p>after class:</p>

<pre> ListenerMixin.mixInto(TheClass)
/</pre>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
Mixin_1 = <em>webpack_require</em>(14); var guid = 0; var ListenerMixin =
/** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(ListenerMixin, _super);
function ListenerMixin() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
/*
Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
The `callback` will be called with the `this` context of the object that .listenTo is being called on.
Can be called:
  .listenTo(other, eventName, callback)
OR
  .listenTo(other, {
    eventName1: callback1,
    eventName2: callback2
  })
 /
ListenerMixin.prototype.listenTo = function (other, arg, callback) {
    if (typeof arg === &#39;object&#39;) {
        for (var eventName in arg) {
            if (arg.hasOwnProperty(eventName)) {
                this.listenTo(other, eventName, arg[eventName]);
            }
        }
    }
    else if (typeof arg === &#39;string&#39;) {
        other.on(arg + &#39;.&#39; + this.getListenerNamespace(), // use event namespacing to identify this object
        $.proxy(callback, this) // always use `this` context
        // the usually-undesired jQuery guid behavior doesn&#39;t matter,
        // because we always unbind via namespace
        );
    }
};
/*
Causes the current object to stop listening to events on the `other` object.
`eventName` is optional. If omitted, will stop listening to ALL events on `other`.
 /
ListenerMixin.prototype.stopListeningTo = function (other, eventName) {
    other.off((eventName || &#39;&#39;) + &#39;.&#39; + this.getListenerNamespace());
};
/*
Returns a string, unique to this object, to be used for event namespacing
 /
ListenerMixin.prototype.getListenerNamespace = function () {
    if (this.listenerId == null) {
        this.listenerId = guid++;
    }
    return &#39;_listener&#39; + this.listenerId;
};
return ListenerMixin;</pre>

<p>}(Mixin_1.default)); exports.default = ListenerMixin;</p>

<p>/***/ }), /* 8 */, /* 9 */, /* 10 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var moment =
<em>webpack_require</em>(0); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var ambigDateOfMonthRegex =
/^s*d{4}-dd$/; var ambigTimeOrZoneRegex =
/^s*d{4}-(?:(dd-dd)|(Wdd$)|(Wdd-d)|(ddd))((T| )(dd(:dd(:dd(.d+)?)?)?)?)?$/;
var newMomentProto = moment.fn; // where we will attach our new methods
exports.newMomentProto = newMomentProto; var oldMomentProto = $.extend({},
newMomentProto); // copy of original moment methods exports.oldMomentProto
= oldMomentProto; // tell momentjs to transfer these properties upon clone
var momentProperties = moment.momentProperties;
momentProperties.push(&#39;_fullCalendar&#39;);
momentProperties.push(&#39;_ambigTime&#39;);
momentProperties.push(&#39;_ambigZone&#39;); /* Call this if you want
Moment&#39;s original format method to be used</p>

<pre>/</pre>

<p>function oldMomentFormat(mom, formatStr) {</p>

<pre>return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js</pre>

<p>} exports.oldMomentFormat = oldMomentFormat; // Creating //
————————————————————————————————- // Creates a new moment, similar to the
vanilla moment(…) constructor, but with // extra features (ambiguous time,
enhanced formatting). When given an existing moment, // it will function as
a clone (and retain the zone of the moment). Anything else will // result
in a moment in the local zone. var momentExt = function () {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">makeMoment</span>(<span class="ruby-identifier">arguments</span>);
</pre>

<p>}; exports.default = momentExt; // Sames as momentExt, but forces the
resulting moment to be in the UTC timezone. momentExt.utc = function () {</p>

<pre>var mom = makeMoment(arguments, true);
// Force it into UTC because makeMoment doesn&#39;t guarantee it
// (if given a pre-existing moment for example)
if (mom.hasTime()) {
    mom.utc();
}
return mom;</pre>

<p>}; // Same as momentExt, but when given an ISO8601 string, the timezone
offset is preserved. // ISO8601 strings with no timezone offset will become
ambiguously zoned. momentExt.parseZone = function () {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">makeMoment</span>(<span class="ruby-identifier">arguments</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">true</span>);
</pre>

<p>}; // Builds an enhanced moment from args. When given an existing moment,
it clones. When given a // native Date, or called with no arguments (the
current time), the resulting moment will be local. // Anything else needs
to be “parsed” (a string or an array), and will be affected by: //   
parseAsUTC - if there is no zone information, should we parse the input in
UTC? //    parseZone - if there is zone information, should we force the
zone of the moment? function makeMoment(args, parseAsUTC, parseZone) {</p>

<pre>if (parseAsUTC === void 0) { parseAsUTC = false; }
if (parseZone === void 0) { parseZone = false; }
var input = args[0];
var isSingleString = args.length === 1 &amp;&amp; typeof input === &#39;string&#39;;
var isAmbigTime;
var isAmbigZone;
var ambigMatch;
var mom;
if (moment.isMoment(input) || util_1.isNativeDate(input) || input === undefined) {
    mom = moment.apply(null, args);
}
else {
    isAmbigTime = false;
    isAmbigZone = false;
    if (isSingleString) {
        if (ambigDateOfMonthRegex.test(input)) {
            // accept strings like &#39;2014-05&#39;, but convert to the first of the month
            input += &#39;-01&#39;;
            args = [input]; // for when we pass it on to moment&#39;s constructor
            isAmbigTime = true;
            isAmbigZone = true;
        }
        else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
            isAmbigTime = !ambigMatch[5]; // no time part?
            isAmbigZone = true;
        }
    }
    else if ($.isArray(input)) {
        // arrays have no timezone information, so assume ambiguous zone
        isAmbigZone = true;
    }
    // otherwise, probably a string with a format
    if (parseAsUTC || isAmbigTime) {
        mom = moment.utc.apply(moment, args);
    }
    else {
        mom = moment.apply(null, args);
    }
    if (isAmbigTime) {
        mom._ambigTime = true;
        mom._ambigZone = true; // ambiguous time always means ambiguous zone
    }
    else if (parseZone) {
        if (isAmbigZone) {
            mom._ambigZone = true;
        }
        else if (isSingleString) {
            mom.utcOffset(input); // if not a valid zone, will assign UTC
        }
    }
}
mom._fullCalendar = true; // flag for extended functionality
return mom;</pre>

<p>} // Week Number // ————————————————————————————————- // Returns the week
number, considering the locale&#39;s custom week number calcuation //
`weeks` is an alias for `week` newMomentProto.week = newMomentProto.weeks =
function (input) {</p>

<pre>var weekCalc = this._locale._fullCalendar_weekCalc;
if (input == null &amp;&amp; typeof weekCalc === &#39;function&#39;) {
    return weekCalc(this);
}
else if (weekCalc === &#39;ISO&#39;) {
    return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
}
return oldMomentProto.week.apply(this, arguments); // local getter/setter</pre>

<p>}; // Time-of-day // ————————————————————————————————- // GETTER // Returns
a Duration with the hours/minutes/seconds/ms values of the moment. // If
the moment has an ambiguous time, a duration of 00:00 will be returned. //
// SETTER // You can supply a Duration, a Moment, or a Duration-like
argument. // When setting the time, and the moment has an ambiguous time,
it then becomes unambiguous. newMomentProto.time = function (time) {</p>

<pre>// Fallback to the original method (if there is one) if this moment wasn&#39;t created via FullCalendar.
// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
if (!this._fullCalendar) {
    return oldMomentProto.time.apply(this, arguments);
}
if (time == null) {
    return moment.duration({
        hours: this.hours(),
        minutes: this.minutes(),
        seconds: this.seconds(),
        milliseconds: this.milliseconds()
    });
}
else {
    this._ambigTime = false; // mark that the moment now has a time
    if (!moment.isDuration(time) &amp;&amp; !moment.isMoment(time)) {
        time = moment.duration(time);
    }
    // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
    // Only for Duration times, not Moment times.
    var dayHours = 0;
    if (moment.isDuration(time)) {
        dayHours = Math.floor(time.asDays()) * 24;
    }
    // We need to set the individual fields.
    // Can&#39;t use startOf(&#39;day&#39;) then add duration. In case of DST at start of day.
    return this.hours(dayHours + time.hours())
        .minutes(time.minutes())
        .seconds(time.seconds())
        .milliseconds(time.milliseconds());
}</pre>

<p>}; // Converts the moment to UTC, stripping out its time-of-day and
timezone offset, // but preserving its YMD. A moment with a stripped time
will display no time // nor timezone offset when .format() is called.
newMomentProto.stripTime = function () {</p>

<pre>if (!this._ambigTime) {
    this.utc(true); // keepLocalTime=true (for keeping *date* value)
    // set time to zero
    this.set({
        hours: 0,
        minutes: 0,
        seconds: 0,
        ms: 0
    });
    // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
    // which clears all ambig flags.
    this._ambigTime = true;
    this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
}
return this; // for chaining</pre>

<p>}; // Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime = function () {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">_ambigTime</span>;
</pre>

<p>}; // Timezone // ————————————————————————————————- // Converts the moment
to UTC, stripping out its timezone offset, but preserving its // YMD and
time-of-day. A moment with a stripped timezone offset will display no //
timezone offset when .format() is called. newMomentProto.stripZone =
function () {</p>

<pre>var wasAmbigTime;
if (!this._ambigZone) {
    wasAmbigTime = this._ambigTime;
    this.utc(true); // keepLocalTime=true (for keeping date and time values)
    // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
    this._ambigTime = wasAmbigTime || false;
    // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
    // which clears the ambig flags.
    this._ambigZone = true;
}
return this; // for chaining</pre>

<p>}; // Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone = function () {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">_ambigZone</span>;
</pre>

<p>}; // implicitly marks a zone newMomentProto.local = function
(keepLocalTime) {</p>

<pre>// for when converting from ambiguously-zoned to local,
// keep the time values when converting from UTC -&gt; local
oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);
// ensure non-ambiguous
// this probably already happened via local() -&gt; utcOffset(), but don&#39;t rely on Moment&#39;s internals
this._ambigTime = false;
this._ambigZone = false;
return this; // for chaining</pre>

<p>}; // implicitly marks a zone newMomentProto.utc = function (keepLocalTime)
{</p>

<pre>oldMomentProto.utc.call(this, keepLocalTime);
// ensure non-ambiguous
// this probably already happened via utc() -&gt; utcOffset(), but don&#39;t rely on Moment&#39;s internals
this._ambigTime = false;
this._ambigZone = false;
return this;</pre>

<p>}; // implicitly marks a zone (will probably get called upon .utc() and
.local()) newMomentProto.utcOffset = function (tzo) {</p>

<pre>if (tzo != null) {
    // these assignments needs to happen before the original zone method is called.
    // I forget why, something to do with a browser crash.
    this._ambigTime = false;
    this._ambigZone = false;
}
return oldMomentProto.utcOffset.apply(this, arguments);</pre>

<p>};</p>

<p>/***/ }), /* 11 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>/* USAGE:</p>

<pre>import { default as EmitterMixin, EmitterInterface } from &#39;./EmitterMixin&#39;</pre>

<p>in class:</p>

<pre>on: EmitterInterface[&#39;on&#39;]
one: EmitterInterface[&#39;one&#39;]
off: EmitterInterface[&#39;off&#39;]
trigger: EmitterInterface[&#39;trigger&#39;]
triggerWith: EmitterInterface[&#39;triggerWith&#39;]
hasHandlers: EmitterInterface[&#39;hasHandlers&#39;]</pre>

<p>after class:</p>

<pre> EmitterMixin.mixInto(TheClass)
/</pre>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
Mixin_1 = <em>webpack_require</em>(14); var EmitterMixin = /** @class */
(function (_super) {</p>

<pre>tslib_1.__extends(EmitterMixin, _super);
function EmitterMixin() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
// jQuery-ification via $(this) allows a non-DOM object to have
// the same event handling capabilities (including namespaces).
EmitterMixin.prototype.on = function (types, handler) {
    $(this).on(types, this._prepareIntercept(handler));
    return this; // for chaining
};
EmitterMixin.prototype.one = function (types, handler) {
    $(this).one(types, this._prepareIntercept(handler));
    return this; // for chaining
};
EmitterMixin.prototype._prepareIntercept = function (handler) {
    // handlers are always called with an &quot;event&quot; object as their first param.
    // sneak the `this` context and arguments into the extra parameter object
    // and forward them on to the original handler.
    var intercept = function (ev, extra) {
        return handler.apply(extra.context || this, extra.args || []);
    };
    // mimick jQuery&#39;s internal &quot;proxy&quot; system (risky, I know)
    // causing all functions with the same .guid to appear to be the same.
    // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
    // this is needed for calling .off with the original non-intercept handler.
    if (!handler.guid) {
        handler.guid = $.guid++;
    }
    intercept.guid = handler.guid;
    return intercept;
};
EmitterMixin.prototype.off = function (types, handler) {
    $(this).off(types, handler);
    return this; // for chaining
};
EmitterMixin.prototype.trigger = function (types) {
    var args = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    // pass in &quot;extra&quot; info to the intercept
    $(this).triggerHandler(types, { args: args });
    return this; // for chaining
};
EmitterMixin.prototype.triggerWith = function (types, context, args) {
    // `triggerHandler` is less reliant on the DOM compared to `trigger`.
    // pass in &quot;extra&quot; info to the intercept.
    $(this).triggerHandler(types, { context: context, args: args });
    return this; // for chaining
};
EmitterMixin.prototype.hasHandlers = function (type) {
    var hash = $._data(this, &#39;events&#39;); // http://blog.jquery.com/2012/08/09/jquery-1-8-released/
    return hash &amp;&amp; hash[type] &amp;&amp; hash[type].length &gt; 0;
};
return EmitterMixin;</pre>

<p>}(Mixin_1.default)); exports.default = EmitterMixin;</p>

<p>/***/ }), /* 12 */ /***/ (function(module, exports) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); /* Meant to
be immutable</p>

<pre>/</pre>

<p>var ComponentFootprint = /** @class */ (function () {</p>

<pre>function ComponentFootprint(unzonedRange, isAllDay) {
    this.isAllDay = false; // component can choose to ignore this
    this.unzonedRange = unzonedRange;
    this.isAllDay = isAllDay;
}
/*
Only works for non-open-ended ranges.
 /
ComponentFootprint.prototype.toLegacy = function (calendar) {
    return {
        start: calendar.msToMoment(this.unzonedRange.startMs, this.isAllDay),
        end: calendar.msToMoment(this.unzonedRange.endMs, this.isAllDay)
    };
};
return ComponentFootprint;</pre>

<p>}()); exports.default = ComponentFootprint;</p>

<p>/***/ }), /* 13 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var EventDef_1 =
<em>webpack_require</em>(34); var EventInstance_1 =
<em>webpack_require</em>(209); var EventDateProfile_1 =
<em>webpack_require</em>(17); var SingleEventDef = /** @class */ (function
(_super) {</p>

<pre>tslib_1.__extends(SingleEventDef, _super);
function SingleEventDef() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
/*
Will receive start/end params, but will be ignored.
 /
SingleEventDef.prototype.buildInstances = function () {
    return [this.buildInstance()];
};
SingleEventDef.prototype.buildInstance = function () {
    return new EventInstance_1.default(this, // definition
    this.dateProfile);
};
SingleEventDef.prototype.isAllDay = function () {
    return this.dateProfile.isAllDay();
};
SingleEventDef.prototype.clone = function () {
    var def = _super.prototype.clone.call(this);
    def.dateProfile = this.dateProfile;
    return def;
};
SingleEventDef.prototype.rezone = function () {
    var calendar = this.source.calendar;
    var dateProfile = this.dateProfile;
    this.dateProfile = new EventDateProfile_1.default(calendar.moment(dateProfile.start), dateProfile.end ? calendar.moment(dateProfile.end) : null, calendar);
};
/*
NOTE: if super-method fails, should still attempt to apply
 /
SingleEventDef.prototype.applyManualStandardProps = function (rawProps) {
    var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
    var dateProfile = EventDateProfile_1.default.parse(rawProps, this.source); // returns null on failure
    if (dateProfile) {
        this.dateProfile = dateProfile;
        // make sure `date` shows up in the legacy event objects as-is
        if (rawProps.date != null) {
            this.miscProps.date = rawProps.date;
        }
        return superSuccess;
    }
    else {
        return false;
    }
};
return SingleEventDef;</pre>

<p>}(EventDef_1.default)); exports.default = SingleEventDef; // Parsing //
———————————————————————————————————————
SingleEventDef.defineStandardProps({</p>

<pre>start: false,
date: false,
end: false,
allDay: false</pre>

<p>});</p>

<p>/***/ }), /* 14 */ /***/ (function(module, exports) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var Mixin =
/** @class */ (function () {</p>

<pre>function Mixin() {
}
Mixin.mixInto = function (destClass) {
    var _this = this;
    Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
        if (!destClass.prototype[name]) {
            destClass.prototype[name] = _this.prototype[name];
        }
    });
};
/*
will override existing methods
TODO: remove! not used anymore
 /
Mixin.mixOver = function (destClass) {
    var _this = this;
    Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
        destClass.prototype[name] = _this.prototype[name];
    });
};
return Mixin;</pre>

<p>}()); exports.default = Mixin;</p>

<p>/***/ }), /* 15 */ /***/ (function(module, exports) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
Interaction = /** @class */ (function () {</p>

<pre>function Interaction(component) {
    this.view = component._getView();
    this.component = component;
}
Interaction.prototype.opt = function (name) {
    return this.view.opt(name);
};
Interaction.prototype.end = function () {
    // subclasses can implement
};
return Interaction;</pre>

<p>}()); exports.default = Interaction;</p>

<p>/***/ }), /* 16 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true });
exports.version = &#39;3.9.0&#39;; // When introducing internal API
incompatibilities (where fullcalendar plugins would break), // the minor
version of the calendar should be upped (ex: 2.7.2 -&gt; 2.8.0) // and the
below integer should be incremented. exports.internalApiVersion = 12; var
util_1 = <em>webpack_require</em>(4); exports.applyAll = util_1.applyAll;
exports.debounce = util_1.debounce; exports.isInt = util_1.isInt;
exports.htmlEscape = util_1.htmlEscape; exports.cssToStr = util_1.cssToStr;
exports.proxy = util_1.proxy; exports.capitaliseFirstLetter =
util_1.capitaliseFirstLetter; exports.getOuterRect = util_1.getOuterRect;
exports.getClientRect = util_1.getClientRect; exports.getContentRect =
util_1.getContentRect; exports.getScrollbarWidths =
util_1.getScrollbarWidths; exports.preventDefault = util_1.preventDefault;
exports.parseFieldSpecs = util_1.parseFieldSpecs;
exports.compareByFieldSpecs = util_1.compareByFieldSpecs;
exports.compareByFieldSpec = util_1.compareByFieldSpec;
exports.flexibleCompare = util_1.flexibleCompare;
exports.computeGreatestUnit = util_1.computeGreatestUnit;
exports.divideRangeByDuration = util_1.divideRangeByDuration;
exports.divideDurationByDuration = util_1.divideDurationByDuration;
exports.multiplyDuration = util_1.multiplyDuration; exports.durationHasTime
= util_1.durationHasTime; exports.log = util_1.log; exports.warn =
util_1.warn; exports.removeExact = util_1.removeExact;
exports.intersectRects = util_1.intersectRects; var date_formatting_1 =
<em>webpack_require</em>(47); exports.formatDate =
date_formatting_1.formatDate; exports.formatRange =
date_formatting_1.formatRange; exports.queryMostGranularFormatUnit =
date_formatting_1.queryMostGranularFormatUnit; var locale_1 =
<em>webpack_require</em>(31); exports.datepickerLocale =
locale_1.datepickerLocale; exports.locale = locale_1.locale; var
moment_ext_1 = <em>webpack_require</em>(10); exports.moment =
moment_ext_1.default; var EmitterMixin_1 = <em>webpack_require</em>(11);
exports.EmitterMixin = EmitterMixin_1.default; var ListenerMixin_1 =
<em>webpack_require</em>(7); exports.ListenerMixin =
ListenerMixin_1.default; var Model_1 = <em>webpack_require</em>(48);
exports.Model = Model_1.default; var Constraints_1 =
<em>webpack_require</em>(207); exports.Constraints = Constraints_1.default;
var UnzonedRange_1 = <em>webpack_require</em>(5); exports.UnzonedRange =
UnzonedRange_1.default; var ComponentFootprint_1 =
<em>webpack_require</em>(12); exports.ComponentFootprint =
ComponentFootprint_1.default; var BusinessHourGenerator_1 =
<em>webpack_require</em>(212); exports.BusinessHourGenerator =
BusinessHourGenerator_1.default; var EventDef_1 =
<em>webpack_require</em>(34); exports.EventDef = EventDef_1.default; var
EventDefMutation_1 = <em>webpack_require</em>(37); exports.EventDefMutation
= EventDefMutation_1.default; var EventSourceParser_1 =
<em>webpack_require</em>(38); exports.EventSourceParser =
EventSourceParser_1.default; var EventSource_1 =
<em>webpack_require</em>(6); exports.EventSource = EventSource_1.default;
var ThemeRegistry_1 = <em>webpack_require</em>(51);
exports.defineThemeSystem = ThemeRegistry_1.defineThemeSystem; var
EventInstanceGroup_1 = <em>webpack_require</em>(18);
exports.EventInstanceGroup = EventInstanceGroup_1.default; var
ArrayEventSource_1 = <em>webpack_require</em>(52); exports.ArrayEventSource
= ArrayEventSource_1.default; var FuncEventSource_1 =
<em>webpack_require</em>(215); exports.FuncEventSource =
FuncEventSource_1.default; var JsonFeedEventSource_1 =
<em>webpack_require</em>(216); exports.JsonFeedEventSource =
JsonFeedEventSource_1.default; var EventFootprint_1 =
<em>webpack_require</em>(36); exports.EventFootprint =
EventFootprint_1.default; var Class_1 = <em>webpack_require</em>(33);
exports.Class = Class_1.default; var Mixin_1 =
<em>webpack_require</em>(14); exports.Mixin = Mixin_1.default; var
CoordCache_1 = <em>webpack_require</em>(53); exports.CoordCache =
CoordCache_1.default; var DragListener_1 = <em>webpack_require</em>(54);
exports.DragListener = DragListener_1.default; var Promise_1 =
<em>webpack_require</em>(20); exports.Promise = Promise_1.default; var
TaskQueue_1 = <em>webpack_require</em>(217); exports.TaskQueue =
TaskQueue_1.default; var RenderQueue_1 = <em>webpack_require</em>(218);
exports.RenderQueue = RenderQueue_1.default; var Scroller_1 =
<em>webpack_require</em>(39); exports.Scroller = Scroller_1.default; var
Theme_1 = <em>webpack_require</em>(19); exports.Theme = Theme_1.default;
var DateComponent_1 = <em>webpack_require</em>(219); exports.DateComponent
= DateComponent_1.default; var InteractiveDateComponent_1 =
<em>webpack_require</em>(40); exports.InteractiveDateComponent =
InteractiveDateComponent_1.default; var Calendar_1 =
<em>webpack_require</em>(220); exports.Calendar = Calendar_1.default; var
View_1 = <em>webpack_require</em>(41); exports.View = View_1.default; var
ViewRegistry_1 = <em>webpack_require</em>(22); exports.defineView =
ViewRegistry_1.defineView; exports.getViewConfig =
ViewRegistry_1.getViewConfig; var DayTableMixin_1 =
<em>webpack_require</em>(55); exports.DayTableMixin =
DayTableMixin_1.default; var BusinessHourRenderer_1 =
<em>webpack_require</em>(56); exports.BusinessHourRenderer =
BusinessHourRenderer_1.default; var EventRenderer_1 =
<em>webpack_require</em>(42); exports.EventRenderer =
EventRenderer_1.default; var FillRenderer_1 = <em>webpack_require</em>(57);
exports.FillRenderer = FillRenderer_1.default; var HelperRenderer_1 =
<em>webpack_require</em>(58); exports.HelperRenderer =
HelperRenderer_1.default; var ExternalDropping_1 =
<em>webpack_require</em>(222); exports.ExternalDropping =
ExternalDropping_1.default; var EventResizing_1 =
<em>webpack_require</em>(223); exports.EventResizing =
EventResizing_1.default; var EventPointing_1 =
<em>webpack_require</em>(59); exports.EventPointing =
EventPointing_1.default; var EventDragging_1 =
<em>webpack_require</em>(224); exports.EventDragging =
EventDragging_1.default; var DateSelecting_1 =
<em>webpack_require</em>(225); exports.DateSelecting =
DateSelecting_1.default; var StandardInteractionsMixin_1 =
<em>webpack_require</em>(60); exports.StandardInteractionsMixin =
StandardInteractionsMixin_1.default; var AgendaView_1 =
<em>webpack_require</em>(226); exports.AgendaView = AgendaView_1.default;
var TimeGrid_1 = <em>webpack_require</em>(227); exports.TimeGrid =
TimeGrid_1.default; var DayGrid_1 = <em>webpack_require</em>(61);
exports.DayGrid = DayGrid_1.default; var BasicView_1 =
<em>webpack_require</em>(62); exports.BasicView = BasicView_1.default; var
MonthView_1 = <em>webpack_require</em>(229); exports.MonthView =
MonthView_1.default; var ListView_1 = <em>webpack_require</em>(230);
exports.ListView = ListView_1.default;</p>

<p>/***/ }), /* 17 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
UnzonedRange_1 = <em>webpack_require</em>(5); /* Meant to be immutable</p>

<pre>/</pre>

<p>var EventDateProfile = /** @class */ (function () {</p>

<pre>function EventDateProfile(start, end, calendar) {
    this.start = start;
    this.end = end || null;
    this.unzonedRange = this.buildUnzonedRange(calendar);
}
/*
Needs an EventSource object
 /
EventDateProfile.parse = function (rawProps, source) {
    var startInput = rawProps.start || rawProps.date;
    var endInput = rawProps.end;
    if (!startInput) {
        return false;
    }
    var calendar = source.calendar;
    var start = calendar.moment(startInput);
    var end = endInput ? calendar.moment(endInput) : null;
    var forcedAllDay = rawProps.allDay;
    var forceEventDuration = calendar.opt(&#39;forceEventDuration&#39;);
    if (!start.isValid()) {
        return false;
    }
    if (end &amp;&amp; (!end.isValid() || !end.isAfter(start))) {
        end = null;
    }
    if (forcedAllDay == null) {
        forcedAllDay = source.allDayDefault;
        if (forcedAllDay == null) {
            forcedAllDay = calendar.opt(&#39;allDayDefault&#39;);
        }
    }
    if (forcedAllDay === true) {
        start.stripTime();
        if (end) {
            end.stripTime();
        }
    }
    else if (forcedAllDay === false) {
        if (!start.hasTime()) {
            start.time(0);
        }
        if (end &amp;&amp; !end.hasTime()) {
            end.time(0);
        }
    }
    if (!end &amp;&amp; forceEventDuration) {
        end = calendar.getDefaultEventEnd(!start.hasTime(), start);
    }
    return new EventDateProfile(start, end, calendar);
};
EventDateProfile.isStandardProp = function (propName) {
    return propName === &#39;start&#39; || propName === &#39;date&#39; || propName === &#39;end&#39; || propName === &#39;allDay&#39;;
};
EventDateProfile.prototype.isAllDay = function () {
    return !(this.start.hasTime() || (this.end &amp;&amp; this.end.hasTime()));
};
/*
Needs a Calendar object
 /
EventDateProfile.prototype.buildUnzonedRange = function (calendar) {
    var startMs = this.start.clone().stripZone().valueOf();
    var endMs = this.getEnd(calendar).stripZone().valueOf();
    return new UnzonedRange_1.default(startMs, endMs);
};
/*
Needs a Calendar object
 /
EventDateProfile.prototype.getEnd = function (calendar) {
    return this.end ?
        this.end.clone() :
        // derive the end from the start and allDay. compute allDay if necessary
        calendar.getDefaultEventEnd(this.isAllDay(), this.start);
};
return EventDateProfile;</pre>

<p>}()); exports.default = EventDateProfile;</p>

<p>/***/ }), /* 18 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
UnzonedRange_1 = <em>webpack_require</em>(5); var util_1 =
<em>webpack_require</em>(35); var EventRange_1 =
<em>webpack_require</em>(211); /* It&#39;s expected that there will be at
least one EventInstance, OR that an explicitEventDef is assigned.</p>

<pre>/</pre>

<p>var EventInstanceGroup = /** @class */ (function () {</p>

<pre>function EventInstanceGroup(eventInstances) {
    this.eventInstances = eventInstances || [];
}
EventInstanceGroup.prototype.getAllEventRanges = function (constraintRange) {
    if (constraintRange) {
        return this.sliceNormalRenderRanges(constraintRange);
    }
    else {
        return this.eventInstances.map(util_1.eventInstanceToEventRange);
    }
};
EventInstanceGroup.prototype.sliceRenderRanges = function (constraintRange) {
    if (this.isInverse()) {
        return this.sliceInverseRenderRanges(constraintRange);
    }
    else {
        return this.sliceNormalRenderRanges(constraintRange);
    }
};
EventInstanceGroup.prototype.sliceNormalRenderRanges = function (constraintRange) {
    var eventInstances = this.eventInstances;
    var i;
    var eventInstance;
    var slicedRange;
    var slicedEventRanges = [];
    for (i = 0; i &lt; eventInstances.length; i++) {
        eventInstance = eventInstances[i];
        slicedRange = eventInstance.dateProfile.unzonedRange.intersect(constraintRange);
        if (slicedRange) {
            slicedEventRanges.push(new EventRange_1.default(slicedRange, eventInstance.def, eventInstance));
        }
    }
    return slicedEventRanges;
};
EventInstanceGroup.prototype.sliceInverseRenderRanges = function (constraintRange) {
    var unzonedRanges = this.eventInstances.map(util_1.eventInstanceToUnzonedRange);
    var ownerDef = this.getEventDef();
    unzonedRanges = UnzonedRange_1.default.invertRanges(unzonedRanges, constraintRange);
    return unzonedRanges.map(function (unzonedRange) {
        return new EventRange_1.default(unzonedRange, ownerDef); // don&#39;t give an EventInstance
    });
};
EventInstanceGroup.prototype.isInverse = function () {
    return this.getEventDef().hasInverseRendering();
};
EventInstanceGroup.prototype.getEventDef = function () {
    return this.explicitEventDef || this.eventInstances[0].def;
};
return EventInstanceGroup;</pre>

<p>}()); exports.default = EventInstanceGroup;</p>

<p>/***/ }), /* 19 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var Theme = /** @class */ (function () {</p>

<pre>function Theme(optionsManager) {
    this.optionsManager = optionsManager;
    this.processIconOverride();
}
Theme.prototype.processIconOverride = function () {
    if (this.iconOverrideOption) {
        this.setIconOverride(this.optionsManager.get(this.iconOverrideOption));
    }
};
Theme.prototype.setIconOverride = function (iconOverrideHash) {
    var iconClassesCopy;
    var buttonName;
    if ($.isPlainObject(iconOverrideHash)) {
        iconClassesCopy = $.extend({}, this.iconClasses);
        for (buttonName in iconOverrideHash) {
            iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
        }
        this.iconClasses = iconClassesCopy;
    }
    else if (iconOverrideHash === false) {
        this.iconClasses = {};
    }
};
Theme.prototype.applyIconOverridePrefix = function (className) {
    var prefix = this.iconOverridePrefix;
    if (prefix &amp;&amp; className.indexOf(prefix) !== 0) {
        className = prefix + className;
    }
    return className;
};
Theme.prototype.getClass = function (key) {
    return this.classes[key] || &#39;&#39;;
};
Theme.prototype.getIconClass = function (buttonName) {
    var className = this.iconClasses[buttonName];
    if (className) {
        return this.baseIconClass + &#39; &#39; + className;
    }
    return &#39;&#39;;
};
Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
    var className;
    if (this.iconOverrideCustomButtonOption) {
        className = customButtonProps[this.iconOverrideCustomButtonOption];
        if (className) {
            return this.baseIconClass + &#39; &#39; + this.applyIconOverridePrefix(className);
        }
    }
    return &#39;&#39;;
};
return Theme;</pre>

<p>}()); exports.default = Theme; Theme.prototype.classes = {};
Theme.prototype.iconClasses = {}; Theme.prototype.baseIconClass =
&#39;&#39;; Theme.prototype.iconOverridePrefix = &#39;&#39;;</p>

<p>/***/ }), /* 20 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var PromiseStub = {</p>

<pre>construct: function (executor) {
    var deferred = $.Deferred();
    var promise = deferred.promise();
    if (typeof executor === &#39;function&#39;) {
        executor(function (val) {
            deferred.resolve(val);
            attachImmediatelyResolvingThen(promise, val);
        }, function () {
            deferred.reject();
            attachImmediatelyRejectingThen(promise);
        });
    }
    return promise;
},
resolve: function (val) {
    var deferred = $.Deferred().resolve(val);
    var promise = deferred.promise();
    attachImmediatelyResolvingThen(promise, val);
    return promise;
},
reject: function () {
    var deferred = $.Deferred().reject();
    var promise = deferred.promise();
    attachImmediatelyRejectingThen(promise);
    return promise;
}</pre>

<p>}; exports.default = PromiseStub; function
attachImmediatelyResolvingThen(promise, val) {</p>

<pre>promise.then = function (onResolve) {
    if (typeof onResolve === &#39;function&#39;) {
        return PromiseStub.resolve(onResolve(val));
    }
    return promise;
};</pre>

<p>} function attachImmediatelyRejectingThen(promise) {</p>

<pre>promise.then = function (onResolve, onReject) {
    if (typeof onReject === &#39;function&#39;) {
        onReject();
    }
    return promise;
};</pre>

<p>}</p>

<p>/***/ }), /* 21 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var exportHooks =
<em>webpack_require</em>(16); var EmitterMixin_1 =
<em>webpack_require</em>(11); var ListenerMixin_1 =
<em>webpack_require</em>(7); exportHooks.touchMouseIgnoreWait = 500; var
globalEmitter = null; var neededCount = 0; /* Listens to document and
window-level user-interaction events, like touch events and mouse events,
and fires these events as-is to whoever is observing a GlobalEmitter. Best
when used as a singleton via GlobalEmitter.get()</p>

<p>Normalizes mouse/touch events. For examples:</p>
<ul><li>
<p>ignores the the simulated mouse events that happen after a quick tap:
mousemove+mousedown+mouseup+click</p>
</li><li>
<p>compensates for various buggy scenarios where a touchend does not fire</p>
</li></ul>

<pre>/</pre>

<p>var GlobalEmitter = /** @class */ (function () {</p>

<pre>function GlobalEmitter() {
    this.isTouching = false;
    this.mouseIgnoreDepth = 0;
}
// gets the singleton
GlobalEmitter.get = function () {
    if (!globalEmitter) {
        globalEmitter = new GlobalEmitter();
        globalEmitter.bind();
    }
    return globalEmitter;
};
// called when an object knows it will need a GlobalEmitter in the near future.
GlobalEmitter.needed = function () {
    GlobalEmitter.get(); // ensures globalEmitter
    neededCount++;
};
// called when the object that originally called needed() doesn&#39;t need a GlobalEmitter anymore.
GlobalEmitter.unneeded = function () {
    neededCount--;
    if (!neededCount) {
        globalEmitter.unbind();
        globalEmitter = null;
    }
};
GlobalEmitter.prototype.bind = function () {
    var _this = this;
    this.listenTo($(document), {
        touchstart: this.handleTouchStart,
        touchcancel: this.handleTouchCancel,
        touchend: this.handleTouchEnd,
        mousedown: this.handleMouseDown,
        mousemove: this.handleMouseMove,
        mouseup: this.handleMouseUp,
        click: this.handleClick,
        selectstart: this.handleSelectStart,
        contextmenu: this.handleContextMenu
    });
    // because we need to call preventDefault
    // because https://www.chromestatus.com/features/5093566007214080
    // TODO: investigate performance because this is a global handler
    window.addEventListener(&#39;touchmove&#39;, this.handleTouchMoveProxy = function (ev) {
        _this.handleTouchMove($.Event(ev));
    }, { passive: false } // allows preventDefault()
    );
    // attach a handler to get called when ANY scroll action happens on the page.
    // this was impossible to do with normal on/off because &#39;scroll&#39; doesn&#39;t bubble.
    // http://stackoverflow.com/a/32954565/96342
    window.addEventListener(&#39;scroll&#39;, this.handleScrollProxy = function (ev) {
        _this.handleScroll($.Event(ev));
    }, true // useCapture
    );
};
GlobalEmitter.prototype.unbind = function () {
    this.stopListeningTo($(document));
    window.removeEventListener(&#39;touchmove&#39;, this.handleTouchMoveProxy);
    window.removeEventListener(&#39;scroll&#39;, this.handleScrollProxy, true // useCapture
    );
};
// Touch Handlers
// -----------------------------------------------------------------------------------------------------------------
GlobalEmitter.prototype.handleTouchStart = function (ev) {
    // if a previous touch interaction never ended with a touchend, then implicitly end it,
    // but since a new touch interaction is about to begin, don&#39;t start the mouse ignore period.
    this.stopTouch(ev, true); // skipMouseIgnore=true
    this.isTouching = true;
    this.trigger(&#39;touchstart&#39;, ev);
};
GlobalEmitter.prototype.handleTouchMove = function (ev) {
    if (this.isTouching) {
        this.trigger(&#39;touchmove&#39;, ev);
    }
};
GlobalEmitter.prototype.handleTouchCancel = function (ev) {
    if (this.isTouching) {
        this.trigger(&#39;touchcancel&#39;, ev);
        // Have touchcancel fire an artificial touchend. That way, handlers won&#39;t need to listen to both.
        // If touchend fires later, it won&#39;t have any effect b/c isTouching will be false.
        this.stopTouch(ev);
    }
};
GlobalEmitter.prototype.handleTouchEnd = function (ev) {
    this.stopTouch(ev);
};
// Mouse Handlers
// -----------------------------------------------------------------------------------------------------------------
GlobalEmitter.prototype.handleMouseDown = function (ev) {
    if (!this.shouldIgnoreMouse()) {
        this.trigger(&#39;mousedown&#39;, ev);
    }
};
GlobalEmitter.prototype.handleMouseMove = function (ev) {
    if (!this.shouldIgnoreMouse()) {
        this.trigger(&#39;mousemove&#39;, ev);
    }
};
GlobalEmitter.prototype.handleMouseUp = function (ev) {
    if (!this.shouldIgnoreMouse()) {
        this.trigger(&#39;mouseup&#39;, ev);
    }
};
GlobalEmitter.prototype.handleClick = function (ev) {
    if (!this.shouldIgnoreMouse()) {
        this.trigger(&#39;click&#39;, ev);
    }
};
// Misc Handlers
// -----------------------------------------------------------------------------------------------------------------
GlobalEmitter.prototype.handleSelectStart = function (ev) {
    this.trigger(&#39;selectstart&#39;, ev);
};
GlobalEmitter.prototype.handleContextMenu = function (ev) {
    this.trigger(&#39;contextmenu&#39;, ev);
};
GlobalEmitter.prototype.handleScroll = function (ev) {
    this.trigger(&#39;scroll&#39;, ev);
};
// Utils
// -----------------------------------------------------------------------------------------------------------------
GlobalEmitter.prototype.stopTouch = function (ev, skipMouseIgnore) {
    if (skipMouseIgnore === void 0) { skipMouseIgnore = false; }
    if (this.isTouching) {
        this.isTouching = false;
        this.trigger(&#39;touchend&#39;, ev);
        if (!skipMouseIgnore) {
            this.startTouchMouseIgnore();
        }
    }
};
GlobalEmitter.prototype.startTouchMouseIgnore = function () {
    var _this = this;
    var wait = exportHooks.touchMouseIgnoreWait;
    if (wait) {
        this.mouseIgnoreDepth++;
        setTimeout(function () {
            _this.mouseIgnoreDepth--;
        }, wait);
    }
};
GlobalEmitter.prototype.shouldIgnoreMouse = function () {
    return this.isTouching || Boolean(this.mouseIgnoreDepth);
};
return GlobalEmitter;</pre>

<p>}()); exports.default = GlobalEmitter;
ListenerMixin_1.default.mixInto(GlobalEmitter);
EmitterMixin_1.default.mixInto(GlobalEmitter);</p>

<p>/***/ }), /* 22 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
exportHooks = <em>webpack_require</em>(16); exports.viewHash = {};
exportHooks.views = exports.viewHash; function defineView(viewName,
viewConfig) {</p>

<pre class="ruby"><span class="ruby-identifier">exports</span>.<span class="ruby-identifier">viewHash</span>[<span class="ruby-identifier">viewName</span>] = <span class="ruby-identifier">viewConfig</span>;
</pre>

<p>} exports.defineView = defineView; function getViewConfig(viewName) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">exports</span>.<span class="ruby-identifier">viewHash</span>[<span class="ruby-identifier">viewName</span>];
</pre>

<p>} exports.getViewConfig = getViewConfig;</p>

<p>/***/ }), /* 23 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var util_1 = <em>webpack_require</em>(4);
var DragListener_1 = <em>webpack_require</em>(54); /* Tracks mouse
movements over a component and raises events about which hit the mouse is
over.</p>
<hr>

<p>options:</p>
<ul><li>
<p>subjectEl</p>
</li><li>
<p>subjectCenter</p>
</li></ul>

<pre>/</pre>

<p>var HitDragListener = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(HitDragListener, _super);
function HitDragListener(component, options) {
    var _this = _super.call(this, options) || this;
    _this.component = component;
    return _this;
}
// Called when drag listening starts (but a real drag has not necessarily began).
// ev might be undefined if dragging was started manually.
HitDragListener.prototype.handleInteractionStart = function (ev) {
    var subjectEl = this.subjectEl;
    var subjectRect;
    var origPoint;
    var point;
    this.component.hitsNeeded();
    this.computeScrollBounds(); // for autoscroll
    if (ev) {
        origPoint = { left: util_1.getEvX(ev), top: util_1.getEvY(ev) };
        point = origPoint;
        // constrain the point to bounds of the element being dragged
        if (subjectEl) {
            subjectRect = util_1.getOuterRect(subjectEl); // used for centering as well
            point = util_1.constrainPoint(point, subjectRect);
        }
        this.origHit = this.queryHit(point.left, point.top);
        // treat the center of the subject as the collision point?
        if (subjectEl &amp;&amp; this.options.subjectCenter) {
            // only consider the area the subject overlaps the hit. best for large subjects.
            // TODO: skip this if hit didn&#39;t supply left/right/top/bottom
            if (this.origHit) {
                subjectRect = util_1.intersectRects(this.origHit, subjectRect) ||
                    subjectRect; // in case there is no intersection
            }
            point = util_1.getRectCenter(subjectRect);
        }
        this.coordAdjust = util_1.diffPoints(point, origPoint); // point - origPoint
    }
    else {
        this.origHit = null;
        this.coordAdjust = null;
    }
    // call the super-method. do it after origHit has been computed
    _super.prototype.handleInteractionStart.call(this, ev);
};
// Called when the actual drag has started
HitDragListener.prototype.handleDragStart = function (ev) {
    var hit;
    _super.prototype.handleDragStart.call(this, ev);
    // might be different from this.origHit if the min-distance is large
    hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));
    // report the initial hit the mouse is over
    // especially important if no min-distance and drag starts immediately
    if (hit) {
        this.handleHitOver(hit);
    }
};
// Called when the drag moves
HitDragListener.prototype.handleDrag = function (dx, dy, ev) {
    var hit;
    _super.prototype.handleDrag.call(this, dx, dy, ev);
    hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));
    if (!isHitsEqual(hit, this.hit)) {
        if (this.hit) {
            this.handleHitOut();
        }
        if (hit) {
            this.handleHitOver(hit);
        }
    }
};
// Called when dragging has been stopped
HitDragListener.prototype.handleDragEnd = function (ev) {
    this.handleHitDone();
    _super.prototype.handleDragEnd.call(this, ev);
};
// Called when a the mouse has just moved over a new hit
HitDragListener.prototype.handleHitOver = function (hit) {
    var isOrig = isHitsEqual(hit, this.origHit);
    this.hit = hit;
    this.trigger(&#39;hitOver&#39;, this.hit, isOrig, this.origHit);
};
// Called when the mouse has just moved out of a hit
HitDragListener.prototype.handleHitOut = function () {
    if (this.hit) {
        this.trigger(&#39;hitOut&#39;, this.hit);
        this.handleHitDone();
        this.hit = null;
    }
};
// Called after a hitOut. Also called before a dragStop
HitDragListener.prototype.handleHitDone = function () {
    if (this.hit) {
        this.trigger(&#39;hitDone&#39;, this.hit);
    }
};
// Called when the interaction ends, whether there was a real drag or not
HitDragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {
    _super.prototype.handleInteractionEnd.call(this, ev, isCancelled);
    this.origHit = null;
    this.hit = null;
    this.component.hitsNotNeeded();
};
// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
HitDragListener.prototype.handleScrollEnd = function () {
    _super.prototype.handleScrollEnd.call(this);
    // hits&#39; absolute positions will be in new places after a user&#39;s scroll.
    // HACK for recomputing.
    if (this.isDragging) {
        this.component.releaseHits();
        this.component.prepareHits();
    }
};
// Gets the hit underneath the coordinates for the given mouse event
HitDragListener.prototype.queryHit = function (left, top) {
    if (this.coordAdjust) {
        left += this.coordAdjust.left;
        top += this.coordAdjust.top;
    }
    return this.component.queryHit(left, top);
};
return HitDragListener;</pre>

<p>}(DragListener_1.default)); exports.default = HitDragListener; // Returns
`true` if the hits are identically equal. `false` otherwise. Must be from
the same component. // Two null values will be considered equal, as two
“out of the component” states are the same. function isHitsEqual(hit0,
hit1) {</p>

<pre>if (!hit0 &amp;&amp; !hit1) {
    return true;
}
if (hit0 &amp;&amp; hit1) {
    return hit0.component === hit1.component &amp;&amp;
        isHitPropsWithin(hit0, hit1) &amp;&amp;
        isHitPropsWithin(hit1, hit0); // ensures all props are identical
}
return false;</pre>

<p>} // Returns true if all of subHit&#39;s non-standard properties are within
superHit function isHitPropsWithin(subHit, superHit) {</p>

<pre>for (var propName in subHit) {
    if (!/^(component|left|right|top|bottom)$/.test(propName)) {
        if (subHit[propName] !== superHit[propName]) {
            return false;
        }
    }
}
return true;</pre>

<p>}</p>

<p>/***/ }), /* 24 */, /* 25 */, /* 26 */, /* 27 */, /* 28 */, /* 29 */, /* 30
*/, /* 31 */ /***/ (function(module, exports, <em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var moment = <em>webpack_require</em>(0); var
exportHooks = <em>webpack_require</em>(16); var options_1 =
<em>webpack_require</em>(32); var util_1 = <em>webpack_require</em>(4);
exports.localeOptionHash = {}; exportHooks.locales =
exports.localeOptionHash; // NOTE: can&#39;t guarantee any of these
computations will run because not every locale has datepicker // configs,
so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions = {</p>

<pre>buttonText: function (dpOptions) {
    return {
        // the translations sometimes wrongly contain HTML entities
        prev: util_1.stripHtmlEntities(dpOptions.prevText),
        next: util_1.stripHtmlEntities(dpOptions.nextText),
        today: util_1.stripHtmlEntities(dpOptions.currentText)
    };
},
// Produces format strings like &quot;MMMM YYYY&quot; -&gt; &quot;September 2014&quot;
monthYearFormat: function (dpOptions) {
    return dpOptions.showMonthAfterYear ?
        &#39;YYYY[&#39; + dpOptions.yearSuffix + &#39;] MMMM&#39; :
        &#39;MMMM YYYY[&#39; + dpOptions.yearSuffix + &#39;]&#39;;
}</pre>

<p>}; var momComputableOptions = {</p>

<pre>// Produces format strings like &quot;ddd M/D&quot; -&gt; &quot;Fri 9/15&quot;
dayOfMonthFormat: function (momOptions, fcOptions) {
    var format = momOptions.longDateFormat(&#39;l&#39;); // for the format like &quot;M/D/YYYY&quot;
    // strip the year off the edge, as well as other misc non-whitespace chars
    format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, &#39;&#39;);
    if (fcOptions.isRTL) {
        format += &#39; ddd&#39;; // for RTL, add day-of-week to end
    }
    else {
        format = &#39;ddd &#39; + format; // for LTR, add day-of-week to beginning
    }
    return format;
},
// Produces format strings like &quot;h:mma&quot; -&gt; &quot;6:00pm&quot;
mediumTimeFormat: function (momOptions) {
    return momOptions.longDateFormat(&#39;LT&#39;)
        .replace(/\s*a$/i, &#39;a&#39;); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
},
// Produces format strings like &quot;h(:mm)a&quot; -&gt; &quot;6pm&quot; / &quot;6:30pm&quot;
smallTimeFormat: function (momOptions) {
    return momOptions.longDateFormat(&#39;LT&#39;)
        .replace(&#39;:mm&#39;, &#39;(:mm)&#39;)
        .replace(/(\Wmm)$/, &#39;($1)&#39;) // like above, but for foreign locales
        .replace(/\s*a$/i, &#39;a&#39;); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
},
// Produces format strings like &quot;h(:mm)t&quot; -&gt; &quot;6p&quot; / &quot;6:30p&quot;
extraSmallTimeFormat: function (momOptions) {
    return momOptions.longDateFormat(&#39;LT&#39;)
        .replace(&#39;:mm&#39;, &#39;(:mm)&#39;)
        .replace(/(\Wmm)$/, &#39;($1)&#39;) // like above, but for foreign locales
        .replace(/\s*a$/i, &#39;t&#39;); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
},
// Produces format strings like &quot;ha&quot; / &quot;H&quot; -&gt; &quot;6pm&quot; / &quot;18&quot;
hourFormat: function (momOptions) {
    return momOptions.longDateFormat(&#39;LT&#39;)
        .replace(&#39;:mm&#39;, &#39;&#39;)
        .replace(/(\Wmm)$/, &#39;&#39;) // like above, but for foreign locales
        .replace(/\s*a$/i, &#39;a&#39;); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
},
// Produces format strings like &quot;h:mm&quot; -&gt; &quot;6:30&quot; (with no AM/PM)
noMeridiemTimeFormat: function (momOptions) {
    return momOptions.longDateFormat(&#39;LT&#39;)
        .replace(/\s*a$/i, &#39;&#39;); // remove trailing AM/PM
}</pre>

<p>}; // options that should be computed off live calendar options (considers
override options) // TODO: best place for this? related to locale? // TODO:
flipping text based on isRTL is a bad idea because the CSS `direction`
might want to handle it var instanceComputableOptions = {</p>

<pre>// Produces format strings for results like &quot;Mo 16&quot;
smallDayDateFormat: function (options) {
    return options.isRTL ?
        &#39;D dd&#39; :
        &#39;dd D&#39;;
},
// Produces format strings for results like &quot;Wk 5&quot;
weekFormat: function (options) {
    return options.isRTL ?
        &#39;w[ &#39; + options.weekNumberTitle + &#39;]&#39; :
        &#39;[&#39; + options.weekNumberTitle + &#39; ]w&#39;;
},
// Produces format strings for results like &quot;Wk5&quot;
smallWeekFormat: function (options) {
    return options.isRTL ?
        &#39;w[&#39; + options.weekNumberTitle + &#39;]&#39; :
        &#39;[&#39; + options.weekNumberTitle + &#39;]w&#39;;
}</pre>

<p>}; // TODO: make these computable properties in optionsManager function
populateInstanceComputableOptions(options) {</p>

<pre>$.each(instanceComputableOptions, function (name, func) {
    if (options[name] == null) {
        options[name] = func(options);
    }
});</pre>

<p>} exports.populateInstanceComputableOptions =
populateInstanceComputableOptions; // Initialize jQuery UI datepicker
translations while using some of the translations // Will set this as the
default locales for datepicker. function datepickerLocale(localeCode,
dpLocaleCode, dpOptions) {</p>

<pre>// get the FullCalendar internal option hash for this locale. create if necessary
var fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});
// transfer some simple options from datepicker to fc
fcOptions.isRTL = dpOptions.isRTL;
fcOptions.weekNumberTitle = dpOptions.weekHeader;
// compute some more complex options from datepicker
$.each(dpComputableOptions, function (name, func) {
    fcOptions[name] = func(dpOptions);
});
var jqDatePicker = $.datepicker;
// is jQuery UI Datepicker is on the page?
if (jqDatePicker) {
    // Register the locale data.
    // FullCalendar and MomentJS use locale codes like &quot;pt-br&quot; but Datepicker
    // does it like &quot;pt-BR&quot; or if it doesn&#39;t have the locale, maybe just &quot;pt&quot;.
    // Make an alias so the locale can be referenced either way.
    jqDatePicker.regional[dpLocaleCode] =
        jqDatePicker.regional[localeCode] = // alias
            dpOptions;
    // Alias &#39;en&#39; to the default locale data. Do this every time.
    jqDatePicker.regional.en = jqDatePicker.regional[&#39;&#39;];
    // Set as Datepicker&#39;s global defaults.
    jqDatePicker.setDefaults(dpOptions);
}</pre>

<p>} exports.datepickerLocale = datepickerLocale; // Sets
FullCalendar-specific translations. Will set the locales as the global
default. function locale(localeCode, newFcOptions) {</p>

<pre>var fcOptions;
var momOptions;
// get the FullCalendar internal option hash for this locale. create if necessary
fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});
// provided new options for this locales? merge them in
if (newFcOptions) {
    fcOptions = exports.localeOptionHash[localeCode] = options_1.mergeOptions([fcOptions, newFcOptions]);
}
// compute locale options that weren&#39;t defined.
// always do this. newFcOptions can be undefined when initializing from i18n file,
// so no way to tell if this is an initialization or a default-setting.
momOptions = getMomentLocaleData(localeCode); // will fall back to en
$.each(momComputableOptions, function (name, func) {
    if (fcOptions[name] == null) {
        fcOptions[name] = (func)(momOptions, fcOptions);
    }
});
// set it as the default locale for FullCalendar
options_1.globalDefaults.locale = localeCode;</pre>

<p>} exports.locale = locale; // Returns moment&#39;s internal locale data. If
doesn&#39;t exist, returns English. function
getMomentLocaleData(localeCode) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">moment</span>.<span class="ruby-identifier">localeData</span>(<span class="ruby-identifier">localeCode</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">moment</span>.<span class="ruby-identifier">localeData</span>(<span class="ruby-string">&#39;en&#39;</span>);
</pre>

<p>} exports.getMomentLocaleData = getMomentLocaleData; // Initialize English
by forcing computation of moment-derived options. // Also, sets it as the
default. locale(&#39;en&#39;, options_1.englishDefaults);</p>

<p>/***/ }), /* 32 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var util_1 =
<em>webpack_require</em>(4); exports.globalDefaults = {</p>

<pre>titleRangeSeparator: &#39; \u2013 &#39;,
monthYearFormat: &#39;MMMM YYYY&#39;,
defaultTimedEventDuration: &#39;02:00:00&#39;,
defaultAllDayEventDuration: { days: 1 },
forceEventDuration: false,
nextDayThreshold: &#39;09:00:00&#39;,
// display
columnHeader: true,
defaultView: &#39;month&#39;,
aspectRatio: 1.35,
header: {
    left: &#39;title&#39;,
    center: &#39;&#39;,
    right: &#39;today prev,next&#39;
},
weekends: true,
weekNumbers: false,
weekNumberTitle: &#39;W&#39;,
weekNumberCalculation: &#39;local&#39;,
// editable: false,
// nowIndicator: false,
scrollTime: &#39;06:00:00&#39;,
minTime: &#39;00:00:00&#39;,
maxTime: &#39;24:00:00&#39;,
showNonCurrentDates: true,
// event ajax
lazyFetching: true,
startParam: &#39;start&#39;,
endParam: &#39;end&#39;,
timezoneParam: &#39;timezone&#39;,
timezone: false,
// allDayDefault: undefined,
// locale
locale: null,
isRTL: false,
buttonText: {
    prev: &#39;prev&#39;,
    next: &#39;next&#39;,
    prevYear: &#39;prev year&#39;,
    nextYear: &#39;next year&#39;,
    year: &#39;year&#39;,
    today: &#39;today&#39;,
    month: &#39;month&#39;,
    week: &#39;week&#39;,
    day: &#39;day&#39;
},
// buttonIcons: null,
allDayText: &#39;all-day&#39;,
// allows setting a min-height to the event segment to prevent short events overlapping each other
agendaEventMinHeight: 0,
// jquery-ui theming
theme: false,
// themeButtonIcons: null,
// eventResizableFromStart: false,
dragOpacity: .75,
dragRevertDuration: 500,
dragScroll: true,
// selectable: false,
unselectAuto: true,
// selectMinDistance: 0,
dropAccept: &#39;*&#39;,
eventOrder: &#39;title&#39;,
// eventRenderWait: null,
eventLimit: false,
eventLimitText: &#39;more&#39;,
eventLimitClick: &#39;popover&#39;,
dayPopoverFormat: &#39;LL&#39;,
handleWindowResize: true,
windowResizeDelay: 100,
longPressDelay: 1000</pre>

<p>}; exports.englishDefaults = {</p>

<pre>dayPopoverFormat: &#39;dddd, MMMM D&#39;</pre>

<p>}; exports.rtlDefaults = {</p>

<pre>header: {
    left: &#39;next,prev today&#39;,
    center: &#39;&#39;,
    right: &#39;title&#39;
},
buttonIcons: {
    prev: &#39;right-single-arrow&#39;,
    next: &#39;left-single-arrow&#39;,
    prevYear: &#39;right-double-arrow&#39;,
    nextYear: &#39;left-double-arrow&#39;
},
themeButtonIcons: {
    prev: &#39;circle-triangle-e&#39;,
    next: &#39;circle-triangle-w&#39;,
    nextYear: &#39;seek-prev&#39;,
    prevYear: &#39;seek-next&#39;
}</pre>

<p>}; var complexOptions = [</p>

<pre>&#39;header&#39;,
&#39;footer&#39;,
&#39;buttonText&#39;,
&#39;buttonIcons&#39;,
&#39;themeButtonIcons&#39;</pre>

<p>]; // Merges an array of option objects into a single object function
mergeOptions(optionObjs) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">util_1</span>.<span class="ruby-identifier">mergeProps</span>(<span class="ruby-identifier">optionObjs</span>, <span class="ruby-identifier">complexOptions</span>);
</pre>

<p>} exports.mergeOptions = mergeOptions;</p>

<p>/***/ }), /* 33 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var util_1 = <em>webpack_require</em>(4); //
Class that all other classes will inherit from var Class = /** @class */
(function () {</p>

<pre>function Class() {
}
// Called on a class to create a subclass.
// LIMITATION: cannot provide a constructor!
Class.extend = function (members) {
    var SubClass = /** @class */ (function (_super) {
        tslib_1.__extends(SubClass, _super);
        function SubClass() {
            return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
        }
        return SubClass;
    }(this));
    util_1.copyOwnProps(members, SubClass.prototype);
    return SubClass;
};
// Adds new member variables/methods to the class&#39;s prototype.
// Can be called with another class, or a plain object hash containing new members.
Class.mixin = function (members) {
    util_1.copyOwnProps(members, this.prototype);
};
return Class;</pre>

<p>}()); exports.default = Class;</p>

<p>/***/ }), /* 34 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var ParsableModelMixin_1 =
<em>webpack_require</em>(208); var EventDef = /** @class */ (function () {</p>

<pre>function EventDef(source) {
    this.source = source;
    this.className = [];
    this.miscProps = {};
}
EventDef.parse = function (rawInput, source) {
    var def = new this(source);
    if (def.applyProps(rawInput)) {
        return def;
    }
    return false;
};
EventDef.normalizeId = function (id) {
    return String(id);
};
EventDef.generateId = function () {
    return &#39;_fc&#39; + (EventDef.uuid++);
};
EventDef.prototype.clone = function () {
    var copy = new this.constructor(this.source);
    copy.id = this.id;
    copy.rawId = this.rawId;
    copy.uid = this.uid; // not really unique anymore :(
    EventDef.copyVerbatimStandardProps(this, copy);
    copy.className = this.className.slice(); // copy
    copy.miscProps = $.extend({}, this.miscProps);
    return copy;
};
EventDef.prototype.hasInverseRendering = function () {
    return this.getRendering() === &#39;inverse-background&#39;;
};
EventDef.prototype.hasBgRendering = function () {
    var rendering = this.getRendering();
    return rendering === &#39;inverse-background&#39; || rendering === &#39;background&#39;;
};
EventDef.prototype.getRendering = function () {
    if (this.rendering != null) {
        return this.rendering;
    }
    return this.source.rendering;
};
EventDef.prototype.getConstraint = function () {
    if (this.constraint != null) {
        return this.constraint;
    }
    if (this.source.constraint != null) {
        return this.source.constraint;
    }
    return this.source.calendar.opt(&#39;eventConstraint&#39;); // what about View option?
};
EventDef.prototype.getOverlap = function () {
    if (this.overlap != null) {
        return this.overlap;
    }
    if (this.source.overlap != null) {
        return this.source.overlap;
    }
    return this.source.calendar.opt(&#39;eventOverlap&#39;); // what about View option?
};
EventDef.prototype.isStartExplicitlyEditable = function () {
    if (this.startEditable != null) {
        return this.startEditable;
    }
    return this.source.startEditable;
};
EventDef.prototype.isDurationExplicitlyEditable = function () {
    if (this.durationEditable != null) {
        return this.durationEditable;
    }
    return this.source.durationEditable;
};
EventDef.prototype.isExplicitlyEditable = function () {
    if (this.editable != null) {
        return this.editable;
    }
    return this.source.editable;
};
EventDef.prototype.toLegacy = function () {
    var obj = $.extend({}, this.miscProps);
    obj._id = this.uid;
    obj.source = this.source;
    obj.className = this.className.slice(); // copy
    obj.allDay = this.isAllDay();
    if (this.rawId != null) {
        obj.id = this.rawId;
    }
    EventDef.copyVerbatimStandardProps(this, obj);
    return obj;
};
EventDef.prototype.applyManualStandardProps = function (rawProps) {
    if (rawProps.id != null) {
        this.id = EventDef.normalizeId((this.rawId = rawProps.id));
    }
    else {
        this.id = EventDef.generateId();
    }
    if (rawProps._id != null) {
        this.uid = String(rawProps._id);
    }
    else {
        this.uid = EventDef.generateId();
    }
    // TODO: converge with EventSource
    if ($.isArray(rawProps.className)) {
        this.className = rawProps.className;
    }
    if (typeof rawProps.className === &#39;string&#39;) {
        this.className = rawProps.className.split(/\s+/);
    }
    return true;
};
EventDef.prototype.applyMiscProps = function (rawProps) {
    $.extend(this.miscProps, rawProps);
};
EventDef.uuid = 0;
EventDef.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;
EventDef.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;
return EventDef;</pre>

<p>}()); exports.default = EventDef;
ParsableModelMixin_1.default.mixInto(EventDef);
EventDef.defineStandardProps({</p>

<pre>// not automatically assigned (`false`)
_id: false,
id: false,
className: false,
source: false,
// automatically assigned (`true`)
title: true,
url: true,
rendering: true,
constraint: true,
overlap: true,
editable: true,
startEditable: true,
durationEditable: true,
color: true,
backgroundColor: true,
borderColor: true,
textColor: true</pre>

<p>});</p>

<p>/***/ }), /* 35 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
EventRange_1 = <em>webpack_require</em>(211); var EventFootprint_1 =
<em>webpack_require</em>(36); var ComponentFootprint_1 =
<em>webpack_require</em>(12); function eventDefsToEventInstances(eventDefs,
unzonedRange) {</p>

<pre>var eventInstances = [];
var i;
for (i = 0; i &lt; eventDefs.length; i++) {
    eventInstances.push.apply(eventInstances, // append
    eventDefs[i].buildInstances(unzonedRange));
}
return eventInstances;</pre>

<p>} exports.eventDefsToEventInstances = eventDefsToEventInstances; function
eventInstanceToEventRange(eventInstance) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">EventRange_1</span>.<span class="ruby-identifier">default</span>(<span class="ruby-identifier">eventInstance</span>.<span class="ruby-identifier">dateProfile</span>.<span class="ruby-identifier">unzonedRange</span>, <span class="ruby-identifier">eventInstance</span>.<span class="ruby-identifier">def</span>, <span class="ruby-identifier">eventInstance</span>);
</pre>

<p>} exports.eventInstanceToEventRange = eventInstanceToEventRange; function
eventRangeToEventFootprint(eventRange) {</p>

<pre>return new EventFootprint_1.default(new ComponentFootprint_1.default(eventRange.unzonedRange, eventRange.eventDef.isAllDay()), eventRange.eventDef, eventRange.eventInstance // might not exist
);</pre>

<p>} exports.eventRangeToEventFootprint = eventRangeToEventFootprint; function
eventInstanceToUnzonedRange(eventInstance) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">eventInstance</span>.<span class="ruby-identifier">dateProfile</span>.<span class="ruby-identifier">unzonedRange</span>;
</pre>

<p>} exports.eventInstanceToUnzonedRange = eventInstanceToUnzonedRange;
function eventFootprintToComponentFootprint(eventFootprint) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">eventFootprint</span>.<span class="ruby-identifier">componentFootprint</span>;
</pre>

<p>} exports.eventFootprintToComponentFootprint =
eventFootprintToComponentFootprint;</p>

<p>/***/ }), /* 36 */ /***/ (function(module, exports) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
EventFootprint = /** @class */ (function () {</p>

<pre>function EventFootprint(componentFootprint, eventDef, eventInstance) {
    this.componentFootprint = componentFootprint;
    this.eventDef = eventDef;
    if (eventInstance) {
        this.eventInstance = eventInstance;
    }
}
EventFootprint.prototype.getEventLegacy = function () {
    return (this.eventInstance || this.eventDef).toLegacy();
};
return EventFootprint;</pre>

<p>}()); exports.default = EventFootprint;</p>

<p>/***/ }), /* 37 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var util_1 =
<em>webpack_require</em>(4); var EventDateProfile_1 =
<em>webpack_require</em>(17); var EventDef_1 =
<em>webpack_require</em>(34); var EventDefDateMutation_1 =
<em>webpack_require</em>(50); var SingleEventDef_1 =
<em>webpack_require</em>(13); var EventDefMutation = /** @class */
(function () {</p>

<pre>function EventDefMutation() {
}
EventDefMutation.createFromRawProps = function (eventInstance, rawProps, largeUnit) {
    var eventDef = eventInstance.def;
    var dateProps = {};
    var standardProps = {};
    var miscProps = {};
    var verbatimStandardProps = {};
    var eventDefId = null;
    var className = null;
    var propName;
    var dateProfile;
    var dateMutation;
    var defMutation;
    for (propName in rawProps) {
        if (EventDateProfile_1.default.isStandardProp(propName)) {
            dateProps[propName] = rawProps[propName];
        }
        else if (eventDef.isStandardProp(propName)) {
            standardProps[propName] = rawProps[propName];
        }
        else if (eventDef.miscProps[propName] !== rawProps[propName]) {
            miscProps[propName] = rawProps[propName];
        }
    }
    dateProfile = EventDateProfile_1.default.parse(dateProps, eventDef.source);
    if (dateProfile) {
        dateMutation = EventDefDateMutation_1.default.createFromDiff(eventInstance.dateProfile, dateProfile, largeUnit);
    }
    if (standardProps.id !== eventDef.id) {
        eventDefId = standardProps.id; // only apply if there&#39;s a change
    }
    if (!util_1.isArraysEqual(standardProps.className, eventDef.className)) {
        className = standardProps.className; // only apply if there&#39;s a change
    }
    EventDef_1.default.copyVerbatimStandardProps(standardProps, // src
    verbatimStandardProps // dest
    );
    defMutation = new EventDefMutation();
    defMutation.eventDefId = eventDefId;
    defMutation.className = className;
    defMutation.verbatimStandardProps = verbatimStandardProps;
    defMutation.miscProps = miscProps;
    if (dateMutation) {
        defMutation.dateMutation = dateMutation;
    }
    return defMutation;
};
/*
eventDef assumed to be a SingleEventDef.
returns an undo function.
 /
EventDefMutation.prototype.mutateSingle = function (eventDef) {
    var origDateProfile;
    if (this.dateMutation) {
        origDateProfile = eventDef.dateProfile;
        eventDef.dateProfile = this.dateMutation.buildNewDateProfile(origDateProfile, eventDef.source.calendar);
    }
    // can&#39;t undo
    // TODO: more DRY with EventDef::applyManualStandardProps
    if (this.eventDefId != null) {
        eventDef.id = EventDef_1.default.normalizeId((eventDef.rawId = this.eventDefId));
    }
    // can&#39;t undo
    // TODO: more DRY with EventDef::applyManualStandardProps
    if (this.className) {
        eventDef.className = this.className;
    }
    // can&#39;t undo
    if (this.verbatimStandardProps) {
        SingleEventDef_1.default.copyVerbatimStandardProps(this.verbatimStandardProps, // src
        eventDef // dest
        );
    }
    // can&#39;t undo
    if (this.miscProps) {
        eventDef.applyMiscProps(this.miscProps);
    }
    if (origDateProfile) {
        return function () {
            eventDef.dateProfile = origDateProfile;
        };
    }
    else {
        return function () { };
    }
};
EventDefMutation.prototype.setDateMutation = function (dateMutation) {
    if (dateMutation &amp;&amp; !dateMutation.isEmpty()) {
        this.dateMutation = dateMutation;
    }
    else {
        this.dateMutation = null;
    }
};
EventDefMutation.prototype.isEmpty = function () {
    return !this.dateMutation;
};
return EventDefMutation;</pre>

<p>}()); exports.default = EventDefMutation;</p>

<p>/***/ }), /* 38 */ /***/ (function(module, exports) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true });
exports.default = {</p>

<pre>sourceClasses: [],
registerClass: function (EventSourceClass) {
    this.sourceClasses.unshift(EventSourceClass); // give highest priority
},
parse: function (rawInput, calendar) {
    var sourceClasses = this.sourceClasses;
    var i;
    var eventSource;
    for (i = 0; i &lt; sourceClasses.length; i++) {
        eventSource = sourceClasses[i].parse(rawInput, calendar);
        if (eventSource) {
            return eventSource;
        }
    }
}</pre>

<p>};</p>

<p>/***/ }), /* 39 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var Class_1 =
<em>webpack_require</em>(33); /* Embodies a div that has potential
scrollbars</p>

<pre>/</pre>

<p>var Scroller = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(Scroller, _super);
function Scroller(options) {
    var _this = _super.call(this) || this;
    options = options || {};
    _this.overflowX = options.overflowX || options.overflow || &#39;auto&#39;;
    _this.overflowY = options.overflowY || options.overflow || &#39;auto&#39;;
    return _this;
}
Scroller.prototype.render = function () {
    this.el = this.renderEl();
    this.applyOverflow();
};
Scroller.prototype.renderEl = function () {
    return (this.scrollEl = $(&#39;&lt;div class=&quot;fc-scroller&quot;&gt;&lt;/div&gt;&#39;));
};
// sets to natural height, unlocks overflow
Scroller.prototype.clear = function () {
    this.setHeight(&#39;auto&#39;);
    this.applyOverflow();
};
Scroller.prototype.destroy = function () {
    this.el.remove();
};
// Overflow
// -----------------------------------------------------------------------------------------------------------------
Scroller.prototype.applyOverflow = function () {
    this.scrollEl.css({
        &#39;overflow-x&#39;: this.overflowX,
        &#39;overflow-y&#39;: this.overflowY
    });
};
// Causes any &#39;auto&#39; overflow values to resolves to &#39;scroll&#39; or &#39;hidden&#39;.
// Useful for preserving scrollbar widths regardless of future resizes.
// Can pass in scrollbarWidths for optimization.
Scroller.prototype.lockOverflow = function (scrollbarWidths) {
    var overflowX = this.overflowX;
    var overflowY = this.overflowY;
    scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();
    if (overflowX === &#39;auto&#39;) {
        overflowX = (scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?
            // OR scrolling pane with massless scrollbars?
            this.scrollEl[0].scrollWidth - 1 &gt; this.scrollEl[0].clientWidth) ? &#39;scroll&#39; : &#39;hidden&#39;;
    }
    if (overflowY === &#39;auto&#39;) {
        overflowY = (scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?
            // OR scrolling pane with massless scrollbars?
            this.scrollEl[0].scrollHeight - 1 &gt; this.scrollEl[0].clientHeight) ? &#39;scroll&#39; : &#39;hidden&#39;;
    }
    this.scrollEl.css({ &#39;overflow-x&#39;: overflowX, &#39;overflow-y&#39;: overflowY });
};
// Getters / Setters
// -----------------------------------------------------------------------------------------------------------------
Scroller.prototype.setHeight = function (height) {
    this.scrollEl.height(height);
};
Scroller.prototype.getScrollTop = function () {
    return this.scrollEl.scrollTop();
};
Scroller.prototype.setScrollTop = function (top) {
    this.scrollEl.scrollTop(top);
};
Scroller.prototype.getClientWidth = function () {
    return this.scrollEl[0].clientWidth;
};
Scroller.prototype.getClientHeight = function () {
    return this.scrollEl[0].clientHeight;
};
Scroller.prototype.getScrollbarWidths = function () {
    return util_1.getScrollbarWidths(this.scrollEl);
};
return Scroller;</pre>

<p>}(Class_1.default)); exports.default = Scroller;</p>

<p>/***/ }), /* 40 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var DateComponent_1 =
<em>webpack_require</em>(219); var GlobalEmitter_1 =
<em>webpack_require</em>(21); var InteractiveDateComponent = /** @class */
(function (_super) {</p>

<pre>tslib_1.__extends(InteractiveDateComponent, _super);
function InteractiveDateComponent(_view, _options) {
    var _this = _super.call(this, _view, _options) || this;
    // self-config, overridable by subclasses
    _this.segSelector = &#39;.fc-event-container &gt; *&#39;; // what constitutes an event element?
    if (_this.dateSelectingClass) {
        _this.dateClicking = new _this.dateClickingClass(_this);
    }
    if (_this.dateSelectingClass) {
        _this.dateSelecting = new _this.dateSelectingClass(_this);
    }
    if (_this.eventPointingClass) {
        _this.eventPointing = new _this.eventPointingClass(_this);
    }
    if (_this.eventDraggingClass &amp;&amp; _this.eventPointing) {
        _this.eventDragging = new _this.eventDraggingClass(_this, _this.eventPointing);
    }
    if (_this.eventResizingClass &amp;&amp; _this.eventPointing) {
        _this.eventResizing = new _this.eventResizingClass(_this, _this.eventPointing);
    }
    if (_this.externalDroppingClass) {
        _this.externalDropping = new _this.externalDroppingClass(_this);
    }
    return _this;
}
// Sets the container element that the view should render inside of, does global DOM-related initializations,
// and renders all the non-date-related content inside.
InteractiveDateComponent.prototype.setElement = function (el) {
    _super.prototype.setElement.call(this, el);
    if (this.dateClicking) {
        this.dateClicking.bindToEl(el);
    }
    if (this.dateSelecting) {
        this.dateSelecting.bindToEl(el);
    }
    this.bindAllSegHandlersToEl(el);
};
InteractiveDateComponent.prototype.removeElement = function () {
    this.endInteractions();
    _super.prototype.removeElement.call(this);
};
InteractiveDateComponent.prototype.executeEventUnrender = function () {
    this.endInteractions();
    _super.prototype.executeEventUnrender.call(this);
};
InteractiveDateComponent.prototype.bindGlobalHandlers = function () {
    _super.prototype.bindGlobalHandlers.call(this);
    if (this.externalDropping) {
        this.externalDropping.bindToDocument();
    }
};
InteractiveDateComponent.prototype.unbindGlobalHandlers = function () {
    _super.prototype.unbindGlobalHandlers.call(this);
    if (this.externalDropping) {
        this.externalDropping.unbindFromDocument();
    }
};
InteractiveDateComponent.prototype.bindDateHandlerToEl = function (el, name, handler) {
    var _this = this;
    // attach a handler to the grid&#39;s root element.
    // jQuery will take care of unregistering them when removeElement gets called.
    this.el.on(name, function (ev) {
        if (!$(ev.target).is(_this.segSelector + &#39;:not(.fc-helper),&#39; + // directly on an event element
            _this.segSelector + &#39;:not(.fc-helper) *,&#39; + // within an event element
            &#39;.fc-more,&#39; + // a &quot;more..&quot; link
            &#39;a[data-goto]&#39; // a clickable nav link
        )) {
            return handler.call(_this, ev);
        }
    });
};
InteractiveDateComponent.prototype.bindAllSegHandlersToEl = function (el) {
    [
        this.eventPointing,
        this.eventDragging,
        this.eventResizing
    ].forEach(function (eventInteraction) {
        if (eventInteraction) {
            eventInteraction.bindToEl(el);
        }
    });
};
InteractiveDateComponent.prototype.bindSegHandlerToEl = function (el, name, handler) {
    var _this = this;
    el.on(name, this.segSelector, function (ev) {
        var segEl = $(ev.currentTarget);
        if (!segEl.is(&#39;.fc-helper&#39;)) {
            var seg = segEl.data(&#39;fc-seg&#39;); // grab segment data. put there by View::renderEventsPayload
            if (seg &amp;&amp; !_this.shouldIgnoreEventPointing()) {
                return handler.call(_this, seg, ev); // context will be the Grid
            }
        }
    });
};
InteractiveDateComponent.prototype.shouldIgnoreMouse = function () {
    // HACK
    // This will still work even though bindDateHandlerToEl doesn&#39;t use GlobalEmitter.
    return GlobalEmitter_1.default.get().shouldIgnoreMouse();
};
InteractiveDateComponent.prototype.shouldIgnoreTouch = function () {
    var view = this._getView();
    // On iOS (and Android?) when a new selection is initiated overtop another selection,
    // the touchend never fires because the elements gets removed mid-touch-interaction (my theory).
    // HACK: simply don&#39;t allow this to happen.
    // ALSO: prevent selection when an *event* is already raised.
    return view.isSelected || view.selectedEvent;
};
InteractiveDateComponent.prototype.shouldIgnoreEventPointing = function () {
    // only call the handlers if there is not a drag/resize in progress
    return (this.eventDragging &amp;&amp; this.eventDragging.isDragging) ||
        (this.eventResizing &amp;&amp; this.eventResizing.isResizing);
};
InteractiveDateComponent.prototype.canStartSelection = function (seg, ev) {
    return util_1.getEvIsTouch(ev) &amp;&amp;
        !this.canStartResize(seg, ev) &amp;&amp;
        (this.isEventDefDraggable(seg.footprint.eventDef) ||
            this.isEventDefResizable(seg.footprint.eventDef));
};
InteractiveDateComponent.prototype.canStartDrag = function (seg, ev) {
    return !this.canStartResize(seg, ev) &amp;&amp;
        this.isEventDefDraggable(seg.footprint.eventDef);
};
InteractiveDateComponent.prototype.canStartResize = function (seg, ev) {
    var view = this._getView();
    var eventDef = seg.footprint.eventDef;
    return (!util_1.getEvIsTouch(ev) || view.isEventDefSelected(eventDef)) &amp;&amp;
        this.isEventDefResizable(eventDef) &amp;&amp;
        $(ev.target).is(&#39;.fc-resizer&#39;);
};
// Kills all in-progress dragging.
// Useful for when public API methods that result in re-rendering are invoked during a drag.
// Also useful for when touch devices misbehave and don&#39;t fire their touchend.
InteractiveDateComponent.prototype.endInteractions = function () {
    [
        this.dateClicking,
        this.dateSelecting,
        this.eventPointing,
        this.eventDragging,
        this.eventResizing
    ].forEach(function (interaction) {
        if (interaction) {
            interaction.end();
        }
    });
};
// Event Drag-n-Drop
// ---------------------------------------------------------------------------------------------------------------
// Computes if the given event is allowed to be dragged by the user
InteractiveDateComponent.prototype.isEventDefDraggable = function (eventDef) {
    return this.isEventDefStartEditable(eventDef);
};
InteractiveDateComponent.prototype.isEventDefStartEditable = function (eventDef) {
    var isEditable = eventDef.isStartExplicitlyEditable();
    if (isEditable == null) {
        isEditable = this.opt(&#39;eventStartEditable&#39;);
        if (isEditable == null) {
            isEditable = this.isEventDefGenerallyEditable(eventDef);
        }
    }
    return isEditable;
};
InteractiveDateComponent.prototype.isEventDefGenerallyEditable = function (eventDef) {
    var isEditable = eventDef.isExplicitlyEditable();
    if (isEditable == null) {
        isEditable = this.opt(&#39;editable&#39;);
    }
    return isEditable;
};
// Event Resizing
// ---------------------------------------------------------------------------------------------------------------
// Computes if the given event is allowed to be resized from its starting edge
InteractiveDateComponent.prototype.isEventDefResizableFromStart = function (eventDef) {
    return this.opt(&#39;eventResizableFromStart&#39;) &amp;&amp; this.isEventDefResizable(eventDef);
};
// Computes if the given event is allowed to be resized from its ending edge
InteractiveDateComponent.prototype.isEventDefResizableFromEnd = function (eventDef) {
    return this.isEventDefResizable(eventDef);
};
// Computes if the given event is allowed to be resized by the user at all
InteractiveDateComponent.prototype.isEventDefResizable = function (eventDef) {
    var isResizable = eventDef.isDurationExplicitlyEditable();
    if (isResizable == null) {
        isResizable = this.opt(&#39;eventDurationEditable&#39;);
        if (isResizable == null) {
            isResizable = this.isEventDefGenerallyEditable(eventDef);
        }
    }
    return isResizable;
};
// Event Mutation / Constraints
// ---------------------------------------------------------------------------------------------------------------
// Diffs the two dates, returning a duration, based on granularity of the grid
// TODO: port isTimeScale into this system?
InteractiveDateComponent.prototype.diffDates = function (a, b) {
    if (this.largeUnit) {
        return util_1.diffByUnit(a, b, this.largeUnit);
    }
    else {
        return util_1.diffDayTime(a, b);
    }
};
// is it allowed, in relation to the view&#39;s validRange?
// NOTE: very similar to isExternalInstanceGroupAllowed
InteractiveDateComponent.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {
    var view = this._getView();
    var dateProfile = this.dateProfile;
    var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
    var i;
    for (i = 0; i &lt; eventFootprints.length; i++) {
        // TODO: just use getAllEventRanges directly
        if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {
            return false;
        }
    }
    return view.calendar.constraints.isEventInstanceGroupAllowed(eventInstanceGroup);
};
// NOTE: very similar to isEventInstanceGroupAllowed
// when it&#39;s a completely anonymous external drag, no event.
InteractiveDateComponent.prototype.isExternalInstanceGroupAllowed = function (eventInstanceGroup) {
    var view = this._getView();
    var dateProfile = this.dateProfile;
    var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
    var i;
    for (i = 0; i &lt; eventFootprints.length; i++) {
        if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {
            return false;
        }
    }
    for (i = 0; i &lt; eventFootprints.length; i++) {
        // treat it as a selection
        // TODO: pass in eventInstanceGroup instead
        //  because we don&#39;t want calendar&#39;s constraint system to depend on a component&#39;s
        //  determination of footprints.
        if (!view.calendar.constraints.isSelectionFootprintAllowed(eventFootprints[i].componentFootprint)) {
            return false;
        }
    }
    return true;
};
return InteractiveDateComponent;</pre>

<p>}(DateComponent_1.default)); exports.default = InteractiveDateComponent;</p>

<p>/***/ }), /* 41 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
moment = <em>webpack_require</em>(0); var util_1 =
<em>webpack_require</em>(4); var RenderQueue_1 =
<em>webpack_require</em>(218); var DateProfileGenerator_1 =
<em>webpack_require</em>(221); var InteractiveDateComponent_1 =
<em>webpack_require</em>(40); var GlobalEmitter_1 =
<em>webpack_require</em>(21); var UnzonedRange_1 =
<em>webpack_require</em>(5); /* An abstract class from which other views
inherit from ———————————————————————————————————————-*/ var View = /**
@class */ (function (_super) {</p>

<pre>tslib_1.__extends(View, _super);
function View(calendar, viewSpec) {
    var _this = _super.call(this, null, viewSpec.options) || this;
    _this.batchRenderDepth = 0;
    _this.isSelected = false; // boolean whether a range of time is user-selected or not
    _this.calendar = calendar;
    _this.viewSpec = viewSpec;
    // shortcuts
    _this.type = viewSpec.type;
    // .name is deprecated
    _this.name = _this.type;
    _this.initRenderQueue();
    _this.initHiddenDays();
    _this.dateProfileGenerator = new _this.dateProfileGeneratorClass(_this);
    _this.bindBaseRenderHandlers();
    _this.eventOrderSpecs = util_1.parseFieldSpecs(_this.opt(&#39;eventOrder&#39;));
    // legacy
    if (_this[&#39;initialize&#39;]) {
        _this[&#39;initialize&#39;]();
    }
    return _this;
}
View.prototype._getView = function () {
    return this;
};
// Retrieves an option with the given name
View.prototype.opt = function (name) {
    return this.options[name];
};
/* Render Queue
------------------------------------------------------------------------------------------------------------------*/
View.prototype.initRenderQueue = function () {
    this.renderQueue = new RenderQueue_1.default({
        event: this.opt(&#39;eventRenderWait&#39;)
    });
    this.renderQueue.on(&#39;start&#39;, this.onRenderQueueStart.bind(this));
    this.renderQueue.on(&#39;stop&#39;, this.onRenderQueueStop.bind(this));
    this.on(&#39;before:change&#39;, this.startBatchRender);
    this.on(&#39;change&#39;, this.stopBatchRender);
};
View.prototype.onRenderQueueStart = function () {
    this.calendar.freezeContentHeight();
    this.addScroll(this.queryScroll());
};
View.prototype.onRenderQueueStop = function () {
    if (this.calendar.updateViewSize()) {
        this.popScroll();
    }
    this.calendar.thawContentHeight();
};
View.prototype.startBatchRender = function () {
    if (!(this.batchRenderDepth++)) {
        this.renderQueue.pause();
    }
};
View.prototype.stopBatchRender = function () {
    if (!(--this.batchRenderDepth)) {
        this.renderQueue.resume();
    }
};
View.prototype.requestRender = function (func, namespace, actionType) {
    this.renderQueue.queue(func, namespace, actionType);
};
// given func will auto-bind to `this`
View.prototype.whenSizeUpdated = function (func) {
    if (this.renderQueue.isRunning) {
        this.renderQueue.one(&#39;stop&#39;, func.bind(this));
    }
    else {
        func.call(this);
    }
};
/* Title and Date Formatting
------------------------------------------------------------------------------------------------------------------*/
// Computes what the title at the top of the calendar should be for this view
View.prototype.computeTitle = function (dateProfile) {
    var unzonedRange;
    // for views that span a large unit of time, show the proper interval, ignoring stray days before and after
    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
        unzonedRange = dateProfile.currentUnzonedRange;
    }
    else {
        unzonedRange = dateProfile.activeUnzonedRange;
    }
    return this.formatRange({
        start: this.calendar.msToMoment(unzonedRange.startMs, dateProfile.isRangeAllDay),
        end: this.calendar.msToMoment(unzonedRange.endMs, dateProfile.isRangeAllDay)
    }, dateProfile.isRangeAllDay, this.opt(&#39;titleFormat&#39;) || this.computeTitleFormat(dateProfile), this.opt(&#39;titleRangeSeparator&#39;));
};
// Generates the format string that should be used to generate the title for the current date range.
// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
View.prototype.computeTitleFormat = function (dateProfile) {
    var currentRangeUnit = dateProfile.currentRangeUnit;
    if (currentRangeUnit === &#39;year&#39;) {
        return &#39;YYYY&#39;;
    }
    else if (currentRangeUnit === &#39;month&#39;) {
        return this.opt(&#39;monthYearFormat&#39;); // like &quot;September 2014&quot;
    }
    else if (dateProfile.currentUnzonedRange.as(&#39;days&#39;) &gt; 1) {
        return &#39;ll&#39;; // multi-day range. shorter, like &quot;Sep 9 - 10 2014&quot;
    }
    else {
        return &#39;LL&#39;; // one day. longer, like &quot;September 9 2014&quot;
    }
};
// Date Setting/Unsetting
// -----------------------------------------------------------------------------------------------------------------
View.prototype.setDate = function (date) {
    var currentDateProfile = this.get(&#39;dateProfile&#39;);
    var newDateProfile = this.dateProfileGenerator.build(date, undefined, true); // forceToValid=true
    if (!currentDateProfile ||
        !currentDateProfile.activeUnzonedRange.equals(newDateProfile.activeUnzonedRange)) {
        this.set(&#39;dateProfile&#39;, newDateProfile);
    }
};
View.prototype.unsetDate = function () {
    this.unset(&#39;dateProfile&#39;);
};
// Event Data
// -----------------------------------------------------------------------------------------------------------------
View.prototype.fetchInitialEvents = function (dateProfile) {
    var calendar = this.calendar;
    var forceAllDay = dateProfile.isRangeAllDay &amp;&amp; !this.usesMinMaxTime;
    return calendar.requestEvents(calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, forceAllDay), calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, forceAllDay));
};
View.prototype.bindEventChanges = function () {
    this.listenTo(this.calendar, &#39;eventsReset&#39;, this.resetEvents); // TODO: make this a real event
};
View.prototype.unbindEventChanges = function () {
    this.stopListeningTo(this.calendar, &#39;eventsReset&#39;);
};
View.prototype.setEvents = function (eventsPayload) {
    this.set(&#39;currentEvents&#39;, eventsPayload);
    this.set(&#39;hasEvents&#39;, true);
};
View.prototype.unsetEvents = function () {
    this.unset(&#39;currentEvents&#39;);
    this.unset(&#39;hasEvents&#39;);
};
View.prototype.resetEvents = function (eventsPayload) {
    this.startBatchRender();
    this.unsetEvents();
    this.setEvents(eventsPayload);
    this.stopBatchRender();
};
// Date High-level Rendering
// -----------------------------------------------------------------------------------------------------------------
View.prototype.requestDateRender = function (dateProfile) {
    var _this = this;
    this.requestRender(function () {
        _this.executeDateRender(dateProfile);
    }, &#39;date&#39;, &#39;init&#39;);
};
View.prototype.requestDateUnrender = function () {
    var _this = this;
    this.requestRender(function () {
        _this.executeDateUnrender();
    }, &#39;date&#39;, &#39;destroy&#39;);
};
// if dateProfile not specified, uses current
View.prototype.executeDateRender = function (dateProfile) {
    _super.prototype.executeDateRender.call(this, dateProfile);
    if (this[&#39;render&#39;]) {
        this[&#39;render&#39;](); // TODO: deprecate
    }
    this.trigger(&#39;datesRendered&#39;);
    this.addScroll({ isDateInit: true });
    this.startNowIndicator(); // shouldn&#39;t render yet because updateSize will be called soon
};
View.prototype.executeDateUnrender = function () {
    this.unselect();
    this.stopNowIndicator();
    this.trigger(&#39;before:datesUnrendered&#39;);
    if (this[&#39;destroy&#39;]) {
        this[&#39;destroy&#39;](); // TODO: deprecate
    }
    _super.prototype.executeDateUnrender.call(this);
};
// &quot;Base&quot; rendering
// -----------------------------------------------------------------------------------------------------------------
View.prototype.bindBaseRenderHandlers = function () {
    var _this = this;
    this.on(&#39;datesRendered&#39;, function () {
        _this.whenSizeUpdated(_this.triggerViewRender);
    });
    this.on(&#39;before:datesUnrendered&#39;, function () {
        _this.triggerViewDestroy();
    });
};
View.prototype.triggerViewRender = function () {
    this.publiclyTrigger(&#39;viewRender&#39;, {
        context: this,
        args: [this, this.el]
    });
};
View.prototype.triggerViewDestroy = function () {
    this.publiclyTrigger(&#39;viewDestroy&#39;, {
        context: this,
        args: [this, this.el]
    });
};
// Event High-level Rendering
// -----------------------------------------------------------------------------------------------------------------
View.prototype.requestEventsRender = function (eventsPayload) {
    var _this = this;
    this.requestRender(function () {
        _this.executeEventRender(eventsPayload);
        _this.whenSizeUpdated(_this.triggerAfterEventsRendered);
    }, &#39;event&#39;, &#39;init&#39;);
};
View.prototype.requestEventsUnrender = function () {
    var _this = this;
    this.requestRender(function () {
        _this.triggerBeforeEventsDestroyed();
        _this.executeEventUnrender();
    }, &#39;event&#39;, &#39;destroy&#39;);
};
// Business Hour High-level Rendering
// -----------------------------------------------------------------------------------------------------------------
View.prototype.requestBusinessHoursRender = function (businessHourGenerator) {
    var _this = this;
    this.requestRender(function () {
        _this.renderBusinessHours(businessHourGenerator);
    }, &#39;businessHours&#39;, &#39;init&#39;);
};
View.prototype.requestBusinessHoursUnrender = function () {
    var _this = this;
    this.requestRender(function () {
        _this.unrenderBusinessHours();
    }, &#39;businessHours&#39;, &#39;destroy&#39;);
};
// Misc view rendering utils
// -----------------------------------------------------------------------------------------------------------------
// Binds DOM handlers to elements that reside outside the view container, such as the document
View.prototype.bindGlobalHandlers = function () {
    _super.prototype.bindGlobalHandlers.call(this);
    this.listenTo(GlobalEmitter_1.default.get(), {
        touchstart: this.processUnselect,
        mousedown: this.handleDocumentMousedown
    });
};
// Unbinds DOM handlers from elements that reside outside the view container
View.prototype.unbindGlobalHandlers = function () {
    _super.prototype.unbindGlobalHandlers.call(this);
    this.stopListeningTo(GlobalEmitter_1.default.get());
};
/* Now Indicator
------------------------------------------------------------------------------------------------------------------*/
// Immediately render the current time indicator and begins re-rendering it at an interval,
// which is defined by this.getNowIndicatorUnit().
// TODO: somehow do this for the current whole day&#39;s background too
View.prototype.startNowIndicator = function () {
    var _this = this;
    var unit;
    var update;
    var delay; // ms wait value
    if (this.opt(&#39;nowIndicator&#39;)) {
        unit = this.getNowIndicatorUnit();
        if (unit) {
            update = util_1.proxy(this, &#39;updateNowIndicator&#39;); // bind to `this`
            this.initialNowDate = this.calendar.getNow();
            this.initialNowQueriedMs = new Date().valueOf();
            // wait until the beginning of the next interval
            delay = this.initialNowDate.clone().startOf(unit).add(1, unit).valueOf() - this.initialNowDate.valueOf();
            this.nowIndicatorTimeoutID = setTimeout(function () {
                _this.nowIndicatorTimeoutID = null;
                update();
                delay = +moment.duration(1, unit);
                delay = Math.max(100, delay); // prevent too frequent
                _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
            }, delay);
        }
        // rendering will be initiated in updateSize
    }
};
// rerenders the now indicator, computing the new current time from the amount of time that has passed
// since the initial getNow call.
View.prototype.updateNowIndicator = function () {
    if (this.isDatesRendered &amp;&amp;
        this.initialNowDate // activated before?
    ) {
        this.unrenderNowIndicator(); // won&#39;t unrender if unnecessary
        this.renderNowIndicator(this.initialNowDate.clone().add(new Date().valueOf() - this.initialNowQueriedMs) // add ms
        );
        this.isNowIndicatorRendered = true;
    }
};
// Immediately unrenders the view&#39;s current time indicator and stops any re-rendering timers.
// Won&#39;t cause side effects if indicator isn&#39;t rendered.
View.prototype.stopNowIndicator = function () {
    if (this.isNowIndicatorRendered) {
        if (this.nowIndicatorTimeoutID) {
            clearTimeout(this.nowIndicatorTimeoutID);
            this.nowIndicatorTimeoutID = null;
        }
        if (this.nowIndicatorIntervalID) {
            clearInterval(this.nowIndicatorIntervalID);
            this.nowIndicatorIntervalID = null;
        }
        this.unrenderNowIndicator();
        this.isNowIndicatorRendered = false;
    }
};
/* Dimensions
------------------------------------------------------------------------------------------------------------------*/
View.prototype.updateSize = function (totalHeight, isAuto, isResize) {
    if (this[&#39;setHeight&#39;]) {
        this[&#39;setHeight&#39;](totalHeight, isAuto);
    }
    else {
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
    }
    this.updateNowIndicator();
};
/* Scroller
------------------------------------------------------------------------------------------------------------------*/
View.prototype.addScroll = function (scroll) {
    var queuedScroll = this.queuedScroll || (this.queuedScroll = {});
    $.extend(queuedScroll, scroll);
};
View.prototype.popScroll = function () {
    this.applyQueuedScroll();
    this.queuedScroll = null;
};
View.prototype.applyQueuedScroll = function () {
    if (this.queuedScroll) {
        this.applyScroll(this.queuedScroll);
    }
};
View.prototype.queryScroll = function () {
    var scroll = {};
    if (this.isDatesRendered) {
        $.extend(scroll, this.queryDateScroll());
    }
    return scroll;
};
View.prototype.applyScroll = function (scroll) {
    if (scroll.isDateInit &amp;&amp; this.isDatesRendered) {
        $.extend(scroll, this.computeInitialDateScroll());
    }
    if (this.isDatesRendered) {
        this.applyDateScroll(scroll);
    }
};
View.prototype.computeInitialDateScroll = function () {
    return {}; // subclasses must implement
};
View.prototype.queryDateScroll = function () {
    return {}; // subclasses must implement
};
View.prototype.applyDateScroll = function (scroll) {
    // subclasses must implement
};
/* Event Drag-n-Drop
------------------------------------------------------------------------------------------------------------------*/
View.prototype.reportEventDrop = function (eventInstance, eventMutation, el, ev) {
    var eventManager = this.calendar.eventManager;
    var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);
    var dateMutation = eventMutation.dateMutation;
    // update the EventInstance, for handlers
    if (dateMutation) {
        eventInstance.dateProfile = dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);
    }
    this.triggerEventDrop(eventInstance, 
    // a drop doesn&#39;t necessarily mean a date mutation (ex: resource change)
    (dateMutation &amp;&amp; dateMutation.dateDelta) || moment.duration(), undoFunc, el, ev);
};
// Triggers event-drop handlers that have subscribed via the API
View.prototype.triggerEventDrop = function (eventInstance, dateDelta, undoFunc, el, ev) {
    this.publiclyTrigger(&#39;eventDrop&#39;, {
        context: el[0],
        args: [
            eventInstance.toLegacy(),
            dateDelta,
            undoFunc,
            ev,
            {},
            this
        ]
    });
};
/* External Element Drag-n-Drop
------------------------------------------------------------------------------------------------------------------*/
// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
// `meta` is the parsed data that has been embedded into the dragging event.
// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
View.prototype.reportExternalDrop = function (singleEventDef, isEvent, isSticky, el, ev, ui) {
    if (isEvent) {
        this.calendar.eventManager.addEventDef(singleEventDef, isSticky);
    }
    this.triggerExternalDrop(singleEventDef, isEvent, el, ev, ui);
};
// Triggers external-drop handlers that have subscribed via the API
View.prototype.triggerExternalDrop = function (singleEventDef, isEvent, el, ev, ui) {
    // trigger &#39;drop&#39; regardless of whether element represents an event
    this.publiclyTrigger(&#39;drop&#39;, {
        context: el[0],
        args: [
            singleEventDef.dateProfile.start.clone(),
            ev,
            ui,
            this
        ]
    });
    if (isEvent) {
        // signal an external event landed
        this.publiclyTrigger(&#39;eventReceive&#39;, {
            context: this,
            args: [
                singleEventDef.buildInstance().toLegacy(),
                this
            ]
        });
    }
};
/* Event Resizing
------------------------------------------------------------------------------------------------------------------*/
// Must be called when an event in the view has been resized to a new length
View.prototype.reportEventResize = function (eventInstance, eventMutation, el, ev) {
    var eventManager = this.calendar.eventManager;
    var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);
    // update the EventInstance, for handlers
    eventInstance.dateProfile = eventMutation.dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);
    this.triggerEventResize(eventInstance, eventMutation.dateMutation.endDelta, undoFunc, el, ev);
};
// Triggers event-resize handlers that have subscribed via the API
View.prototype.triggerEventResize = function (eventInstance, durationDelta, undoFunc, el, ev) {
    this.publiclyTrigger(&#39;eventResize&#39;, {
        context: el[0],
        args: [
            eventInstance.toLegacy(),
            durationDelta,
            undoFunc,
            ev,
            {},
            this
        ]
    });
};
/* Selection (time range)
------------------------------------------------------------------------------------------------------------------*/
// Selects a date span on the view. `start` and `end` are both Moments.
// `ev` is the native mouse event that begin the interaction.
View.prototype.select = function (footprint, ev) {
    this.unselect(ev);
    this.renderSelectionFootprint(footprint);
    this.reportSelection(footprint, ev);
};
View.prototype.renderSelectionFootprint = function (footprint) {
    if (this[&#39;renderSelection&#39;]) {
        this[&#39;renderSelection&#39;](footprint.toLegacy(this.calendar));
    }
    else {
        _super.prototype.renderSelectionFootprint.call(this, footprint);
    }
};
// Called when a new selection is made. Updates internal state and triggers handlers.
View.prototype.reportSelection = function (footprint, ev) {
    this.isSelected = true;
    this.triggerSelect(footprint, ev);
};
// Triggers handlers to &#39;select&#39;
View.prototype.triggerSelect = function (footprint, ev) {
    var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of &quot;Event&quot;DateProfile?
    this.publiclyTrigger(&#39;select&#39;, {
        context: this,
        args: [
            dateProfile.start,
            dateProfile.end,
            ev,
            this
        ]
    });
};
// Undoes a selection. updates in the internal state and triggers handlers.
// `ev` is the native mouse event that began the interaction.
View.prototype.unselect = function (ev) {
    if (this.isSelected) {
        this.isSelected = false;
        if (this[&#39;destroySelection&#39;]) {
            this[&#39;destroySelection&#39;](); // TODO: deprecate
        }
        this.unrenderSelection();
        this.publiclyTrigger(&#39;unselect&#39;, {
            context: this,
            args: [ev, this]
        });
    }
};
/* Event Selection
------------------------------------------------------------------------------------------------------------------*/
View.prototype.selectEventInstance = function (eventInstance) {
    if (!this.selectedEventInstance ||
        this.selectedEventInstance !== eventInstance) {
        this.unselectEventInstance();
        this.getEventSegs().forEach(function (seg) {
            if (seg.footprint.eventInstance === eventInstance &amp;&amp;
                seg.el // necessary?
            ) {
                seg.el.addClass(&#39;fc-selected&#39;);
            }
        });
        this.selectedEventInstance = eventInstance;
    }
};
View.prototype.unselectEventInstance = function () {
    if (this.selectedEventInstance) {
        this.getEventSegs().forEach(function (seg) {
            if (seg.el) {
                seg.el.removeClass(&#39;fc-selected&#39;);
            }
        });
        this.selectedEventInstance = null;
    }
};
View.prototype.isEventDefSelected = function (eventDef) {
    // event references might change on refetchEvents(), while selectedEventInstance doesn&#39;t,
    // so compare IDs
    return this.selectedEventInstance &amp;&amp; this.selectedEventInstance.def.id === eventDef.id;
};
/* Mouse / Touch Unselecting (time range &amp; event unselection)
------------------------------------------------------------------------------------------------------------------*/
// TODO: move consistently to down/start or up/end?
// TODO: don&#39;t kill previous selection if touch scrolling
View.prototype.handleDocumentMousedown = function (ev) {
    if (util_1.isPrimaryMouseButton(ev)) {
        this.processUnselect(ev);
    }
};
View.prototype.processUnselect = function (ev) {
    this.processRangeUnselect(ev);
    this.processEventUnselect(ev);
};
View.prototype.processRangeUnselect = function (ev) {
    var ignore;
    // is there a time-range selection?
    if (this.isSelected &amp;&amp; this.opt(&#39;unselectAuto&#39;)) {
        // only unselect if the clicked element is not identical to or inside of an &#39;unselectCancel&#39; element
        ignore = this.opt(&#39;unselectCancel&#39;);
        if (!ignore || !$(ev.target).closest(ignore).length) {
            this.unselect(ev);
        }
    }
};
View.prototype.processEventUnselect = function (ev) {
    if (this.selectedEventInstance) {
        if (!$(ev.target).closest(&#39;.fc-selected&#39;).length) {
            this.unselectEventInstance();
        }
    }
};
/* Triggers
------------------------------------------------------------------------------------------------------------------*/
View.prototype.triggerBaseRendered = function () {
    this.publiclyTrigger(&#39;viewRender&#39;, {
        context: this,
        args: [this, this.el]
    });
};
View.prototype.triggerBaseUnrendered = function () {
    this.publiclyTrigger(&#39;viewDestroy&#39;, {
        context: this,
        args: [this, this.el]
    });
};
// Triggers handlers to &#39;dayClick&#39;
// Span has start/end of the clicked area. Only the start is useful.
View.prototype.triggerDayClick = function (footprint, dayEl, ev) {
    var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of &quot;Event&quot;DateProfile?
    this.publiclyTrigger(&#39;dayClick&#39;, {
        context: dayEl,
        args: [dateProfile.start, ev, this]
    });
};
/* Date Utils
------------------------------------------------------------------------------------------------------------------*/
// For DateComponent::getDayClasses
View.prototype.isDateInOtherMonth = function (date, dateProfile) {
    return false;
};
// Arguments after name will be forwarded to a hypothetical function value
// WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
// Always clone your objects if you fear mutation.
View.prototype.getUnzonedRangeOption = function (name) {
    var val = this.opt(name);
    if (typeof val === &#39;function&#39;) {
        val = val.apply(null, Array.prototype.slice.call(arguments, 1));
    }
    if (val) {
        return this.calendar.parseUnzonedRange(val);
    }
};
/* Hidden Days
------------------------------------------------------------------------------------------------------------------*/
// Initializes internal variables related to calculating hidden days-of-week
View.prototype.initHiddenDays = function () {
    var hiddenDays = this.opt(&#39;hiddenDays&#39;) || []; // array of day-of-week indices that are hidden
    var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -&gt; bool)
    var dayCnt = 0;
    var i;
    if (this.opt(&#39;weekends&#39;) === false) {
        hiddenDays.push(0, 6); // 0=sunday, 6=saturday
    }
    for (i = 0; i &lt; 7; i++) {
        if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {
            dayCnt++;
        }
    }
    if (!dayCnt) {
        throw new Error(&#39;invalid hiddenDays&#39;); // all days were hidden? bad.
    }
    this.isHiddenDayHash = isHiddenDayHash;
};
// Remove days from the beginning and end of the range that are computed as hidden.
// If the whole range is trimmed off, returns null
View.prototype.trimHiddenDays = function (inputUnzonedRange) {
    var start = inputUnzonedRange.getStart();
    var end = inputUnzonedRange.getEnd();
    if (start) {
        start = this.skipHiddenDays(start);
    }
    if (end) {
        end = this.skipHiddenDays(end, -1, true);
    }
    if (start === null || end === null || start &lt; end) {
        return new UnzonedRange_1.default(start, end);
    }
    return null;
};
// Is the current day hidden?
// `day` is a day-of-week index (0-6), or a Moment
View.prototype.isHiddenDay = function (day) {
    if (moment.isMoment(day)) {
        day = day.day();
    }
    return this.isHiddenDayHash[day];
};
// Incrementing the current day until it is no longer a hidden day, returning a copy.
// DOES NOT CONSIDER validUnzonedRange!
// If the initial value of `date` is not a hidden day, don&#39;t do anything.
// Pass `isExclusive` as `true` if you are dealing with an end date.
// `inc` defaults to `1` (increment one day forward each time)
View.prototype.skipHiddenDays = function (date, inc, isExclusive) {
    if (inc === void 0) { inc = 1; }
    if (isExclusive === void 0) { isExclusive = false; }
    var out = date.clone();
    while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {
        out.add(inc, &#39;days&#39;);
    }
    return out;
};
return View;</pre>

<p>}(InteractiveDateComponent_1.default)); exports.default = View;
View.prototype.usesMinMaxTime = false;
View.prototype.dateProfileGeneratorClass = DateProfileGenerator_1.default;
View.watch(&#39;displayingDates&#39;, [&#39;isInDom&#39;,
&#39;dateProfile&#39;], function (deps) {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">requestDateRender</span>(<span class="ruby-identifier">deps</span>.<span class="ruby-identifier">dateProfile</span>);
</pre>

<p>}, function () {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">requestDateUnrender</span>();
</pre>

<p>}); View.watch(&#39;displayingBusinessHours&#39;,
[&#39;displayingDates&#39;, &#39;businessHourGenerator&#39;], function
(deps) {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">requestBusinessHoursRender</span>(<span class="ruby-identifier">deps</span>.<span class="ruby-identifier">businessHourGenerator</span>);
</pre>

<p>}, function () {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">requestBusinessHoursUnrender</span>();
</pre>

<p>}); View.watch(&#39;initialEvents&#39;, [&#39;dateProfile&#39;], function
(deps) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fetchInitialEvents</span>(<span class="ruby-identifier">deps</span>.<span class="ruby-identifier">dateProfile</span>);
</pre>

<p>}); View.watch(&#39;bindingEvents&#39;, [&#39;initialEvents&#39;], function
(deps) {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">setEvents</span>(<span class="ruby-identifier">deps</span>.<span class="ruby-identifier">initialEvents</span>);
<span class="ruby-identifier">this</span>.<span class="ruby-identifier">bindEventChanges</span>();
</pre>

<p>}, function () {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">unbindEventChanges</span>();
<span class="ruby-identifier">this</span>.<span class="ruby-identifier">unsetEvents</span>();
</pre>

<p>}); View.watch(&#39;displayingEvents&#39;, [&#39;displayingDates&#39;,
&#39;hasEvents&#39;], function () {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">requestEventsRender</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">get</span>(<span class="ruby-string">&#39;currentEvents&#39;</span>));
</pre>

<p>}, function () {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">requestEventsUnrender</span>();
</pre>

<p>}); View.watch(&#39;title&#39;, [&#39;dateProfile&#39;], function (deps) {</p>

<pre>return (this.title = this.computeTitle(deps.dateProfile)); // assign to View for legacy reasons</pre>

<p>}); View.watch(&#39;legacyDateProps&#39;, [&#39;dateProfile&#39;], function
(deps) {</p>

<pre>var calendar = this.calendar;
var dateProfile = deps.dateProfile;
// DEPRECATED, but we need to keep it updated...
this.start = calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, dateProfile.isRangeAllDay);
this.end = calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, dateProfile.isRangeAllDay);
this.intervalStart = calendar.msToMoment(dateProfile.currentUnzonedRange.startMs, dateProfile.isRangeAllDay);
this.intervalEnd = calendar.msToMoment(dateProfile.currentUnzonedRange.endMs, dateProfile.isRangeAllDay);</pre>

<p>});</p>

<p>/***/ }), /* 42 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var util_1 = <em>webpack_require</em>(4); var
EventRenderer = /** @class */ (function () {</p>

<pre>function EventRenderer(component, fillRenderer) {
    this.view = component._getView();
    this.component = component;
    this.fillRenderer = fillRenderer;
}
EventRenderer.prototype.opt = function (name) {
    return this.view.opt(name);
};
// Updates values that rely on options and also relate to range
EventRenderer.prototype.rangeUpdated = function () {
    var displayEventTime;
    var displayEventEnd;
    this.eventTimeFormat =
        this.opt(&#39;eventTimeFormat&#39;) ||
            this.opt(&#39;timeFormat&#39;) || // deprecated
            this.computeEventTimeFormat();
    displayEventTime = this.opt(&#39;displayEventTime&#39;);
    if (displayEventTime == null) {
        displayEventTime = this.computeDisplayEventTime(); // might be based off of range
    }
    displayEventEnd = this.opt(&#39;displayEventEnd&#39;);
    if (displayEventEnd == null) {
        displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
    }
    this.displayEventTime = displayEventTime;
    this.displayEventEnd = displayEventEnd;
};
EventRenderer.prototype.render = function (eventsPayload) {
    var dateProfile = this.component._getDateProfile();
    var eventDefId;
    var instanceGroup;
    var eventRanges;
    var bgRanges = [];
    var fgRanges = [];
    for (eventDefId in eventsPayload) {
        instanceGroup = eventsPayload[eventDefId];
        eventRanges = instanceGroup.sliceRenderRanges(dateProfile.activeUnzonedRange);
        if (instanceGroup.getEventDef().hasBgRendering()) {
            bgRanges.push.apply(bgRanges, eventRanges);
        }
        else {
            fgRanges.push.apply(fgRanges, eventRanges);
        }
    }
    this.renderBgRanges(bgRanges);
    this.renderFgRanges(fgRanges);
};
EventRenderer.prototype.unrender = function () {
    this.unrenderBgRanges();
    this.unrenderFgRanges();
};
EventRenderer.prototype.renderFgRanges = function (eventRanges) {
    var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);
    var segs = this.component.eventFootprintsToSegs(eventFootprints);
    // render an `.el` on each seg
    // returns a subset of the segs. segs that were actually rendered
    segs = this.renderFgSegEls(segs);
    if (this.renderFgSegs(segs) !== false) {
        this.fgSegs = segs;
    }
};
EventRenderer.prototype.unrenderFgRanges = function () {
    this.unrenderFgSegs(this.fgSegs || []);
    this.fgSegs = null;
};
EventRenderer.prototype.renderBgRanges = function (eventRanges) {
    var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);
    var segs = this.component.eventFootprintsToSegs(eventFootprints);
    if (this.renderBgSegs(segs) !== false) {
        this.bgSegs = segs;
    }
};
EventRenderer.prototype.unrenderBgRanges = function () {
    this.unrenderBgSegs();
    this.bgSegs = null;
};
EventRenderer.prototype.getSegs = function () {
    return (this.bgSegs || []).concat(this.fgSegs || []);
};
// Renders foreground event segments onto the grid
EventRenderer.prototype.renderFgSegs = function (segs) {
    // subclasses must implement
    // segs already has rendered els, and has been filtered.
    return false; // signal failure if not implemented
};
// Unrenders all currently rendered foreground segments
EventRenderer.prototype.unrenderFgSegs = function (segs) {
    // subclasses must implement
};
EventRenderer.prototype.renderBgSegs = function (segs) {
    var _this = this;
    if (this.fillRenderer) {
        this.fillRenderer.renderSegs(&#39;bgEvent&#39;, segs, {
            getClasses: function (seg) {
                return _this.getBgClasses(seg.footprint.eventDef);
            },
            getCss: function (seg) {
                return {
                    &#39;background-color&#39;: _this.getBgColor(seg.footprint.eventDef)
                };
            },
            filterEl: function (seg, el) {
                return _this.filterEventRenderEl(seg.footprint, el);
            }
        });
    }
    else {
        return false; // signal failure if no fillRenderer
    }
};
EventRenderer.prototype.unrenderBgSegs = function () {
    if (this.fillRenderer) {
        this.fillRenderer.unrender(&#39;bgEvent&#39;);
    }
};
// Renders and assigns an `el` property for each foreground event segment.
// Only returns segments that successfully rendered.
EventRenderer.prototype.renderFgSegEls = function (segs, disableResizing) {
    var _this = this;
    if (disableResizing === void 0) { disableResizing = false; }
    var hasEventRenderHandlers = this.view.hasPublicHandlers(&#39;eventRender&#39;);
    var html = &#39;&#39;;
    var renderedSegs = [];
    var i;
    if (segs.length) {
        // build a large concatenation of event segment HTML
        for (i = 0; i &lt; segs.length; i++) {
            this.beforeFgSegHtml(segs[i]);
            html += this.fgSegHtml(segs[i], disableResizing);
        }
        // Grab individual elements from the combined HTML string. Use each as the default rendering.
        // Then, compute the &#39;el&#39; for each segment. An el might be null if the eventRender callback returned false.
        $(html).each(function (i, node) {
            var seg = segs[i];
            var el = $(node);
            if (hasEventRenderHandlers) {
                el = _this.filterEventRenderEl(seg.footprint, el);
            }
            if (el) {
                el.data(&#39;fc-seg&#39;, seg); // used by handlers
                seg.el = el;
                renderedSegs.push(seg);
            }
        });
    }
    return renderedSegs;
};
EventRenderer.prototype.beforeFgSegHtml = function (seg) {
};
// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
EventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
    // subclasses should implement
};
// Generic utility for generating the HTML classNames for an event segment&#39;s element
EventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable) {
    var classes = [
        &#39;fc-event&#39;,
        seg.isStart ? &#39;fc-start&#39; : &#39;fc-not-start&#39;,
        seg.isEnd ? &#39;fc-end&#39; : &#39;fc-not-end&#39;
    ].concat(this.getClasses(seg.footprint.eventDef));
    if (isDraggable) {
        classes.push(&#39;fc-draggable&#39;);
    }
    if (isResizable) {
        classes.push(&#39;fc-resizable&#39;);
    }
    // event is currently selected? attach a className.
    if (this.view.isEventDefSelected(seg.footprint.eventDef)) {
        classes.push(&#39;fc-selected&#39;);
    }
    return classes;
};
// Given an event and the default element used for rendering, returns the element that should actually be used.
// Basically runs events and elements through the eventRender hook.
EventRenderer.prototype.filterEventRenderEl = function (eventFootprint, el) {
    var legacy = eventFootprint.getEventLegacy();
    var custom = this.view.publiclyTrigger(&#39;eventRender&#39;, {
        context: legacy,
        args: [legacy, el, this.view]
    });
    if (custom === false) {
        el = null;
    }
    else if (custom &amp;&amp; custom !== true) {
        el = $(custom);
    }
    return el;
};
// Compute the text that should be displayed on an event&#39;s element.
// `range` can be the Event object itself, or something range-like, with at least a `start`.
// If event times are disabled, or the event has no time, will return a blank string.
// If not specified, formatStr will default to the eventTimeFormat setting,
// and displayEnd will default to the displayEventEnd setting.
EventRenderer.prototype.getTimeText = function (eventFootprint, formatStr, displayEnd) {
    return this._getTimeText(eventFootprint.eventInstance.dateProfile.start, eventFootprint.eventInstance.dateProfile.end, eventFootprint.componentFootprint.isAllDay, formatStr, displayEnd);
};
EventRenderer.prototype._getTimeText = function (start, end, isAllDay, formatStr, displayEnd) {
    if (formatStr == null) {
        formatStr = this.eventTimeFormat;
    }
    if (displayEnd == null) {
        displayEnd = this.displayEventEnd;
    }
    if (this.displayEventTime &amp;&amp; !isAllDay) {
        if (displayEnd &amp;&amp; end) {
            return this.view.formatRange({ start: start, end: end }, false, // allDay
            formatStr);
        }
        else {
            return start.format(formatStr);
        }
    }
    return &#39;&#39;;
};
EventRenderer.prototype.computeEventTimeFormat = function () {
    return this.opt(&#39;smallTimeFormat&#39;);
};
EventRenderer.prototype.computeDisplayEventTime = function () {
    return true;
};
EventRenderer.prototype.computeDisplayEventEnd = function () {
    return true;
};
EventRenderer.prototype.getBgClasses = function (eventDef) {
    var classNames = this.getClasses(eventDef);
    classNames.push(&#39;fc-bgevent&#39;);
    return classNames;
};
EventRenderer.prototype.getClasses = function (eventDef) {
    var objs = this.getStylingObjs(eventDef);
    var i;
    var classNames = [];
    for (i = 0; i &lt; objs.length; i++) {
        classNames.push.apply(// append
        classNames, objs[i].eventClassName || objs[i].className || []);
    }
    return classNames;
};
// Utility for generating event skin-related CSS properties
EventRenderer.prototype.getSkinCss = function (eventDef) {
    return {
        &#39;background-color&#39;: this.getBgColor(eventDef),
        &#39;border-color&#39;: this.getBorderColor(eventDef),
        color: this.getTextColor(eventDef)
    };
};
// Queries for caller-specified color, then falls back to default
EventRenderer.prototype.getBgColor = function (eventDef) {
    var objs = this.getStylingObjs(eventDef);
    var i;
    var val;
    for (i = 0; i &lt; objs.length &amp;&amp; !val; i++) {
        val = objs[i].eventBackgroundColor || objs[i].eventColor ||
            objs[i].backgroundColor || objs[i].color;
    }
    if (!val) {
        val = this.opt(&#39;eventBackgroundColor&#39;) || this.opt(&#39;eventColor&#39;);
    }
    return val;
};
// Queries for caller-specified color, then falls back to default
EventRenderer.prototype.getBorderColor = function (eventDef) {
    var objs = this.getStylingObjs(eventDef);
    var i;
    var val;
    for (i = 0; i &lt; objs.length &amp;&amp; !val; i++) {
        val = objs[i].eventBorderColor || objs[i].eventColor ||
            objs[i].borderColor || objs[i].color;
    }
    if (!val) {
        val = this.opt(&#39;eventBorderColor&#39;) || this.opt(&#39;eventColor&#39;);
    }
    return val;
};
// Queries for caller-specified color, then falls back to default
EventRenderer.prototype.getTextColor = function (eventDef) {
    var objs = this.getStylingObjs(eventDef);
    var i;
    var val;
    for (i = 0; i &lt; objs.length &amp;&amp; !val; i++) {
        val = objs[i].eventTextColor ||
            objs[i].textColor;
    }
    if (!val) {
        val = this.opt(&#39;eventTextColor&#39;);
    }
    return val;
};
EventRenderer.prototype.getStylingObjs = function (eventDef) {
    var objs = this.getFallbackStylingObjs(eventDef);
    objs.unshift(eventDef);
    return objs;
};
EventRenderer.prototype.getFallbackStylingObjs = function (eventDef) {
    return [eventDef.source];
};
EventRenderer.prototype.sortEventSegs = function (segs) {
    segs.sort(util_1.proxy(this, &#39;compareEventSegs&#39;));
};
// A cmp function for determining which segments should take visual priority
EventRenderer.prototype.compareEventSegs = function (seg1, seg2) {
    var f1 = seg1.footprint;
    var f2 = seg2.footprint;
    var cf1 = f1.componentFootprint;
    var cf2 = f2.componentFootprint;
    var r1 = cf1.unzonedRange;
    var r2 = cf2.unzonedRange;
    return r1.startMs - r2.startMs || // earlier events go first
        (r2.endMs - r2.startMs) - (r1.endMs - r1.startMs) || // tie? longer events go first
        cf2.isAllDay - cf1.isAllDay || // tie? put all-day events first (booleans cast to 0/1)
        util_1.compareByFieldSpecs(f1.eventDef, f2.eventDef, this.view.eventOrderSpecs, f1.eventDef.miscProps, f2.eventDef.miscProps);
};
return EventRenderer;</pre>

<p>}()); exports.default = EventRenderer;</p>

<p>/***/ }), /* 43 */, /* 44 */, /* 45 */, /* 46 */, /* 47 */ /***/
(function(module, exports, <em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
moment_ext_1 = <em>webpack_require</em>(10); // Plugin //
————————————————————————————————- moment_ext_1.newMomentProto.format =
function () {</p>

<pre>if (this._fullCalendar &amp;&amp; arguments[0]) {
    return formatDate(this, arguments[0]); // our extended formatting
}
if (this._ambigTime) {
    return moment_ext_1.oldMomentFormat(englishMoment(this), &#39;YYYY-MM-DD&#39;);
}
if (this._ambigZone) {
    return moment_ext_1.oldMomentFormat(englishMoment(this), &#39;YYYY-MM-DD[T]HH:mm:ss&#39;);
}
if (this._fullCalendar) {
    // moment.format() doesn&#39;t ensure english, but we want to.
    return moment_ext_1.oldMomentFormat(englishMoment(this));
}
return moment_ext_1.oldMomentProto.format.apply(this, arguments);</pre>

<p>}; moment_ext_1.newMomentProto.toISOString = function () {</p>

<pre>if (this._ambigTime) {
    return moment_ext_1.oldMomentFormat(englishMoment(this), &#39;YYYY-MM-DD&#39;);
}
if (this._ambigZone) {
    return moment_ext_1.oldMomentFormat(englishMoment(this), &#39;YYYY-MM-DD[T]HH:mm:ss&#39;);
}
if (this._fullCalendar) {
    // depending on browser, moment might not output english. ensure english.
    // https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22
    return moment_ext_1.oldMomentProto.toISOString.apply(englishMoment(this), arguments);
}
return moment_ext_1.oldMomentProto.toISOString.apply(this, arguments);</pre>

<p>}; function englishMoment(mom) {</p>

<pre>if (mom.locale() !== &#39;en&#39;) {
    return mom.clone().locale(&#39;en&#39;);
}
return mom;</pre>

<p>} // Config // ——————————————————————————————————————— /* Inserted between
chunks in the fake (“intermediate”) formatting string. Important that it
passes as whitespace (s) because moment often identifies non-standalone
months via a regexp with an s.</p>

<pre>/</pre>

<p>var PART_SEPARATOR = &#39;u000b&#39;; // vertical tab /* Inserted as the
first character of a literal-text chunk to indicate that the literal text
is not actually literal text, but rather, a “special” token that has custom
rendering (see specialTokens map).</p>

<pre>/</pre>

<p>var SPECIAL_TOKEN_MARKER = &#39;u001f&#39;; // information separator 1 /*
Inserted at the beginning and end of a span of text that must have non-zero
numeric characters. Handling of these markers is done in a post-processing
step at the very end of text rendering.</p>

<pre>/</pre>

<p>var MAYBE_MARKER = &#39;u001e&#39;; // information separator 2 var
MAYBE_REGEXP = new RegExp(MAYBE_MARKER + &#39;([^&#39; + MAYBE_MARKER +
&#39;]*)&#39; + MAYBE_MARKER, &#39;g&#39;); // must be global /* Addition
formatting tokens we want recognized</p>

<pre>/</pre>

<p>var specialTokens = {</p>

<pre>t: function (date) {
    return moment_ext_1.oldMomentFormat(date, &#39;a&#39;).charAt(0);
},
T: function (date) {
    return moment_ext_1.oldMomentFormat(date, &#39;A&#39;).charAt(0);
}</pre>

<p>}; /* The first characters of formatting tokens for units that are 1 day or
larger. `value` is for ranking relative size (lower means bigger). `unit`
is a normalized unit, used for comparing moments.</p>

<pre>/</pre>

<p>var largeTokenMap = {</p>

<pre>Y: { value: 1, unit: &#39;year&#39; },
M: { value: 2, unit: &#39;month&#39; },
W: { value: 3, unit: &#39;week&#39; },
w: { value: 3, unit: &#39;week&#39; },
D: { value: 4, unit: &#39;day&#39; },
d: { value: 4, unit: &#39;day&#39; } // day of week</pre>

<p>}; // Single Date Formatting // ——————————————————————————————————————— /*
Formats `date` with a Moment formatting string, but allow our non-zero
areas and special token</p>

<pre>/</pre>

<p>function formatDate(date, formatStr) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">renderFakeFormatString</span>(<span class="ruby-identifier">getParsedFormatString</span>(<span class="ruby-identifier">formatStr</span>).<span class="ruby-identifier">fakeFormatString</span>, <span class="ruby-identifier">date</span>);
</pre>

<p>} exports.formatDate = formatDate; // Date Range Formatting //
————————————————————————————————- // TODO: make it work with timezone
offset /* Using a formatting string meant for a single date, generate a
range string, like “Sep 2 - 9 2013”, that intelligently inserts a separator
where the dates differ. If the dates are the same as far as the format
string is concerned, just return a single rendering of one date, without
any separator.</p>

<pre>/</pre>

<p>function formatRange(date1, date2, formatStr, separator, isRTL) {</p>

<pre>var localeData;
date1 = moment_ext_1.default.parseZone(date1);
date2 = moment_ext_1.default.parseZone(date2);
localeData = date1.localeData();
// Expand localized format strings, like &quot;LL&quot; -&gt; &quot;MMMM D YYYY&quot;.
// BTW, this is not important for `formatDate` because it is impossible to put custom tokens
// or non-zero areas in Moment&#39;s localized format strings.
formatStr = localeData.longDateFormat(formatStr) || formatStr;
return renderParsedFormat(getParsedFormatString(formatStr), date1, date2, separator || &#39; - &#39;, isRTL);</pre>

<p>} exports.formatRange = formatRange; /* Renders a range with an
already-parsed format string.</p>

<pre>/</pre>

<p>function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {</p>

<pre>var sameUnits = parsedFormat.sameUnits;
var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons
var unzonedDate2 = date2.clone().stripZone(); // &quot;
var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);
var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);
var leftI;
var leftStr = &#39;&#39;;
var rightI;
var rightStr = &#39;&#39;;
var middleI;
var middleStr1 = &#39;&#39;;
var middleStr2 = &#39;&#39;;
var middleStr = &#39;&#39;;
// Start at the leftmost side of the formatting string and continue until you hit a token
// that is not the same between dates.
for (leftI = 0; leftI &lt; sameUnits.length &amp;&amp; (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI])); leftI++) {
    leftStr += renderedParts1[leftI];
}
// Similarly, start at the rightmost side of the formatting string and move left
for (rightI = sameUnits.length - 1; rightI &gt; leftI &amp;&amp; (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI])); rightI--) {
    // If current chunk is on the boundary of unique date-content, and is a special-case
    // date-formatting postfix character, then don&#39;t consume it. Consider it unique date-content.
    // TODO: make configurable
    if (rightI - 1 === leftI &amp;&amp; renderedParts1[rightI] === &#39;.&#39;) {
        break;
    }
    rightStr = renderedParts1[rightI] + rightStr;
}
// The area in the middle is different for both of the dates.
// Collect them distinctly so we can jam them together later.
for (middleI = leftI; middleI &lt;= rightI; middleI++) {
    middleStr1 += renderedParts1[middleI];
    middleStr2 += renderedParts2[middleI];
}
if (middleStr1 || middleStr2) {
    if (isRTL) {
        middleStr = middleStr2 + separator + middleStr1;
    }
    else {
        middleStr = middleStr1 + separator + middleStr2;
    }
}
return processMaybeMarkers(leftStr + middleStr + rightStr);</pre>

<p>} // Format String Parsing // ——————————————————————————————————————— var
parsedFormatStrCache = {}; /* Returns a parsed format string, leveraging a
cache.</p>

<pre>/</pre>

<p>function getParsedFormatString(formatStr) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">parsedFormatStrCache</span>[<span class="ruby-identifier">formatStr</span>] <span class="ruby-operator">||</span>
    (<span class="ruby-identifier">parsedFormatStrCache</span>[<span class="ruby-identifier">formatStr</span>] = <span class="ruby-identifier">parseFormatString</span>(<span class="ruby-identifier">formatStr</span>));
</pre>

<p>} /* Parses a format string into the following:</p>
<ul><li>
<p>fakeFormatString: a momentJS formatting string, littered with special
control characters that get post-processed.</p>
</li><li>
<p>sameUnits: for every part in fakeFormatString, if the part is a token, the
value will be a unit string (like “day”), that indicates how similar a
range&#39;s start &amp; end must be in order to share the same formatted
text. If not a token, then the value is null. Always a flat array (not
nested liked “chunks”).</p>
</li></ul>

<pre>/</pre>

<p>function parseFormatString(formatStr) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">chunks</span> = <span class="ruby-identifier">chunkFormatString</span>(<span class="ruby-identifier">formatStr</span>);
<span class="ruby-keyword">return</span> {
    <span class="ruby-value">fakeFormatString:</span> <span class="ruby-identifier">buildFakeFormatString</span>(<span class="ruby-identifier">chunks</span>),
    <span class="ruby-value">sameUnits:</span> <span class="ruby-identifier">buildSameUnits</span>(<span class="ruby-identifier">chunks</span>)
};
</pre>

<p>} /* Break the formatting string into an array of chunks. A &#39;maybe&#39;
chunk will have nested chunks.</p>

<pre>/</pre>

<p>function chunkFormatString(formatStr) {</p>

<pre>var chunks = [];
var match;
// TODO: more descrimination
// \4 is a backreference to the first character of a multi-character set.
var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;
while ((match = chunker.exec(formatStr))) {
    if (match[1]) {
        chunks.push.apply(chunks, // append
        splitStringLiteral(match[1]));
    }
    else if (match[2]) {
        chunks.push({ maybe: chunkFormatString(match[2]) });
    }
    else if (match[3]) {
        chunks.push({ token: match[3] });
    }
    else if (match[5]) {
        chunks.push.apply(chunks, // append
        splitStringLiteral(match[5]));
    }
}
return chunks;</pre>

<p>} /* Potentially splits a literal-text string into multiple parts. For
special cases.</p>

<pre>/</pre>

<p>function splitStringLiteral(s) {</p>

<pre>if (s === &#39;. &#39;) {
    return [&#39;.&#39;, &#39; &#39;]; // for locales with periods bound to the end of each year/month/date
}
else {
    return [s];
}</pre>

<p>} /* Given chunks parsed from a real format string, generate a fake (aka
“intermediate”) format string with special control characters that will
eventually be given to moment for formatting, and then post-processed.</p>

<pre>/</pre>

<p>function buildFakeFormatString(chunks) {</p>

<pre>var parts = [];
var i;
var chunk;
for (i = 0; i &lt; chunks.length; i++) {
    chunk = chunks[i];
    if (typeof chunk === &#39;string&#39;) {
        parts.push(&#39;[&#39; + chunk + &#39;]&#39;);
    }
    else if (chunk.token) {
        if (chunk.token in specialTokens) {
            parts.push(SPECIAL_TOKEN_MARKER + // useful during post-processing
                &#39;[&#39; + chunk.token + &#39;]&#39; // preserve as literal text
            );
        }
        else {
            parts.push(chunk.token); // unprotected text implies a format string
        }
    }
    else if (chunk.maybe) {
        parts.push(MAYBE_MARKER + // useful during post-processing
            buildFakeFormatString(chunk.maybe) +
            MAYBE_MARKER);
    }
}
return parts.join(PART_SEPARATOR);</pre>

<p>} /* Given parsed chunks from a real formatting string, generates an array
of unit strings (like “day”) that indicate in which regard two dates must
be similar in order to share range formatting text. The `chunks` can be
nested (because of “maybe” chunks), however, the returned array will be
flat.</p>

<pre>/</pre>

<p>function buildSameUnits(chunks) {</p>

<pre>var units = [];
var i;
var chunk;
var tokenInfo;
for (i = 0; i &lt; chunks.length; i++) {
    chunk = chunks[i];
    if (chunk.token) {
        tokenInfo = largeTokenMap[chunk.token.charAt(0)];
        units.push(tokenInfo ? tokenInfo.unit : &#39;second&#39;); // default to a very strict same-second
    }
    else if (chunk.maybe) {
        units.push.apply(units, // append
        buildSameUnits(chunk.maybe));
    }
    else {
        units.push(null);
    }
}
return units;</pre>

<p>} // Rendering to text // ——————————————————————————————————————— /*
Formats a date with a fake format string, post-processes the control
characters, then returns.</p>

<pre>/</pre>

<p>function renderFakeFormatString(fakeFormatString, date) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">processMaybeMarkers</span>(<span class="ruby-identifier">renderFakeFormatStringParts</span>(<span class="ruby-identifier">fakeFormatString</span>, <span class="ruby-identifier">date</span>).<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39;&#39;</span>));
</pre>

<p>} /* Formats a date into parts that will have been post-processed, EXCEPT
for the “maybe” markers.</p>

<pre>/</pre>

<p>function renderFakeFormatStringParts(fakeFormatString, date) {</p>

<pre>var parts = [];
var fakeRender = moment_ext_1.oldMomentFormat(date, fakeFormatString);
var fakeParts = fakeRender.split(PART_SEPARATOR);
var i;
var fakePart;
for (i = 0; i &lt; fakeParts.length; i++) {
    fakePart = fakeParts[i];
    if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {
        parts.push(
        // the literal string IS the token&#39;s name.
        // call special token&#39;s registered function.
        specialTokens[fakePart.substring(1)](date));
    }
    else {
        parts.push(fakePart);
    }
}
return parts;</pre>

<p>} /* Accepts an almost-finally-formatted string and processes the “maybe”
control characters, returning a new string.</p>

<pre>/</pre>

<p>function processMaybeMarkers(s) {</p>

<pre>return s.replace(MAYBE_REGEXP, function (m0, m1) {
    if (m1.match(/[1-9]/)) {
        return m1;
    }
    else {
        return &#39;&#39;;
    }
});</pre>

<p>} // Misc Utils // ————————————————————————————————- /* Returns a unit
string, either &#39;year&#39;, &#39;month&#39;, &#39;day&#39;, or null for
the most granular formatting token in the string.</p>

<pre>/</pre>

<p>function queryMostGranularFormatUnit(formatStr) {</p>

<pre>var chunks = chunkFormatString(formatStr);
var i;
var chunk;
var candidate;
var best;
for (i = 0; i &lt; chunks.length; i++) {
    chunk = chunks[i];
    if (chunk.token) {
        candidate = largeTokenMap[chunk.token.charAt(0)];
        if (candidate) {
            if (!best || candidate.value &gt; best.value) {
                best = candidate;
            }
        }
    }
}
if (best) {
    return best.unit;
}
return null;</pre>

<p>} exports.queryMostGranularFormatUnit = queryMostGranularFormatUnit;</p>

<p>/***/ }), /* 48 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var Class_1 = <em>webpack_require</em>(33);
var EmitterMixin_1 = <em>webpack_require</em>(11); var ListenerMixin_1 =
<em>webpack_require</em>(7); var Model = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(Model, _super);
function Model() {
    var _this = _super.call(this) || this;
    _this._watchers = {};
    _this._props = {};
    _this.applyGlobalWatchers();
    _this.constructed();
    return _this;
}
Model.watch = function (name) {
    var args = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    // subclasses should make a masked-copy of the superclass&#39;s map
    // TODO: write test
    if (!this.prototype.hasOwnProperty(&#39;_globalWatchArgs&#39;)) {
        this.prototype._globalWatchArgs = Object.create(this.prototype._globalWatchArgs);
    }
    this.prototype._globalWatchArgs[name] = args;
};
Model.prototype.constructed = function () {
    // useful for monkeypatching. TODO: BaseClass?
};
Model.prototype.applyGlobalWatchers = function () {
    var map = this._globalWatchArgs;
    var name;
    for (name in map) {
        this.watch.apply(this, [name].concat(map[name]));
    }
};
Model.prototype.has = function (name) {
    return name in this._props;
};
Model.prototype.get = function (name) {
    if (name === undefined) {
        return this._props;
    }
    return this._props[name];
};
Model.prototype.set = function (name, val) {
    var newProps;
    if (typeof name === &#39;string&#39;) {
        newProps = {};
        newProps[name] = val === undefined ? null : val;
    }
    else {
        newProps = name;
    }
    this.setProps(newProps);
};
Model.prototype.reset = function (newProps) {
    var oldProps = this._props;
    var changeset = {}; // will have undefined&#39;s to signal unsets
    var name;
    for (name in oldProps) {
        changeset[name] = undefined;
    }
    for (name in newProps) {
        changeset[name] = newProps[name];
    }
    this.setProps(changeset);
};
Model.prototype.unset = function (name) {
    var newProps = {};
    var names;
    var i;
    if (typeof name === &#39;string&#39;) {
        names = [name];
    }
    else {
        names = name;
    }
    for (i = 0; i &lt; names.length; i++) {
        newProps[names[i]] = undefined;
    }
    this.setProps(newProps);
};
Model.prototype.setProps = function (newProps) {
    var changedProps = {};
    var changedCnt = 0;
    var name;
    var val;
    for (name in newProps) {
        val = newProps[name];
        // a change in value?
        // if an object, don&#39;t check equality, because might have been mutated internally.
        // TODO: eventually enforce immutability.
        if (typeof val === &#39;object&#39; ||
            val !== this._props[name]) {
            changedProps[name] = val;
            changedCnt++;
        }
    }
    if (changedCnt) {
        this.trigger(&#39;before:batchChange&#39;, changedProps);
        for (name in changedProps) {
            val = changedProps[name];
            this.trigger(&#39;before:change&#39;, name, val);
            this.trigger(&#39;before:change:&#39; + name, val);
        }
        for (name in changedProps) {
            val = changedProps[name];
            if (val === undefined) {
                delete this._props[name];
            }
            else {
                this._props[name] = val;
            }
            this.trigger(&#39;change:&#39; + name, val);
            this.trigger(&#39;change&#39;, name, val);
        }
        this.trigger(&#39;batchChange&#39;, changedProps);
    }
};
Model.prototype.watch = function (name, depList, startFunc, stopFunc) {
    var _this = this;
    this.unwatch(name);
    this._watchers[name] = this._watchDeps(depList, function (deps) {
        var res = startFunc.call(_this, deps);
        if (res &amp;&amp; res.then) {
            _this.unset(name); // put in an unset state while resolving
            res.then(function (val) {
                _this.set(name, val);
            });
        }
        else {
            _this.set(name, res);
        }
    }, function (deps) {
        _this.unset(name);
        if (stopFunc) {
            stopFunc.call(_this, deps);
        }
    });
};
Model.prototype.unwatch = function (name) {
    var watcher = this._watchers[name];
    if (watcher) {
        delete this._watchers[name];
        watcher.teardown();
    }
};
Model.prototype._watchDeps = function (depList, startFunc, stopFunc) {
    var _this = this;
    var queuedChangeCnt = 0;
    var depCnt = depList.length;
    var satisfyCnt = 0;
    var values = {}; // what&#39;s passed as the `deps` arguments
    var bindTuples = []; // array of [ eventName, handlerFunc ] arrays
    var isCallingStop = false;
    var onBeforeDepChange = function (depName, val, isOptional) {
        queuedChangeCnt++;
        if (queuedChangeCnt === 1) {
            if (satisfyCnt === depCnt) {
                isCallingStop = true;
                stopFunc(values);
                isCallingStop = false;
            }
        }
    };
    var onDepChange = function (depName, val, isOptional) {
        if (val === undefined) {
            // required dependency that was previously set?
            if (!isOptional &amp;&amp; values[depName] !== undefined) {
                satisfyCnt--;
            }
            delete values[depName];
        }
        else {
            // required dependency that was previously unset?
            if (!isOptional &amp;&amp; values[depName] === undefined) {
                satisfyCnt++;
            }
            values[depName] = val;
        }
        queuedChangeCnt--;
        if (!queuedChangeCnt) {
            // now finally satisfied or satisfied all along?
            if (satisfyCnt === depCnt) {
                // if the stopFunc initiated another value change, ignore it.
                // it will be processed by another change event anyway.
                if (!isCallingStop) {
                    startFunc(values);
                }
            }
        }
    };
    // intercept for .on() that remembers handlers
    var bind = function (eventName, handler) {
        _this.on(eventName, handler);
        bindTuples.push([eventName, handler]);
    };
    // listen to dependency changes
    depList.forEach(function (depName) {
        var isOptional = false;
        if (depName.charAt(0) === &#39;?&#39;) {
            depName = depName.substring(1);
            isOptional = true;
        }
        bind(&#39;before:change:&#39; + depName, function (val) {
            onBeforeDepChange(depName, val, isOptional);
        });
        bind(&#39;change:&#39; + depName, function (val) {
            onDepChange(depName, val, isOptional);
        });
    });
    // process current dependency values
    depList.forEach(function (depName) {
        var isOptional = false;
        if (depName.charAt(0) === &#39;?&#39;) {
            depName = depName.substring(1);
            isOptional = true;
        }
        if (_this.has(depName)) {
            values[depName] = _this.get(depName);
            satisfyCnt++;
        }
        else if (isOptional) {
            satisfyCnt++;
        }
    });
    // initially satisfied
    if (satisfyCnt === depCnt) {
        startFunc(values);
    }
    return {
        teardown: function () {
            // remove all handlers
            for (var i = 0; i &lt; bindTuples.length; i++) {
                _this.off(bindTuples[i][0], bindTuples[i][1]);
            }
            bindTuples = null;
            // was satisfied, so call stopFunc
            if (satisfyCnt === depCnt) {
                stopFunc();
            }
        },
        flash: function () {
            if (satisfyCnt === depCnt) {
                stopFunc();
                startFunc(values);
            }
        }
    };
};
Model.prototype.flash = function (name) {
    var watcher = this._watchers[name];
    if (watcher) {
        watcher.flash();
    }
};
return Model;</pre>

<p>}(Class_1.default)); exports.default = Model;
Model.prototype._globalWatchArgs = {}; // mutation protection in
Model.watch EmitterMixin_1.default.mixInto(Model);
ListenerMixin_1.default.mixInto(Model);</p>

<p>/***/ }), /* 49 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var moment =
<em>webpack_require</em>(0); var util_1 = <em>webpack_require</em>(4); var
SingleEventDef_1 = <em>webpack_require</em>(13); var RecurringEventDef_1 =
<em>webpack_require</em>(210); exports.default = {</p>

<pre>parse: function (eventInput, source) {
    if (util_1.isTimeString(eventInput.start) || moment.isDuration(eventInput.start) ||
        util_1.isTimeString(eventInput.end) || moment.isDuration(eventInput.end)) {
        return RecurringEventDef_1.default.parse(eventInput, source);
    }
    else {
        return SingleEventDef_1.default.parse(eventInput, source);
    }
}</pre>

<p>};</p>

<p>/***/ }), /* 50 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var util_1 =
<em>webpack_require</em>(4); var EventDateProfile_1 =
<em>webpack_require</em>(17); var EventDefDateMutation = /** @class */
(function () {</p>

<pre>function EventDefDateMutation() {
    this.clearEnd = false;
    this.forceTimed = false;
    this.forceAllDay = false;
}
EventDefDateMutation.createFromDiff = function (dateProfile0, dateProfile1, largeUnit) {
    var clearEnd = dateProfile0.end &amp;&amp; !dateProfile1.end;
    var forceTimed = dateProfile0.isAllDay() &amp;&amp; !dateProfile1.isAllDay();
    var forceAllDay = !dateProfile0.isAllDay() &amp;&amp; dateProfile1.isAllDay();
    var dateDelta;
    var endDiff;
    var endDelta;
    var mutation;
    // subtracts the dates in the appropriate way, returning a duration
    function subtractDates(date1, date0) {
        if (largeUnit) {
            return util_1.diffByUnit(date1, date0, largeUnit); // poorly named
        }
        else if (dateProfile1.isAllDay()) {
            return util_1.diffDay(date1, date0); // poorly named
        }
        else {
            return util_1.diffDayTime(date1, date0); // poorly named
        }
    }
    dateDelta = subtractDates(dateProfile1.start, dateProfile0.start);
    if (dateProfile1.end) {
        // use unzonedRanges because dateProfile0.end might be null
        endDiff = subtractDates(dateProfile1.unzonedRange.getEnd(), dateProfile0.unzonedRange.getEnd());
        endDelta = endDiff.subtract(dateDelta);
    }
    mutation = new EventDefDateMutation();
    mutation.clearEnd = clearEnd;
    mutation.forceTimed = forceTimed;
    mutation.forceAllDay = forceAllDay;
    mutation.setDateDelta(dateDelta);
    mutation.setEndDelta(endDelta);
    return mutation;
};
/*
returns an undo function.
 /
EventDefDateMutation.prototype.buildNewDateProfile = function (eventDateProfile, calendar) {
    var start = eventDateProfile.start.clone();
    var end = null;
    var shouldRezone = false;
    if (eventDateProfile.end &amp;&amp; !this.clearEnd) {
        end = eventDateProfile.end.clone();
    }
    else if (this.endDelta &amp;&amp; !end) {
        end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);
    }
    if (this.forceTimed) {
        shouldRezone = true;
        if (!start.hasTime()) {
            start.time(0);
        }
        if (end &amp;&amp; !end.hasTime()) {
            end.time(0);
        }
    }
    else if (this.forceAllDay) {
        if (start.hasTime()) {
            start.stripTime();
        }
        if (end &amp;&amp; end.hasTime()) {
            end.stripTime();
        }
    }
    if (this.dateDelta) {
        shouldRezone = true;
        start.add(this.dateDelta);
        if (end) {
            end.add(this.dateDelta);
        }
    }
    // do this before adding startDelta to start, so we can work off of start
    if (this.endDelta) {
        shouldRezone = true;
        end.add(this.endDelta);
    }
    if (this.startDelta) {
        shouldRezone = true;
        start.add(this.startDelta);
    }
    if (shouldRezone) {
        start = calendar.applyTimezone(start);
        if (end) {
            end = calendar.applyTimezone(end);
        }
    }
    // TODO: okay to access calendar option?
    if (!end &amp;&amp; calendar.opt(&#39;forceEventDuration&#39;)) {
        end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);
    }
    return new EventDateProfile_1.default(start, end, calendar);
};
EventDefDateMutation.prototype.setDateDelta = function (dateDelta) {
    if (dateDelta &amp;&amp; dateDelta.valueOf()) {
        this.dateDelta = dateDelta;
    }
    else {
        this.dateDelta = null;
    }
};
EventDefDateMutation.prototype.setStartDelta = function (startDelta) {
    if (startDelta &amp;&amp; startDelta.valueOf()) {
        this.startDelta = startDelta;
    }
    else {
        this.startDelta = null;
    }
};
EventDefDateMutation.prototype.setEndDelta = function (endDelta) {
    if (endDelta &amp;&amp; endDelta.valueOf()) {
        this.endDelta = endDelta;
    }
    else {
        this.endDelta = null;
    }
};
EventDefDateMutation.prototype.isEmpty = function () {
    return !this.clearEnd &amp;&amp; !this.forceTimed &amp;&amp; !this.forceAllDay &amp;&amp;
        !this.dateDelta &amp;&amp; !this.startDelta &amp;&amp; !this.endDelta;
};
return EventDefDateMutation;</pre>

<p>}()); exports.default = EventDefDateMutation;</p>

<p>/***/ }), /* 51 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
StandardTheme_1 = <em>webpack_require</em>(213); var JqueryUiTheme_1 =
<em>webpack_require</em>(214); var themeClassHash = {}; function
defineThemeSystem(themeName, themeClass) {</p>

<pre class="ruby"><span class="ruby-identifier">themeClassHash</span>[<span class="ruby-identifier">themeName</span>] = <span class="ruby-identifier">themeClass</span>;
</pre>

<p>} exports.defineThemeSystem = defineThemeSystem; function
getThemeSystemClass(themeSetting) {</p>

<pre>if (!themeSetting) {
    return StandardTheme_1.default;
}
else if (themeSetting === true) {
    return JqueryUiTheme_1.default;
}
else {
    return themeClassHash[themeSetting];
}</pre>

<p>} exports.getThemeSystemClass = getThemeSystemClass;</p>

<p>/***/ }), /* 52 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var Promise_1 =
<em>webpack_require</em>(20); var EventSource_1 =
<em>webpack_require</em>(6); var SingleEventDef_1 =
<em>webpack_require</em>(13); var ArrayEventSource = /** @class */
(function (_super) {</p>

<pre>tslib_1.__extends(ArrayEventSource, _super);
function ArrayEventSource(calendar) {
    var _this = _super.call(this, calendar) || this;
    _this.eventDefs = []; // for if setRawEventDefs is never called
    return _this;
}
ArrayEventSource.parse = function (rawInput, calendar) {
    var rawProps;
    // normalize raw input
    if ($.isArray(rawInput.events)) {
        rawProps = rawInput;
    }
    else if ($.isArray(rawInput)) {
        rawProps = { events: rawInput };
    }
    if (rawProps) {
        return EventSource_1.default.parse.call(this, rawProps, calendar);
    }
    return false;
};
ArrayEventSource.prototype.setRawEventDefs = function (rawEventDefs) {
    this.rawEventDefs = rawEventDefs;
    this.eventDefs = this.parseEventDefs(rawEventDefs);
};
ArrayEventSource.prototype.fetch = function (start, end, timezone) {
    var eventDefs = this.eventDefs;
    var i;
    if (this.currentTimezone != null &amp;&amp;
        this.currentTimezone !== timezone) {
        for (i = 0; i &lt; eventDefs.length; i++) {
            if (eventDefs[i] instanceof SingleEventDef_1.default) {
                eventDefs[i].rezone();
            }
        }
    }
    this.currentTimezone = timezone;
    return Promise_1.default.resolve(eventDefs);
};
ArrayEventSource.prototype.addEventDef = function (eventDef) {
    this.eventDefs.push(eventDef);
};
/*
eventDefId already normalized to a string
 /
ArrayEventSource.prototype.removeEventDefsById = function (eventDefId) {
    return util_1.removeMatching(this.eventDefs, function (eventDef) {
        return eventDef.id === eventDefId;
    });
};
ArrayEventSource.prototype.removeAllEventDefs = function () {
    this.eventDefs = [];
};
ArrayEventSource.prototype.getPrimitive = function () {
    return this.rawEventDefs;
};
ArrayEventSource.prototype.applyManualStandardProps = function (rawProps) {
    var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
    this.setRawEventDefs(rawProps.events);
    return superSuccess;
};
return ArrayEventSource;</pre>

<p>}(EventSource_1.default)); exports.default = ArrayEventSource;
ArrayEventSource.defineStandardProps({</p>

<pre>events: false // don&#39;t automatically transfer</pre>

<p>});</p>

<p>/***/ }), /* 53 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var util_1 = <em>webpack_require</em>(4); /* A
cache for the left/right/top/bottom/width/height values for one or more
elements. Works with both offset (from topleft document) and position (from
offsetParent).</p>

<p>options:</p>
<ul><li>
<p>els</p>
</li><li>
<p>isHorizontal</p>
</li><li>
<p>isVertical</p>
</li></ul>

<pre>/</pre>

<p>var CoordCache = /** @class */ (function () {</p>

<pre>function CoordCache(options) {
    this.isHorizontal = false; // whether to query for left/right/width
    this.isVertical = false; // whether to query for top/bottom/height
    this.els = $(options.els);
    this.isHorizontal = options.isHorizontal;
    this.isVertical = options.isVertical;
    this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
}
// Queries the els for coordinates and stores them.
// Call this method before using and of the get* methods below.
CoordCache.prototype.build = function () {
    var offsetParentEl = this.forcedOffsetParentEl;
    if (!offsetParentEl &amp;&amp; this.els.length &gt; 0) {
        offsetParentEl = this.els.eq(0).offsetParent();
    }
    this.origin = offsetParentEl ?
        offsetParentEl.offset() :
        null;
    this.boundingRect = this.queryBoundingRect();
    if (this.isHorizontal) {
        this.buildElHorizontals();
    }
    if (this.isVertical) {
        this.buildElVerticals();
    }
};
// Destroys all internal data about coordinates, freeing memory
CoordCache.prototype.clear = function () {
    this.origin = null;
    this.boundingRect = null;
    this.lefts = null;
    this.rights = null;
    this.tops = null;
    this.bottoms = null;
};
// When called, if coord caches aren&#39;t built, builds them
CoordCache.prototype.ensureBuilt = function () {
    if (!this.origin) {
        this.build();
    }
};
// Populates the left/right internal coordinate arrays
CoordCache.prototype.buildElHorizontals = function () {
    var lefts = [];
    var rights = [];
    this.els.each(function (i, node) {
        var el = $(node);
        var left = el.offset().left;
        var width = el.outerWidth();
        lefts.push(left);
        rights.push(left + width);
    });
    this.lefts = lefts;
    this.rights = rights;
};
// Populates the top/bottom internal coordinate arrays
CoordCache.prototype.buildElVerticals = function () {
    var tops = [];
    var bottoms = [];
    this.els.each(function (i, node) {
        var el = $(node);
        var top = el.offset().top;
        var height = el.outerHeight();
        tops.push(top);
        bottoms.push(top + height);
    });
    this.tops = tops;
    this.bottoms = bottoms;
};
// Given a left offset (from document left), returns the index of the el that it horizontally intersects.
// If no intersection is made, returns undefined.
CoordCache.prototype.getHorizontalIndex = function (leftOffset) {
    this.ensureBuilt();
    var lefts = this.lefts;
    var rights = this.rights;
    var len = lefts.length;
    var i;
    for (i = 0; i &lt; len; i++) {
        if (leftOffset &gt;= lefts[i] &amp;&amp; leftOffset &lt; rights[i]) {
            return i;
        }
    }
};
// Given a top offset (from document top), returns the index of the el that it vertically intersects.
// If no intersection is made, returns undefined.
CoordCache.prototype.getVerticalIndex = function (topOffset) {
    this.ensureBuilt();
    var tops = this.tops;
    var bottoms = this.bottoms;
    var len = tops.length;
    var i;
    for (i = 0; i &lt; len; i++) {
        if (topOffset &gt;= tops[i] &amp;&amp; topOffset &lt; bottoms[i]) {
            return i;
        }
    }
};
// Gets the left offset (from document left) of the element at the given index
CoordCache.prototype.getLeftOffset = function (leftIndex) {
    this.ensureBuilt();
    return this.lefts[leftIndex];
};
// Gets the left position (from offsetParent left) of the element at the given index
CoordCache.prototype.getLeftPosition = function (leftIndex) {
    this.ensureBuilt();
    return this.lefts[leftIndex] - this.origin.left;
};
// Gets the right offset (from document left) of the element at the given index.
// This value is NOT relative to the document&#39;s right edge, like the CSS concept of &quot;right&quot; would be.
CoordCache.prototype.getRightOffset = function (leftIndex) {
    this.ensureBuilt();
    return this.rights[leftIndex];
};
// Gets the right position (from offsetParent left) of the element at the given index.
// This value is NOT relative to the offsetParent&#39;s right edge, like the CSS concept of &quot;right&quot; would be.
CoordCache.prototype.getRightPosition = function (leftIndex) {
    this.ensureBuilt();
    return this.rights[leftIndex] - this.origin.left;
};
// Gets the width of the element at the given index
CoordCache.prototype.getWidth = function (leftIndex) {
    this.ensureBuilt();
    return this.rights[leftIndex] - this.lefts[leftIndex];
};
// Gets the top offset (from document top) of the element at the given index
CoordCache.prototype.getTopOffset = function (topIndex) {
    this.ensureBuilt();
    return this.tops[topIndex];
};
// Gets the top position (from offsetParent top) of the element at the given position
CoordCache.prototype.getTopPosition = function (topIndex) {
    this.ensureBuilt();
    return this.tops[topIndex] - this.origin.top;
};
// Gets the bottom offset (from the document top) of the element at the given index.
// This value is NOT relative to the offsetParent&#39;s bottom edge, like the CSS concept of &quot;bottom&quot; would be.
CoordCache.prototype.getBottomOffset = function (topIndex) {
    this.ensureBuilt();
    return this.bottoms[topIndex];
};
// Gets the bottom position (from the offsetParent top) of the element at the given index.
// This value is NOT relative to the offsetParent&#39;s bottom edge, like the CSS concept of &quot;bottom&quot; would be.
CoordCache.prototype.getBottomPosition = function (topIndex) {
    this.ensureBuilt();
    return this.bottoms[topIndex] - this.origin.top;
};
// Gets the height of the element at the given index
CoordCache.prototype.getHeight = function (topIndex) {
    this.ensureBuilt();
    return this.bottoms[topIndex] - this.tops[topIndex];
};
// Bounding Rect
// TODO: decouple this from CoordCache
// Compute and return what the elements&#39; bounding rectangle is, from the user&#39;s perspective.
// Right now, only returns a rectangle if constrained by an overflow:scroll element.
// Returns null if there are no elements
CoordCache.prototype.queryBoundingRect = function () {
    var scrollParentEl;
    if (this.els.length &gt; 0) {
        scrollParentEl = util_1.getScrollParent(this.els.eq(0));
        if (!scrollParentEl.is(document)) {
            return util_1.getClientRect(scrollParentEl);
        }
    }
    return null;
};
CoordCache.prototype.isPointInBounds = function (leftOffset, topOffset) {
    return this.isLeftInBounds(leftOffset) &amp;&amp; this.isTopInBounds(topOffset);
};
CoordCache.prototype.isLeftInBounds = function (leftOffset) {
    return !this.boundingRect || (leftOffset &gt;= this.boundingRect.left &amp;&amp; leftOffset &lt; this.boundingRect.right);
};
CoordCache.prototype.isTopInBounds = function (topOffset) {
    return !this.boundingRect || (topOffset &gt;= this.boundingRect.top &amp;&amp; topOffset &lt; this.boundingRect.bottom);
};
return CoordCache;</pre>

<p>}()); exports.default = CoordCache;</p>

<p>/***/ }), /* 54 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var util_1 = <em>webpack_require</em>(4); var
ListenerMixin_1 = <em>webpack_require</em>(7); var GlobalEmitter_1 =
<em>webpack_require</em>(21); /* Tracks a drag&#39;s mouse movement, firing
various handlers ———————————————————————————————————————-*/ // TODO: use
Emitter var DragListener = /** @class */ (function () {</p>

<pre>function DragListener(options) {
    this.isInteracting = false;
    this.isDistanceSurpassed = false;
    this.isDelayEnded = false;
    this.isDragging = false;
    this.isTouch = false;
    this.isGeneric = false; // initiated by &#39;dragstart&#39; (jqui)
    this.shouldCancelTouchScroll = true;
    this.scrollAlwaysKills = false;
    this.isAutoScroll = false;
    // defaults
    this.scrollSensitivity = 30; // pixels from edge for scrolling to start
    this.scrollSpeed = 200; // pixels per second, at maximum speed
    this.scrollIntervalMs = 50; // millisecond wait between scroll increment
    this.options = options || {};
}
// Interaction (high-level)
// -----------------------------------------------------------------------------------------------------------------
DragListener.prototype.startInteraction = function (ev, extraOptions) {
    if (extraOptions === void 0) { extraOptions = {}; }
    if (ev.type === &#39;mousedown&#39;) {
        if (GlobalEmitter_1.default.get().shouldIgnoreMouse()) {
            return;
        }
        else if (!util_1.isPrimaryMouseButton(ev)) {
            return;
        }
        else {
            ev.preventDefault(); // prevents native selection in most browsers
        }
    }
    if (!this.isInteracting) {
        // process options
        this.delay = util_1.firstDefined(extraOptions.delay, this.options.delay, 0);
        this.minDistance = util_1.firstDefined(extraOptions.distance, this.options.distance, 0);
        this.subjectEl = this.options.subjectEl;
        util_1.preventSelection($(&#39;body&#39;));
        this.isInteracting = true;
        this.isTouch = util_1.getEvIsTouch(ev);
        this.isGeneric = ev.type === &#39;dragstart&#39;;
        this.isDelayEnded = false;
        this.isDistanceSurpassed = false;
        this.originX = util_1.getEvX(ev);
        this.originY = util_1.getEvY(ev);
        this.scrollEl = util_1.getScrollParent($(ev.target));
        this.bindHandlers();
        this.initAutoScroll();
        this.handleInteractionStart(ev);
        this.startDelay(ev);
        if (!this.minDistance) {
            this.handleDistanceSurpassed(ev);
        }
    }
};
DragListener.prototype.handleInteractionStart = function (ev) {
    this.trigger(&#39;interactionStart&#39;, ev);
};
DragListener.prototype.endInteraction = function (ev, isCancelled) {
    if (this.isInteracting) {
        this.endDrag(ev);
        if (this.delayTimeoutId) {
            clearTimeout(this.delayTimeoutId);
            this.delayTimeoutId = null;
        }
        this.destroyAutoScroll();
        this.unbindHandlers();
        this.isInteracting = false;
        this.handleInteractionEnd(ev, isCancelled);
        util_1.allowSelection($(&#39;body&#39;));
    }
};
DragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {
    this.trigger(&#39;interactionEnd&#39;, ev, isCancelled || false);
};
// Binding To DOM
// -----------------------------------------------------------------------------------------------------------------
DragListener.prototype.bindHandlers = function () {
    // some browsers (Safari in iOS 10) don&#39;t allow preventDefault on touch events that are bound after touchstart,
    // so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.
    var globalEmitter = GlobalEmitter_1.default.get();
    if (this.isGeneric) {
        this.listenTo($(document), {
            drag: this.handleMove,
            dragstop: this.endInteraction
        });
    }
    else if (this.isTouch) {
        this.listenTo(globalEmitter, {
            touchmove: this.handleTouchMove,
            touchend: this.endInteraction,
            scroll: this.handleTouchScroll
        });
    }
    else {
        this.listenTo(globalEmitter, {
            mousemove: this.handleMouseMove,
            mouseup: this.endInteraction
        });
    }
    this.listenTo(globalEmitter, {
        selectstart: util_1.preventDefault,
        contextmenu: util_1.preventDefault // long taps would open menu on Chrome dev tools
    });
};
DragListener.prototype.unbindHandlers = function () {
    this.stopListeningTo(GlobalEmitter_1.default.get());
    this.stopListeningTo($(document)); // for isGeneric
};
// Drag (high-level)
// -----------------------------------------------------------------------------------------------------------------
// extraOptions ignored if drag already started
DragListener.prototype.startDrag = function (ev, extraOptions) {
    this.startInteraction(ev, extraOptions); // ensure interaction began
    if (!this.isDragging) {
        this.isDragging = true;
        this.handleDragStart(ev);
    }
};
DragListener.prototype.handleDragStart = function (ev) {
    this.trigger(&#39;dragStart&#39;, ev);
};
DragListener.prototype.handleMove = function (ev) {
    var dx = util_1.getEvX(ev) - this.originX;
    var dy = util_1.getEvY(ev) - this.originY;
    var minDistance = this.minDistance;
    var distanceSq; // current distance from the origin, squared
    if (!this.isDistanceSurpassed) {
        distanceSq = dx * dx + dy * dy;
        if (distanceSq &gt;= minDistance * minDistance) {
            this.handleDistanceSurpassed(ev);
        }
    }
    if (this.isDragging) {
        this.handleDrag(dx, dy, ev);
    }
};
// Called while the mouse is being moved and when we know a legitimate drag is taking place
DragListener.prototype.handleDrag = function (dx, dy, ev) {
    this.trigger(&#39;drag&#39;, dx, dy, ev);
    this.updateAutoScroll(ev); // will possibly cause scrolling
};
DragListener.prototype.endDrag = function (ev) {
    if (this.isDragging) {
        this.isDragging = false;
        this.handleDragEnd(ev);
    }
};
DragListener.prototype.handleDragEnd = function (ev) {
    this.trigger(&#39;dragEnd&#39;, ev);
};
// Delay
// -----------------------------------------------------------------------------------------------------------------
DragListener.prototype.startDelay = function (initialEv) {
    var _this = this;
    if (this.delay) {
        this.delayTimeoutId = setTimeout(function () {
            _this.handleDelayEnd(initialEv);
        }, this.delay);
    }
    else {
        this.handleDelayEnd(initialEv);
    }
};
DragListener.prototype.handleDelayEnd = function (initialEv) {
    this.isDelayEnded = true;
    if (this.isDistanceSurpassed) {
        this.startDrag(initialEv);
    }
};
// Distance
// -----------------------------------------------------------------------------------------------------------------
DragListener.prototype.handleDistanceSurpassed = function (ev) {
    this.isDistanceSurpassed = true;
    if (this.isDelayEnded) {
        this.startDrag(ev);
    }
};
// Mouse / Touch
// -----------------------------------------------------------------------------------------------------------------
DragListener.prototype.handleTouchMove = function (ev) {
    // prevent inertia and touchmove-scrolling while dragging
    if (this.isDragging &amp;&amp; this.shouldCancelTouchScroll) {
        ev.preventDefault();
    }
    this.handleMove(ev);
};
DragListener.prototype.handleMouseMove = function (ev) {
    this.handleMove(ev);
};
// Scrolling (unrelated to auto-scroll)
// -----------------------------------------------------------------------------------------------------------------
DragListener.prototype.handleTouchScroll = function (ev) {
    // if the drag is being initiated by touch, but a scroll happens before
    // the drag-initiating delay is over, cancel the drag
    if (!this.isDragging || this.scrollAlwaysKills) {
        this.endInteraction(ev, true); // isCancelled=true
    }
};
// Utils
// -----------------------------------------------------------------------------------------------------------------
// Triggers a callback. Calls a function in the option hash of the same name.
// Arguments beyond the first `name` are forwarded on.
DragListener.prototype.trigger = function (name) {
    var args = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    if (this.options[name]) {
        this.options[name].apply(this, args);
    }
    // makes _methods callable by event name. TODO: kill this
    if (this[&#39;_&#39; + name]) {
        this[&#39;_&#39; + name].apply(this, args);
    }
};
// Auto-scroll
// -----------------------------------------------------------------------------------------------------------------
DragListener.prototype.initAutoScroll = function () {
    var scrollEl = this.scrollEl;
    this.isAutoScroll =
        this.options.scroll &amp;&amp;
            scrollEl &amp;&amp;
            !scrollEl.is(window) &amp;&amp;
            !scrollEl.is(document);
    if (this.isAutoScroll) {
        // debounce makes sure rapid calls don&#39;t happen
        this.listenTo(scrollEl, &#39;scroll&#39;, util_1.debounce(this.handleDebouncedScroll, 100));
    }
};
DragListener.prototype.destroyAutoScroll = function () {
    this.endAutoScroll(); // kill any animation loop
    // remove the scroll handler if there is a scrollEl
    if (this.isAutoScroll) {
        this.stopListeningTo(this.scrollEl, &#39;scroll&#39;); // will probably get removed by unbindHandlers too :(
    }
};
// Computes and stores the bounding rectangle of scrollEl
DragListener.prototype.computeScrollBounds = function () {
    if (this.isAutoScroll) {
        this.scrollBounds = util_1.getOuterRect(this.scrollEl);
        // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
    }
};
// Called when the dragging is in progress and scrolling should be updated
DragListener.prototype.updateAutoScroll = function (ev) {
    var sensitivity = this.scrollSensitivity;
    var bounds = this.scrollBounds;
    var topCloseness;
    var bottomCloseness;
    var leftCloseness;
    var rightCloseness;
    var topVel = 0;
    var leftVel = 0;
    if (bounds) {
        // compute closeness to edges. valid range is from 0.0 - 1.0
        topCloseness = (sensitivity - (util_1.getEvY(ev) - bounds.top)) / sensitivity;
        bottomCloseness = (sensitivity - (bounds.bottom - util_1.getEvY(ev))) / sensitivity;
        leftCloseness = (sensitivity - (util_1.getEvX(ev) - bounds.left)) / sensitivity;
        rightCloseness = (sensitivity - (bounds.right - util_1.getEvX(ev))) / sensitivity;
        // translate vertical closeness into velocity.
        // mouse must be completely in bounds for velocity to happen.
        if (topCloseness &gt;= 0 &amp;&amp; topCloseness &lt;= 1) {
            topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
        }
        else if (bottomCloseness &gt;= 0 &amp;&amp; bottomCloseness &lt;= 1) {
            topVel = bottomCloseness * this.scrollSpeed;
        }
        // translate horizontal closeness into velocity
        if (leftCloseness &gt;= 0 &amp;&amp; leftCloseness &lt;= 1) {
            leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
        }
        else if (rightCloseness &gt;= 0 &amp;&amp; rightCloseness &lt;= 1) {
            leftVel = rightCloseness * this.scrollSpeed;
        }
    }
    this.setScrollVel(topVel, leftVel);
};
// Sets the speed-of-scrolling for the scrollEl
DragListener.prototype.setScrollVel = function (topVel, leftVel) {
    this.scrollTopVel = topVel;
    this.scrollLeftVel = leftVel;
    this.constrainScrollVel(); // massages into realistic values
    // if there is non-zero velocity, and an animation loop hasn&#39;t already started, then START
    if ((this.scrollTopVel || this.scrollLeftVel) &amp;&amp; !this.scrollIntervalId) {
        this.scrollIntervalId = setInterval(util_1.proxy(this, &#39;scrollIntervalFunc&#39;), // scope to `this`
        this.scrollIntervalMs);
    }
};
// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
DragListener.prototype.constrainScrollVel = function () {
    var el = this.scrollEl;
    if (this.scrollTopVel &lt; 0) {
        if (el.scrollTop() &lt;= 0) {
            this.scrollTopVel = 0;
        }
    }
    else if (this.scrollTopVel &gt; 0) {
        if (el.scrollTop() + el[0].clientHeight &gt;= el[0].scrollHeight) {
            this.scrollTopVel = 0;
        }
    }
    if (this.scrollLeftVel &lt; 0) {
        if (el.scrollLeft() &lt;= 0) {
            this.scrollLeftVel = 0;
        }
    }
    else if (this.scrollLeftVel &gt; 0) {
        if (el.scrollLeft() + el[0].clientWidth &gt;= el[0].scrollWidth) {
            this.scrollLeftVel = 0;
        }
    }
};
// This function gets called during every iteration of the scrolling animation loop
DragListener.prototype.scrollIntervalFunc = function () {
    var el = this.scrollEl;
    var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult&#39;d by
    // change the value of scrollEl&#39;s scroll
    if (this.scrollTopVel) {
        el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
    }
    if (this.scrollLeftVel) {
        el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
    }
    this.constrainScrollVel(); // since the scroll values changed, recompute the velocities
    // if scrolled all the way, which causes the vels to be zero, stop the animation loop
    if (!this.scrollTopVel &amp;&amp; !this.scrollLeftVel) {
        this.endAutoScroll();
    }
};
// Kills any existing scrolling animation loop
DragListener.prototype.endAutoScroll = function () {
    if (this.scrollIntervalId) {
        clearInterval(this.scrollIntervalId);
        this.scrollIntervalId = null;
        this.handleScrollEnd();
    }
};
// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
DragListener.prototype.handleDebouncedScroll = function () {
    // recompute all coordinates, but *only* if this is *not* part of our scrolling animation
    if (!this.scrollIntervalId) {
        this.handleScrollEnd();
    }
};
DragListener.prototype.handleScrollEnd = function () {
    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
};
return DragListener;</pre>

<p>}()); exports.default = DragListener;
ListenerMixin_1.default.mixInto(DragListener);</p>

<p>/***/ }), /* 55 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var util_1 = <em>webpack_require</em>(4);
var Mixin_1 = <em>webpack_require</em>(14); /* A set of rendering and
date-related methods for a visual component comprised of one or more rows
of day columns. Prerequisite: the object being mixed into needs to be a
<strong>Grid</strong></p>

<pre>/</pre>

<p>var DayTableMixin = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(DayTableMixin, _super);
function DayTableMixin() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
// Populates internal variables used for date calculation and rendering
DayTableMixin.prototype.updateDayTable = function () {
    var t = this;
    var view = t.view;
    var calendar = view.calendar;
    var date = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.startMs, true);
    var end = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.endMs, true);
    var dayIndex = -1;
    var dayIndices = [];
    var dayDates = [];
    var daysPerRow;
    var firstDay;
    var rowCnt;
    while (date.isBefore(end)) {
        if (view.isHiddenDay(date)) {
            dayIndices.push(dayIndex + 0.5); // mark that it&#39;s between indices
        }
        else {
            dayIndex++;
            dayIndices.push(dayIndex);
            dayDates.push(date.clone());
        }
        date.add(1, &#39;days&#39;);
    }
    if (this.breakOnWeeks) {
        // count columns until the day-of-week repeats
        firstDay = dayDates[0].day();
        for (daysPerRow = 1; daysPerRow &lt; dayDates.length; daysPerRow++) {
            if (dayDates[daysPerRow].day() === firstDay) {
                break;
            }
        }
        rowCnt = Math.ceil(dayDates.length / daysPerRow);
    }
    else {
        rowCnt = 1;
        daysPerRow = dayDates.length;
    }
    this.dayDates = dayDates;
    this.dayIndices = dayIndices;
    this.daysPerRow = daysPerRow;
    this.rowCnt = rowCnt;
    this.updateDayTableCols();
};
// Computes and assigned the colCnt property and updates any options that may be computed from it
DayTableMixin.prototype.updateDayTableCols = function () {
    this.colCnt = this.computeColCnt();
    this.colHeadFormat =
        this.opt(&#39;columnHeaderFormat&#39;) ||
            this.opt(&#39;columnFormat&#39;) || // deprecated
            this.computeColHeadFormat();
};
// Determines how many columns there should be in the table
DayTableMixin.prototype.computeColCnt = function () {
    return this.daysPerRow;
};
// Computes the ambiguously-timed moment for the given cell
DayTableMixin.prototype.getCellDate = function (row, col) {
    return this.dayDates[this.getCellDayIndex(row, col)].clone();
};
// Computes the ambiguously-timed date range for the given cell
DayTableMixin.prototype.getCellRange = function (row, col) {
    var start = this.getCellDate(row, col);
    var end = start.clone().add(1, &#39;days&#39;);
    return { start: start, end: end };
};
// Returns the number of day cells, chronologically, from the first of the grid (0-based)
DayTableMixin.prototype.getCellDayIndex = function (row, col) {
    return row * this.daysPerRow + this.getColDayIndex(col);
};
// Returns the numner of day cells, chronologically, from the first cell in *any given row*
DayTableMixin.prototype.getColDayIndex = function (col) {
    if (this.isRTL) {
        return this.colCnt - 1 - col;
    }
    else {
        return col;
    }
};
// Given a date, returns its chronolocial cell-index from the first cell of the grid.
// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
// If before the first offset, returns a negative number.
// If after the last offset, returns an offset past the last cell offset.
// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
DayTableMixin.prototype.getDateDayIndex = function (date) {
    var dayIndices = this.dayIndices;
    var dayOffset = date.diff(this.dayDates[0], &#39;days&#39;);
    if (dayOffset &lt; 0) {
        return dayIndices[0] - 1;
    }
    else if (dayOffset &gt;= dayIndices.length) {
        return dayIndices[dayIndices.length - 1] + 1;
    }
    else {
        return dayIndices[dayOffset];
    }
};
/* Options
------------------------------------------------------------------------------------------------------------------*/
// Computes a default column header formatting string if `colFormat` is not explicitly defined
DayTableMixin.prototype.computeColHeadFormat = function () {
    // if more than one week row, or if there are a lot of columns with not much space,
    // put just the day numbers will be in each cell
    if (this.rowCnt &gt; 1 || this.colCnt &gt; 10) {
        return &#39;ddd&#39;; // &quot;Sat&quot;
    }
    else if (this.colCnt &gt; 1) {
        return this.opt(&#39;dayOfMonthFormat&#39;); // &quot;Sat 12/10&quot;
    }
    else {
        return &#39;dddd&#39;; // &quot;Saturday&quot;
    }
};
/* Slicing
------------------------------------------------------------------------------------------------------------------*/
// Slices up a date range into a segment for every week-row it intersects with
DayTableMixin.prototype.sliceRangeByRow = function (unzonedRange) {
    var daysPerRow = this.daysPerRow;
    var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold
    var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
    var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, &#39;days&#39;)); // inclusive last index
    var segs = [];
    var row;
    var rowFirst;
    var rowLast; // inclusive day-index range for current row
    var segFirst;
    var segLast; // inclusive day-index range for segment
    for (row = 0; row &lt; this.rowCnt; row++) {
        rowFirst = row * daysPerRow;
        rowLast = rowFirst + daysPerRow - 1;
        // intersect segment&#39;s offset range with the row&#39;s
        segFirst = Math.max(rangeFirst, rowFirst);
        segLast = Math.min(rangeLast, rowLast);
        // deal with in-between indices
        segFirst = Math.ceil(segFirst); // in-between starts round to next cell
        segLast = Math.floor(segLast); // in-between ends round to prev cell
        if (segFirst &lt;= segLast) {
            segs.push({
                row: row,
                // normalize to start of row
                firstRowDayIndex: segFirst - rowFirst,
                lastRowDayIndex: segLast - rowFirst,
                // must be matching integers to be the segment&#39;s start/end
                isStart: segFirst === rangeFirst,
                isEnd: segLast === rangeLast
            });
        }
    }
    return segs;
};
// Slices up a date range into a segment for every day-cell it intersects with.
// TODO: make more DRY with sliceRangeByRow somehow.
DayTableMixin.prototype.sliceRangeByDay = function (unzonedRange) {
    var daysPerRow = this.daysPerRow;
    var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold
    var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
    var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, &#39;days&#39;)); // inclusive last index
    var segs = [];
    var row;
    var rowFirst;
    var rowLast; // inclusive day-index range for current row
    var i;
    var segFirst;
    var segLast; // inclusive day-index range for segment
    for (row = 0; row &lt; this.rowCnt; row++) {
        rowFirst = row * daysPerRow;
        rowLast = rowFirst + daysPerRow - 1;
        for (i = rowFirst; i &lt;= rowLast; i++) {
            // intersect segment&#39;s offset range with the row&#39;s
            segFirst = Math.max(rangeFirst, i);
            segLast = Math.min(rangeLast, i);
            // deal with in-between indices
            segFirst = Math.ceil(segFirst); // in-between starts round to next cell
            segLast = Math.floor(segLast); // in-between ends round to prev cell
            if (segFirst &lt;= segLast) {
                segs.push({
                    row: row,
                    // normalize to start of row
                    firstRowDayIndex: segFirst - rowFirst,
                    lastRowDayIndex: segLast - rowFirst,
                    // must be matching integers to be the segment&#39;s start/end
                    isStart: segFirst === rangeFirst,
                    isEnd: segLast === rangeLast
                });
            }
        }
    }
    return segs;
};
/* Header Rendering
------------------------------------------------------------------------------------------------------------------*/
DayTableMixin.prototype.renderHeadHtml = function () {
    var theme = this.view.calendar.theme;
    return &#39;&#39; +
        &#39;&lt;div class=&quot;fc-row &#39; + theme.getClass(&#39;headerRow&#39;) + &#39;&quot;&gt;&#39; +
        &#39;&lt;table class=&quot;&#39; + theme.getClass(&#39;tableGrid&#39;) + &#39;&quot;&gt;&#39; +
        &#39;&lt;thead&gt;&#39; +
        this.renderHeadTrHtml() +
        &#39;&lt;/thead&gt;&#39; +
        &#39;&lt;/table&gt;&#39; +
        &#39;&lt;/div&gt;&#39;;
};
DayTableMixin.prototype.renderHeadIntroHtml = function () {
    return this.renderIntroHtml(); // fall back to generic
};
DayTableMixin.prototype.renderHeadTrHtml = function () {
    return &#39;&#39; +
        &#39;&lt;tr&gt;&#39; +
        (this.isRTL ? &#39;&#39; : this.renderHeadIntroHtml()) +
        this.renderHeadDateCellsHtml() +
        (this.isRTL ? this.renderHeadIntroHtml() : &#39;&#39;) +
        &#39;&lt;/tr&gt;&#39;;
};
DayTableMixin.prototype.renderHeadDateCellsHtml = function () {
    var htmls = [];
    var col;
    var date;
    for (col = 0; col &lt; this.colCnt; col++) {
        date = this.getCellDate(0, col);
        htmls.push(this.renderHeadDateCellHtml(date));
    }
    return htmls.join(&#39;&#39;);
};
// TODO: when internalApiVersion, accept an object for HTML attributes
// (colspan should be no different)
DayTableMixin.prototype.renderHeadDateCellHtml = function (date, colspan, otherAttrs) {
    var t = this;
    var view = t.view;
    var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
    var classNames = [
        &#39;fc-day-header&#39;,
        view.calendar.theme.getClass(&#39;widgetHeader&#39;)
    ];
    var innerHtml;
    if (typeof t.opt(&#39;columnHeaderHtml&#39;) === &#39;function&#39;) {
        innerHtml = t.opt(&#39;columnHeaderHtml&#39;)(date);
    }
    else if (typeof t.opt(&#39;columnHeaderText&#39;) === &#39;function&#39;) {
        innerHtml = util_1.htmlEscape(t.opt(&#39;columnHeaderText&#39;)(date));
    }
    else {
        innerHtml = util_1.htmlEscape(date.format(t.colHeadFormat));
    }
    // if only one row of days, the classNames on the header can represent the specific days beneath
    if (t.rowCnt === 1) {
        classNames = classNames.concat(
        // includes the day-of-week class
        // noThemeHighlight=true (don&#39;t highlight the header)
        t.getDayClasses(date, true));
    }
    else {
        classNames.push(&#39;fc-&#39; + util_1.dayIDs[date.day()]); // only add the day-of-week class
    }
    return &#39;&#39; +
        &#39;&lt;th class=&quot;&#39; + classNames.join(&#39; &#39;) + &#39;&quot;&#39; +
        ((isDateValid &amp;&amp; t.rowCnt) === 1 ?
            &#39; data-date=&quot;&#39; + date.format(&#39;YYYY-MM-DD&#39;) + &#39;&quot;&#39; :
            &#39;&#39;) +
        (colspan &gt; 1 ?
            &#39; colspan=&quot;&#39; + colspan + &#39;&quot;&#39; :
            &#39;&#39;) +
        (otherAttrs ?
            &#39; &#39; + otherAttrs :
            &#39;&#39;) +
        &#39;&gt;&#39; +
        (isDateValid ?
            // don&#39;t make a link if the heading could represent multiple days, or if there&#39;s only one day (forceOff)
            view.buildGotoAnchorHtml({ date: date, forceOff: t.rowCnt &gt; 1 || t.colCnt === 1 }, innerHtml) :
            // if not valid, display text, but no link
            innerHtml) +
        &#39;&lt;/th&gt;&#39;;
};
/* Background Rendering
------------------------------------------------------------------------------------------------------------------*/
DayTableMixin.prototype.renderBgTrHtml = function (row) {
    return &#39;&#39; +
        &#39;&lt;tr&gt;&#39; +
        (this.isRTL ? &#39;&#39; : this.renderBgIntroHtml(row)) +
        this.renderBgCellsHtml(row) +
        (this.isRTL ? this.renderBgIntroHtml(row) : &#39;&#39;) +
        &#39;&lt;/tr&gt;&#39;;
};
DayTableMixin.prototype.renderBgIntroHtml = function (row) {
    return this.renderIntroHtml(); // fall back to generic
};
DayTableMixin.prototype.renderBgCellsHtml = function (row) {
    var htmls = [];
    var col;
    var date;
    for (col = 0; col &lt; this.colCnt; col++) {
        date = this.getCellDate(row, col);
        htmls.push(this.renderBgCellHtml(date));
    }
    return htmls.join(&#39;&#39;);
};
DayTableMixin.prototype.renderBgCellHtml = function (date, otherAttrs) {
    var t = this;
    var view = t.view;
    var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
    var classes = t.getDayClasses(date);
    classes.unshift(&#39;fc-day&#39;, view.calendar.theme.getClass(&#39;widgetContent&#39;));
    return &#39;&lt;td class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&#39; +
        (isDateValid ?
            &#39; data-date=&quot;&#39; + date.format(&#39;YYYY-MM-DD&#39;) + &#39;&quot;&#39; : // if date has a time, won&#39;t format it
            &#39;&#39;) +
        (otherAttrs ?
            &#39; &#39; + otherAttrs :
            &#39;&#39;) +
        &#39;&gt;&lt;/td&gt;&#39;;
};
/* Generic
------------------------------------------------------------------------------------------------------------------*/
DayTableMixin.prototype.renderIntroHtml = function () {
    // Generates the default HTML intro for any row. User classes should override
};
// TODO: a generic method for dealing with &lt;tr&gt;, RTL, intro
// when increment internalApiVersion
// wrapTr (scheduler)
/* Utils
------------------------------------------------------------------------------------------------------------------*/
// Applies the generic &quot;intro&quot; and &quot;outro&quot; HTML to the given cells.
// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
DayTableMixin.prototype.bookendCells = function (trEl) {
    var introHtml = this.renderIntroHtml();
    if (introHtml) {
        if (this.isRTL) {
            trEl.append(introHtml);
        }
        else {
            trEl.prepend(introHtml);
        }
    }
};
return DayTableMixin;</pre>

<p>}(Mixin_1.default)); exports.default = DayTableMixin;</p>

<p>/***/ }), /* 56 */ /***/ (function(module, exports) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
BusinessHourRenderer = /** @class */ (function () {</p>

<pre>/*
component implements:
  - eventRangesToEventFootprints
  - eventFootprintsToSegs
 /
function BusinessHourRenderer(component, fillRenderer) {
    this.component = component;
    this.fillRenderer = fillRenderer;
}
BusinessHourRenderer.prototype.render = function (businessHourGenerator) {
    var component = this.component;
    var unzonedRange = component._getDateProfile().activeUnzonedRange;
    var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(component.hasAllDayBusinessHours, unzonedRange);
    var eventFootprints = eventInstanceGroup ?
        component.eventRangesToEventFootprints(eventInstanceGroup.sliceRenderRanges(unzonedRange)) :
        [];
    this.renderEventFootprints(eventFootprints);
};
BusinessHourRenderer.prototype.renderEventFootprints = function (eventFootprints) {
    var segs = this.component.eventFootprintsToSegs(eventFootprints);
    this.renderSegs(segs);
    this.segs = segs;
};
BusinessHourRenderer.prototype.renderSegs = function (segs) {
    if (this.fillRenderer) {
        this.fillRenderer.renderSegs(&#39;businessHours&#39;, segs, {
            getClasses: function (seg) {
                return [&#39;fc-nonbusiness&#39;, &#39;fc-bgevent&#39;];
            }
        });
    }
};
BusinessHourRenderer.prototype.unrender = function () {
    if (this.fillRenderer) {
        this.fillRenderer.unrender(&#39;businessHours&#39;);
    }
    this.segs = null;
};
BusinessHourRenderer.prototype.getSegs = function () {
    return this.segs || [];
};
return BusinessHourRenderer;</pre>

<p>}()); exports.default = BusinessHourRenderer;</p>

<p>/***/ }), /* 57 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var util_1 = <em>webpack_require</em>(4); var
FillRenderer = /** @class */ (function () {</p>

<pre>function FillRenderer(component) {
    this.fillSegTag = &#39;div&#39;;
    this.component = component;
    this.elsByFill = {};
}
FillRenderer.prototype.renderFootprint = function (type, componentFootprint, props) {
    this.renderSegs(type, this.component.componentFootprintToSegs(componentFootprint), props);
};
FillRenderer.prototype.renderSegs = function (type, segs, props) {
    var els;
    segs = this.buildSegEls(type, segs, props); // assignes `.el` to each seg. returns successfully rendered segs
    els = this.attachSegEls(type, segs);
    if (els) {
        this.reportEls(type, els);
    }
    return segs;
};
// Unrenders a specific type of fill that is currently rendered on the grid
FillRenderer.prototype.unrender = function (type) {
    var el = this.elsByFill[type];
    if (el) {
        el.remove();
        delete this.elsByFill[type];
    }
};
// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
// Only returns segments that successfully rendered.
FillRenderer.prototype.buildSegEls = function (type, segs, props) {
    var _this = this;
    var html = &#39;&#39;;
    var renderedSegs = [];
    var i;
    if (segs.length) {
        // build a large concatenation of segment HTML
        for (i = 0; i &lt; segs.length; i++) {
            html += this.buildSegHtml(type, segs[i], props);
        }
        // Grab individual elements from the combined HTML string. Use each as the default rendering.
        // Then, compute the &#39;el&#39; for each segment.
        $(html).each(function (i, node) {
            var seg = segs[i];
            var el = $(node);
            // allow custom filter methods per-type
            if (props.filterEl) {
                el = props.filterEl(seg, el);
            }
            if (el) {
                el = $(el); // allow custom filter to return raw DOM node
                // correct element type? (would be bad if a non-TD were inserted into a table for example)
                if (el.is(_this.fillSegTag)) {
                    seg.el = el;
                    renderedSegs.push(seg);
                }
            }
        });
    }
    return renderedSegs;
};
// Builds the HTML needed for one fill segment. Generic enough to work with different types.
FillRenderer.prototype.buildSegHtml = function (type, seg, props) {
    // custom hooks per-type
    var classes = props.getClasses ? props.getClasses(seg) : [];
    var css = util_1.cssToStr(props.getCss ? props.getCss(seg) : {});
    return &#39;&lt;&#39; + this.fillSegTag +
        (classes.length ? &#39; class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&#39; : &#39;&#39;) +
        (css ? &#39; style=&quot;&#39; + css + &#39;&quot;&#39; : &#39;&#39;) +
        &#39; /&gt;&#39;;
};
// Should return wrapping DOM structure
FillRenderer.prototype.attachSegEls = function (type, segs) {
    // subclasses must implement
};
FillRenderer.prototype.reportEls = function (type, nodes) {
    if (this.elsByFill[type]) {
        this.elsByFill[type] = this.elsByFill[type].add(nodes);
    }
    else {
        this.elsByFill[type] = $(nodes);
    }
};
return FillRenderer;</pre>

<p>}()); exports.default = FillRenderer;</p>

<p>/***/ }), /* 58 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
SingleEventDef_1 = <em>webpack_require</em>(13); var EventFootprint_1 =
<em>webpack_require</em>(36); var EventSource_1 =
<em>webpack_require</em>(6); var HelperRenderer = /** @class */ (function
() {</p>

<pre>function HelperRenderer(component, eventRenderer) {
    this.view = component._getView();
    this.component = component;
    this.eventRenderer = eventRenderer;
}
HelperRenderer.prototype.renderComponentFootprint = function (componentFootprint) {
    this.renderEventFootprints([
        this.fabricateEventFootprint(componentFootprint)
    ]);
};
HelperRenderer.prototype.renderEventDraggingFootprints = function (eventFootprints, sourceSeg, isTouch) {
    this.renderEventFootprints(eventFootprints, sourceSeg, &#39;fc-dragging&#39;, isTouch ? null : this.view.opt(&#39;dragOpacity&#39;));
};
HelperRenderer.prototype.renderEventResizingFootprints = function (eventFootprints, sourceSeg, isTouch) {
    this.renderEventFootprints(eventFootprints, sourceSeg, &#39;fc-resizing&#39;);
};
HelperRenderer.prototype.renderEventFootprints = function (eventFootprints, sourceSeg, extraClassNames, opacity) {
    var segs = this.component.eventFootprintsToSegs(eventFootprints);
    var classNames = &#39;fc-helper &#39; + (extraClassNames || &#39;&#39;);
    var i;
    // assigns each seg&#39;s el and returns a subset of segs that were rendered
    segs = this.eventRenderer.renderFgSegEls(segs);
    for (i = 0; i &lt; segs.length; i++) {
        segs[i].el.addClass(classNames);
    }
    if (opacity != null) {
        for (i = 0; i &lt; segs.length; i++) {
            segs[i].el.css(&#39;opacity&#39;, opacity);
        }
    }
    this.helperEls = this.renderSegs(segs, sourceSeg);
};
/*
Must return all mock event elements
 /
HelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
    // Subclasses must implement
};
HelperRenderer.prototype.unrender = function () {
    if (this.helperEls) {
        this.helperEls.remove();
        this.helperEls = null;
    }
};
HelperRenderer.prototype.fabricateEventFootprint = function (componentFootprint) {
    var calendar = this.view.calendar;
    var eventDateProfile = calendar.footprintToDateProfile(componentFootprint);
    var dummyEvent = new SingleEventDef_1.default(new EventSource_1.default(calendar));
    var dummyInstance;
    dummyEvent.dateProfile = eventDateProfile;
    dummyInstance = dummyEvent.buildInstance();
    return new EventFootprint_1.default(componentFootprint, dummyEvent, dummyInstance);
};
return HelperRenderer;</pre>

<p>}()); exports.default = HelperRenderer;</p>

<p>/***/ }), /* 59 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var GlobalEmitter_1 =
<em>webpack_require</em>(21); var Interaction_1 =
<em>webpack_require</em>(15); var EventPointing = /** @class */ (function
(_super) {</p>

<pre>tslib_1.__extends(EventPointing, _super);
function EventPointing() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
/*
component must implement:
  - publiclyTrigger
 /
EventPointing.prototype.bindToEl = function (el) {
    var component = this.component;
    component.bindSegHandlerToEl(el, &#39;click&#39;, this.handleClick.bind(this));
    component.bindSegHandlerToEl(el, &#39;mouseenter&#39;, this.handleMouseover.bind(this));
    component.bindSegHandlerToEl(el, &#39;mouseleave&#39;, this.handleMouseout.bind(this));
};
EventPointing.prototype.handleClick = function (seg, ev) {
    var res = this.component.publiclyTrigger(&#39;eventClick&#39;, {
        context: seg.el[0],
        args: [seg.footprint.getEventLegacy(), ev, this.view]
    });
    if (res === false) {
        ev.preventDefault();
    }
};
// Updates internal state and triggers handlers for when an event element is moused over
EventPointing.prototype.handleMouseover = function (seg, ev) {
    if (!GlobalEmitter_1.default.get().shouldIgnoreMouse() &amp;&amp;
        !this.mousedOverSeg) {
        this.mousedOverSeg = seg;
        // TODO: move to EventSelecting&#39;s responsibility
        if (this.view.isEventDefResizable(seg.footprint.eventDef)) {
            seg.el.addClass(&#39;fc-allow-mouse-resize&#39;);
        }
        this.component.publiclyTrigger(&#39;eventMouseover&#39;, {
            context: seg.el[0],
            args: [seg.footprint.getEventLegacy(), ev, this.view]
        });
    }
};
// Updates internal state and triggers handlers for when an event element is moused out.
// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
EventPointing.prototype.handleMouseout = function (seg, ev) {
    if (this.mousedOverSeg) {
        this.mousedOverSeg = null;
        // TODO: move to EventSelecting&#39;s responsibility
        if (this.view.isEventDefResizable(seg.footprint.eventDef)) {
            seg.el.removeClass(&#39;fc-allow-mouse-resize&#39;);
        }
        this.component.publiclyTrigger(&#39;eventMouseout&#39;, {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev || {},
                this.view
            ]
        });
    }
};
EventPointing.prototype.end = function () {
    if (this.mousedOverSeg) {
        this.handleMouseout(this.mousedOverSeg);
    }
};
return EventPointing;</pre>

<p>}(Interaction_1.default)); exports.default = EventPointing;</p>

<p>/***/ }), /* 60 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var Mixin_1 = <em>webpack_require</em>(14);
var DateClicking_1 = <em>webpack_require</em>(245); var DateSelecting_1 =
<em>webpack_require</em>(225); var EventPointing_1 =
<em>webpack_require</em>(59); var EventDragging_1 =
<em>webpack_require</em>(224); var EventResizing_1 =
<em>webpack_require</em>(223); var ExternalDropping_1 =
<em>webpack_require</em>(222); var StandardInteractionsMixin = /** @class
*/ (function (_super) {</p>

<pre>tslib_1.__extends(StandardInteractionsMixin, _super);
function StandardInteractionsMixin() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
return StandardInteractionsMixin;</pre>

<p>}(Mixin_1.default)); exports.default = StandardInteractionsMixin;
StandardInteractionsMixin.prototype.dateClickingClass =
DateClicking_1.default;
StandardInteractionsMixin.prototype.dateSelectingClass =
DateSelecting_1.default;
StandardInteractionsMixin.prototype.eventPointingClass =
EventPointing_1.default;
StandardInteractionsMixin.prototype.eventDraggingClass =
EventDragging_1.default;
StandardInteractionsMixin.prototype.eventResizingClass =
EventResizing_1.default;
StandardInteractionsMixin.prototype.externalDroppingClass =
ExternalDropping_1.default;</p>

<p>/***/ }), /* 61 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var CoordCache_1 =
<em>webpack_require</em>(53); var Popover_1 =
<em>webpack_require</em>(249); var UnzonedRange_1 =
<em>webpack_require</em>(5); var ComponentFootprint_1 =
<em>webpack_require</em>(12); var EventFootprint_1 =
<em>webpack_require</em>(36); var BusinessHourRenderer_1 =
<em>webpack_require</em>(56); var StandardInteractionsMixin_1 =
<em>webpack_require</em>(60); var InteractiveDateComponent_1 =
<em>webpack_require</em>(40); var DayTableMixin_1 =
<em>webpack_require</em>(55); var DayGridEventRenderer_1 =
<em>webpack_require</em>(250); var DayGridHelperRenderer_1 =
<em>webpack_require</em>(251); var DayGridFillRenderer_1 =
<em>webpack_require</em>(252); /* A component that renders a grid of
whole-days that runs horizontally. There can be multiple rows, one per
week. ———————————————————————————————————————-*/ var DayGrid = /** @class
*/ (function (_super) {</p>

<pre>tslib_1.__extends(DayGrid, _super);
function DayGrid(view) {
    var _this = _super.call(this, view) || this;
    _this.cellWeekNumbersVisible = false; // display week numbers in day cell?
    _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid
    // isRigid determines whether the individual rows should ignore the contents and be a constant height.
    // Relies on the view&#39;s colCnt and rowCnt. In the future, this component should probably be self-sufficient.
    _this.isRigid = false;
    _this.hasAllDayBusinessHours = true;
    return _this;
}
// Slices up the given span (unzoned start/end with other misc data) into an array of segments
DayGrid.prototype.componentFootprintToSegs = function (componentFootprint) {
    var segs = this.sliceRangeByRow(componentFootprint.unzonedRange);
    var i;
    var seg;
    for (i = 0; i &lt; segs.length; i++) {
        seg = segs[i];
        if (this.isRTL) {
            seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
            seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
        }
        else {
            seg.leftCol = seg.firstRowDayIndex;
            seg.rightCol = seg.lastRowDayIndex;
        }
    }
    return segs;
};
/* Date Rendering
------------------------------------------------------------------------------------------------------------------*/
DayGrid.prototype.renderDates = function (dateProfile) {
    this.dateProfile = dateProfile;
    this.updateDayTable();
    this.renderGrid();
};
DayGrid.prototype.unrenderDates = function () {
    this.removeSegPopover();
};
// Renders the rows and columns into the component&#39;s `this.el`, which should already be assigned.
DayGrid.prototype.renderGrid = function () {
    var view = this.view;
    var rowCnt = this.rowCnt;
    var colCnt = this.colCnt;
    var html = &#39;&#39;;
    var row;
    var col;
    if (this.headContainerEl) {
        this.headContainerEl.html(this.renderHeadHtml());
    }
    for (row = 0; row &lt; rowCnt; row++) {
        html += this.renderDayRowHtml(row, this.isRigid);
    }
    this.el.html(html);
    this.rowEls = this.el.find(&#39;.fc-row&#39;);
    this.cellEls = this.el.find(&#39;.fc-day, .fc-disabled-day&#39;);
    this.rowCoordCache = new CoordCache_1.default({
        els: this.rowEls,
        isVertical: true
    });
    this.colCoordCache = new CoordCache_1.default({
        els: this.cellEls.slice(0, this.colCnt),
        isHorizontal: true
    });
    // trigger dayRender with each cell&#39;s element
    for (row = 0; row &lt; rowCnt; row++) {
        for (col = 0; col &lt; colCnt; col++) {
            this.publiclyTrigger(&#39;dayRender&#39;, {
                context: view,
                args: [
                    this.getCellDate(row, col),
                    this.getCellEl(row, col),
                    view
                ]
            });
        }
    }
};
// Generates the HTML for a single row, which is a div that wraps a table.
// `row` is the row number.
DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {
    var theme = this.view.calendar.theme;
    var classes = [&#39;fc-row&#39;, &#39;fc-week&#39;, theme.getClass(&#39;dayRow&#39;)];
    if (isRigid) {
        classes.push(&#39;fc-rigid&#39;);
    }
    return &#39;&#39; +
        &#39;&lt;div class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&gt;&#39; +
        &#39;&lt;div class=&quot;fc-bg&quot;&gt;&#39; +
        &#39;&lt;table class=&quot;&#39; + theme.getClass(&#39;tableGrid&#39;) + &#39;&quot;&gt;&#39; +
        this.renderBgTrHtml(row) +
        &#39;&lt;/table&gt;&#39; +
        &#39;&lt;/div&gt;&#39; +
        &#39;&lt;div class=&quot;fc-content-skeleton&quot;&gt;&#39; +
        &#39;&lt;table&gt;&#39; +
        (this.getIsNumbersVisible() ?
            &#39;&lt;thead&gt;&#39; +
                this.renderNumberTrHtml(row) +
                &#39;&lt;/thead&gt;&#39; :
            &#39;&#39;) +
        &#39;&lt;/table&gt;&#39; +
        &#39;&lt;/div&gt;&#39; +
        &#39;&lt;/div&gt;&#39;;
};
DayGrid.prototype.getIsNumbersVisible = function () {
    return this.getIsDayNumbersVisible() || this.cellWeekNumbersVisible;
};
DayGrid.prototype.getIsDayNumbersVisible = function () {
    return this.rowCnt &gt; 1;
};
/* Grid Number Rendering
------------------------------------------------------------------------------------------------------------------*/
DayGrid.prototype.renderNumberTrHtml = function (row) {
    return &#39;&#39; +
        &#39;&lt;tr&gt;&#39; +
        (this.isRTL ? &#39;&#39; : this.renderNumberIntroHtml(row)) +
        this.renderNumberCellsHtml(row) +
        (this.isRTL ? this.renderNumberIntroHtml(row) : &#39;&#39;) +
        &#39;&lt;/tr&gt;&#39;;
};
DayGrid.prototype.renderNumberIntroHtml = function (row) {
    return this.renderIntroHtml();
};
DayGrid.prototype.renderNumberCellsHtml = function (row) {
    var htmls = [];
    var col;
    var date;
    for (col = 0; col &lt; this.colCnt; col++) {
        date = this.getCellDate(row, col);
        htmls.push(this.renderNumberCellHtml(date));
    }
    return htmls.join(&#39;&#39;);
};
// Generates the HTML for the &lt;td&gt;s of the &quot;number&quot; row in the DayGrid&#39;s content skeleton.
// The number row will only exist if either day numbers or week numbers are turned on.
DayGrid.prototype.renderNumberCellHtml = function (date) {
    var view = this.view;
    var html = &#39;&#39;;
    var isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
    var isDayNumberVisible = this.getIsDayNumbersVisible() &amp;&amp; isDateValid;
    var classes;
    var weekCalcFirstDoW;
    if (!isDayNumberVisible &amp;&amp; !this.cellWeekNumbersVisible) {
        // no numbers in day cell (week number must be along the side)
        return &#39;&lt;td/&gt;&#39;; //  will create an empty space above events :(
    }
    classes = this.getDayClasses(date);
    classes.unshift(&#39;fc-day-top&#39;);
    if (this.cellWeekNumbersVisible) {
        // To determine the day of week number change under ISO, we cannot
        // rely on moment.js methods such as firstDayOfWeek() or weekday(),
        // because they rely on the locale&#39;s dow (possibly overridden by
        // our firstDay option), which may not be Monday. We cannot change
        // dow, because that would affect the calendar start day as well.
        if (date._locale._fullCalendar_weekCalc === &#39;ISO&#39;) {
            weekCalcFirstDoW = 1; // Monday by ISO 8601 definition
        }
        else {
            weekCalcFirstDoW = date._locale.firstDayOfWeek();
        }
    }
    html += &#39;&lt;td class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&#39; +
        (isDateValid ?
            &#39; data-date=&quot;&#39; + date.format() + &#39;&quot;&#39; :
            &#39;&#39;) +
        &#39;&gt;&#39;;
    if (this.cellWeekNumbersVisible &amp;&amp; (date.day() === weekCalcFirstDoW)) {
        html += view.buildGotoAnchorHtml({ date: date, type: &#39;week&#39; }, { &#39;class&#39;: &#39;fc-week-number&#39; }, date.format(&#39;w&#39;) // inner HTML
        );
    }
    if (isDayNumberVisible) {
        html += view.buildGotoAnchorHtml(date, { &#39;class&#39;: &#39;fc-day-number&#39; }, date.format(&#39;D&#39;) // inner HTML
        );
    }
    html += &#39;&lt;/td&gt;&#39;;
    return html;
};
/* Hit System
------------------------------------------------------------------------------------------------------------------*/
DayGrid.prototype.prepareHits = function () {
    this.colCoordCache.build();
    this.rowCoordCache.build();
    this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
};
DayGrid.prototype.releaseHits = function () {
    this.colCoordCache.clear();
    this.rowCoordCache.clear();
};
DayGrid.prototype.queryHit = function (leftOffset, topOffset) {
    if (this.colCoordCache.isLeftInBounds(leftOffset) &amp;&amp; this.rowCoordCache.isTopInBounds(topOffset)) {
        var col = this.colCoordCache.getHorizontalIndex(leftOffset);
        var row = this.rowCoordCache.getVerticalIndex(topOffset);
        if (row != null &amp;&amp; col != null) {
            return this.getCellHit(row, col);
        }
    }
};
DayGrid.prototype.getHitFootprint = function (hit) {
    var range = this.getCellRange(hit.row, hit.col);
    return new ComponentFootprint_1.default(new UnzonedRange_1.default(range.start, range.end), true // all-day?
    );
};
DayGrid.prototype.getHitEl = function (hit) {
    return this.getCellEl(hit.row, hit.col);
};
/* Cell System
------------------------------------------------------------------------------------------------------------------*/
// FYI: the first column is the leftmost column, regardless of date
DayGrid.prototype.getCellHit = function (row, col) {
    return {
        row: row,
        col: col,
        component: this,
        left: this.colCoordCache.getLeftOffset(col),
        right: this.colCoordCache.getRightOffset(col),
        top: this.rowCoordCache.getTopOffset(row),
        bottom: this.rowCoordCache.getBottomOffset(row)
    };
};
DayGrid.prototype.getCellEl = function (row, col) {
    return this.cellEls.eq(row * this.colCnt + col);
};
/* Event Rendering
------------------------------------------------------------------------------------------------------------------*/
// Unrenders all events currently rendered on the grid
DayGrid.prototype.executeEventUnrender = function () {
    this.removeSegPopover(); // removes the &quot;more..&quot; events popover
    _super.prototype.executeEventUnrender.call(this);
};
// Retrieves all rendered segment objects currently rendered on the grid
DayGrid.prototype.getOwnEventSegs = function () {
    // append the segments from the &quot;more...&quot; popover
    return _super.prototype.getOwnEventSegs.call(this).concat(this.popoverSegs || []);
};
/* Event Drag Visualization
------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event or external element being dragged.
// `eventLocation` has zoned start and end (optional)
DayGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
    var i;
    for (i = 0; i &lt; eventFootprints.length; i++) {
        this.renderHighlight(eventFootprints[i].componentFootprint);
    }
    // render drags from OTHER components as helpers
    if (eventFootprints.length &amp;&amp; seg &amp;&amp; seg.component !== this) {
        this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);
        return true; // signal helpers rendered
    }
};
// Unrenders any visual indication of a hovering event
DayGrid.prototype.unrenderDrag = function () {
    this.unrenderHighlight();
    this.helperRenderer.unrender();
};
/* Event Resize Visualization
------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event being resized
DayGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
    var i;
    for (i = 0; i &lt; eventFootprints.length; i++) {
        this.renderHighlight(eventFootprints[i].componentFootprint);
    }
    this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);
};
// Unrenders a visual indication of an event being resized
DayGrid.prototype.unrenderEventResize = function () {
    this.unrenderHighlight();
    this.helperRenderer.unrender();
};
/* More+ Link Popover
------------------------------------------------------------------------------------------------------------------*/
DayGrid.prototype.removeSegPopover = function () {
    if (this.segPopover) {
        this.segPopover.hide(); // in handler, will call segPopover&#39;s removeElement
    }
};
// Limits the number of &quot;levels&quot; (vertically stacking layers of events) for each row of the grid.
// `levelLimit` can be false (don&#39;t limit), a number, or true (should be computed).
DayGrid.prototype.limitRows = function (levelLimit) {
    var rowStructs = this.eventRenderer.rowStructs || [];
    var row; // row #
    var rowLevelLimit;
    for (row = 0; row &lt; rowStructs.length; row++) {
        this.unlimitRow(row);
        if (!levelLimit) {
            rowLevelLimit = false;
        }
        else if (typeof levelLimit === &#39;number&#39;) {
            rowLevelLimit = levelLimit;
        }
        else {
            rowLevelLimit = this.computeRowLevelLimit(row);
        }
        if (rowLevelLimit !== false) {
            this.limitRow(row, rowLevelLimit);
        }
    }
};
// Computes the number of levels a row will accomodate without going outside its bounds.
// Assumes the row is &quot;rigid&quot; (maintains a constant height regardless of what is inside).
// `row` is the row number.
DayGrid.prototype.computeRowLevelLimit = function (row) {
    var rowEl = this.rowEls.eq(row); // the containing &quot;fake&quot; row div
    var rowHeight = rowEl.height(); // TODO: cache somehow?
    var trEls = this.eventRenderer.rowStructs[row].tbodyEl.children();
    var i;
    var trEl;
    var trHeight;
    function iterInnerHeights(i, childNode) {
        trHeight = Math.max(trHeight, $(childNode).outerHeight());
    }
    // Reveal one level &lt;tr&gt; at a time and stop when we find one out of bounds
    for (i = 0; i &lt; trEls.length; i++) {
        trEl = trEls.eq(i).removeClass(&#39;fc-limited&#39;); // reset to original state (reveal)
        // with rowspans&gt;1 and IE8, trEl.outerHeight() would return the height of the largest cell,
        // so instead, find the tallest inner content element.
        trHeight = 0;
        trEl.find(&#39;&gt; td &gt; :first-child&#39;).each(iterInnerHeights);
        if (trEl.position().top + trHeight &gt; rowHeight) {
            return i;
        }
    }
    return false; // should not limit at all
};
// Limits the given grid row to the maximum number of levels and injects &quot;more&quot; links if necessary.
// `row` is the row number.
// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
DayGrid.prototype.limitRow = function (row, levelLimit) {
    var _this = this;
    var rowStruct = this.eventRenderer.rowStructs[row];
    var moreNodes = []; // array of &quot;more&quot; &lt;a&gt; links and &lt;td&gt; DOM nodes
    var col = 0; // col #, left-to-right (not chronologically)
    var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
    var cellMatrix; // a matrix (by level, then column) of all &lt;td&gt; jQuery elements in the row
    var limitedNodes; // array of temporarily hidden level &lt;tr&gt; and segment &lt;td&gt; DOM nodes
    var i;
    var seg;
    var segsBelow; // array of segment objects below `seg` in the current `col`
    var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
    var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs&#39;s first column)
    var td;
    var rowspan;
    var segMoreNodes; // array of &quot;more&quot; &lt;td&gt; cells that will stand-in for the current seg&#39;s cell
    var j;
    var moreTd;
    var moreWrap;
    var moreLink;
    // Iterates through empty level cells and places &quot;more&quot; links inside if need be
    var emptyCellsUntil = function (endCol) {
        while (col &lt; endCol) {
            segsBelow = _this.getCellSegs(row, col, levelLimit);
            if (segsBelow.length) {
                td = cellMatrix[levelLimit - 1][col];
                moreLink = _this.renderMoreLink(row, col, segsBelow);
                moreWrap = $(&#39;&lt;div/&gt;&#39;).append(moreLink);
                td.append(moreWrap);
                moreNodes.push(moreWrap[0]);
            }
            col++;
        }
    };
    if (levelLimit &amp;&amp; levelLimit &lt; rowStruct.segLevels.length) {
        levelSegs = rowStruct.segLevels[levelLimit - 1];
        cellMatrix = rowStruct.cellMatrix;
        limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level &lt;tr&gt; elements past the limit
            .addClass(&#39;fc-limited&#39;).get(); // hide elements and get a simple DOM-nodes array
        // iterate though segments in the last allowable level
        for (i = 0; i &lt; levelSegs.length; i++) {
            seg = levelSegs[i];
            emptyCellsUntil(seg.leftCol); // process empty cells before the segment
            // determine *all* segments below `seg` that occupy the same columns
            colSegsBelow = [];
            totalSegsBelow = 0;
            while (col &lt;= seg.rightCol) {
                segsBelow = this.getCellSegs(row, col, levelLimit);
                colSegsBelow.push(segsBelow);
                totalSegsBelow += segsBelow.length;
                col++;
            }
            if (totalSegsBelow) {
                td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment&#39;s parent cell
                rowspan = td.attr(&#39;rowspan&#39;) || 1;
                segMoreNodes = [];
                // make a replacement &lt;td&gt; for each column the segment occupies. will be one for each colspan
                for (j = 0; j &lt; colSegsBelow.length; j++) {
                    moreTd = $(&#39;&lt;td class=&quot;fc-more-cell&quot;/&gt;&#39;).attr(&#39;rowspan&#39;, rowspan);
                    segsBelow = colSegsBelow[j];
                    moreLink = this.renderMoreLink(row, seg.leftCol + j, [seg].concat(segsBelow) // count seg as hidden too
                    );
                    moreWrap = $(&#39;&lt;div/&gt;&#39;).append(moreLink);
                    moreTd.append(moreWrap);
                    segMoreNodes.push(moreTd[0]);
                    moreNodes.push(moreTd[0]);
                }
                td.addClass(&#39;fc-limited&#39;).after($(segMoreNodes)); // hide original &lt;td&gt; and inject replacements
                limitedNodes.push(td[0]);
            }
        }
        emptyCellsUntil(this.colCnt); // finish off the level
        rowStruct.moreEls = $(moreNodes); // for easy undoing later
        rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
    }
};
// Reveals all levels and removes all &quot;more&quot;-related elements for a grid&#39;s row.
// `row` is a row number.
DayGrid.prototype.unlimitRow = function (row) {
    var rowStruct = this.eventRenderer.rowStructs[row];
    if (rowStruct.moreEls) {
        rowStruct.moreEls.remove();
        rowStruct.moreEls = null;
    }
    if (rowStruct.limitedEls) {
        rowStruct.limitedEls.removeClass(&#39;fc-limited&#39;);
        rowStruct.limitedEls = null;
    }
};
// Renders an &lt;a&gt; element that represents hidden event element for a cell.
// Responsible for attaching click handler as well.
DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {
    var _this = this;
    var view = this.view;
    return $(&#39;&lt;a class=&quot;fc-more&quot;/&gt;&#39;)
        .text(this.getMoreLinkText(hiddenSegs.length))
        .on(&#39;click&#39;, function (ev) {
        var clickOption = _this.opt(&#39;eventLimitClick&#39;);
        var date = _this.getCellDate(row, col);
        var moreEl = $(ev.currentTarget);
        var dayEl = _this.getCellEl(row, col);
        var allSegs = _this.getCellSegs(row, col);
        // rescope the segments to be within the cell&#39;s date
        var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
        var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);
        if (typeof clickOption === &#39;function&#39;) {
            // the returned value can be an atomic option
            clickOption = _this.publiclyTrigger(&#39;eventLimitClick&#39;, {
                context: view,
                args: [
                    {
                        date: date.clone(),
                        dayEl: dayEl,
                        moreEl: moreEl,
                        segs: reslicedAllSegs,
                        hiddenSegs: reslicedHiddenSegs
                    },
                    ev,
                    view
                ]
            });
        }
        if (clickOption === &#39;popover&#39;) {
            _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
        }
        else if (typeof clickOption === &#39;string&#39;) {
            view.calendar.zoomTo(date, clickOption);
        }
    });
};
// Reveals the popover that displays all events within a cell
DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {
    var _this = this;
    var view = this.view;
    var moreWrap = moreLink.parent(); // the &lt;div&gt; wrapper around the &lt;a&gt;
    var topEl; // the element we want to match the top coordinate of
    var options;
    if (this.rowCnt === 1) {
        topEl = view.el; // will cause the popover to cover any sort of header
    }
    else {
        topEl = this.rowEls.eq(row); // will align with top of row
    }
    options = {
        className: &#39;fc-more-popover &#39; + view.calendar.theme.getClass(&#39;popover&#39;),
        content: this.renderSegPopoverContent(row, col, segs),
        parentEl: view.el,
        top: topEl.offset().top,
        autoHide: true,
        viewportConstrain: this.opt(&#39;popoverViewportConstrain&#39;),
        hide: function () {
            // kill everything when the popover is hidden
            // notify events to be removed
            if (_this.popoverSegs) {
                _this.triggerBeforeEventSegsDestroyed(_this.popoverSegs);
            }
            _this.segPopover.removeElement();
            _this.segPopover = null;
            _this.popoverSegs = null;
        }
    };
    // Determine horizontal coordinate.
    // We use the moreWrap instead of the &lt;td&gt; to avoid border confusion.
    if (this.isRTL) {
        options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
    }
    else {
        options.left = moreWrap.offset().left - 1; // -1 to be over cell border
    }
    this.segPopover = new Popover_1.default(options);
    this.segPopover.show();
    // the popover doesn&#39;t live within the grid&#39;s container element, and thus won&#39;t get the event
    // delegated-handlers for free. attach event-related handlers to the popover.
    this.bindAllSegHandlersToEl(this.segPopover.el);
    this.triggerAfterEventSegsRendered(segs);
};
// Builds the inner DOM contents of the segment popover
DayGrid.prototype.renderSegPopoverContent = function (row, col, segs) {
    var view = this.view;
    var theme = view.calendar.theme;
    var title = this.getCellDate(row, col).format(this.opt(&#39;dayPopoverFormat&#39;));
    var content = $(&#39;&lt;div class=&quot;fc-header &#39; + theme.getClass(&#39;popoverHeader&#39;) + &#39;&quot;&gt;&#39; +
        &#39;&lt;span class=&quot;fc-close &#39; + theme.getIconClass(&#39;close&#39;) + &#39;&quot;&gt;&lt;/span&gt;&#39; +
        &#39;&lt;span class=&quot;fc-title&quot;&gt;&#39; +
        util_1.htmlEscape(title) +
        &#39;&lt;/span&gt;&#39; +
        &#39;&lt;div class=&quot;fc-clear&quot;/&gt;&#39; +
        &#39;&lt;/div&gt;&#39; +
        &#39;&lt;div class=&quot;fc-body &#39; + theme.getClass(&#39;popoverContent&#39;) + &#39;&quot;&gt;&#39; +
        &#39;&lt;div class=&quot;fc-event-container&quot;&gt;&lt;/div&gt;&#39; +
        &#39;&lt;/div&gt;&#39;);
    var segContainer = content.find(&#39;.fc-event-container&#39;);
    var i;
    // render each seg&#39;s `el` and only return the visible segs
    segs = this.eventRenderer.renderFgSegEls(segs, true); // disableResizing=true
    this.popoverSegs = segs;
    for (i = 0; i &lt; segs.length; i++) {
        // because segments in the popover are not part of a grid coordinate system, provide a hint to any
        // grids that want to do drag-n-drop about which cell it came from
        this.hitsNeeded();
        segs[i].hit = this.getCellHit(row, col);
        this.hitsNotNeeded();
        segContainer.append(segs[i].el);
    }
    return content;
};
// Given the events within an array of segment objects, reslice them to be in a single day
DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {
    var dayStart = dayDate.clone();
    var dayEnd = dayStart.clone().add(1, &#39;days&#39;);
    var dayRange = new UnzonedRange_1.default(dayStart, dayEnd);
    var newSegs = [];
    var i;
    var seg;
    var slicedRange;
    for (i = 0; i &lt; segs.length; i++) {
        seg = segs[i];
        slicedRange = seg.footprint.componentFootprint.unzonedRange.intersect(dayRange);
        if (slicedRange) {
            newSegs.push($.extend({}, seg, {
                footprint: new EventFootprint_1.default(new ComponentFootprint_1.default(slicedRange, seg.footprint.componentFootprint.isAllDay), seg.footprint.eventDef, seg.footprint.eventInstance),
                isStart: seg.isStart &amp;&amp; slicedRange.isStart,
                isEnd: seg.isEnd &amp;&amp; slicedRange.isEnd
            }));
        }
    }
    // force an order because eventsToSegs doesn&#39;t guarantee one
    // TODO: research if still needed
    this.eventRenderer.sortEventSegs(newSegs);
    return newSegs;
};
// Generates the text that should be inside a &quot;more&quot; link, given the number of events it represents
DayGrid.prototype.getMoreLinkText = function (num) {
    var opt = this.opt(&#39;eventLimitText&#39;);
    if (typeof opt === &#39;function&#39;) {
        return opt(num);
    }
    else {
        return &#39;+&#39; + num + &#39; &#39; + opt;
    }
};
// Returns segments within a given cell.
// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
DayGrid.prototype.getCellSegs = function (row, col, startLevel) {
    var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;
    var level = startLevel || 0;
    var segs = [];
    var seg;
    while (level &lt; segMatrix.length) {
        seg = segMatrix[level][col];
        if (seg) {
            segs.push(seg);
        }
        level++;
    }
    return segs;
};
return DayGrid;</pre>

<p>}(InteractiveDateComponent_1.default)); exports.default = DayGrid;
DayGrid.prototype.eventRendererClass = DayGridEventRenderer_1.default;
DayGrid.prototype.businessHourRendererClass =
BusinessHourRenderer_1.default; DayGrid.prototype.helperRendererClass =
DayGridHelperRenderer_1.default; DayGrid.prototype.fillRendererClass =
DayGridFillRenderer_1.default;
StandardInteractionsMixin_1.default.mixInto(DayGrid);
DayTableMixin_1.default.mixInto(DayGrid);</p>

<p>/***/ }), /* 62 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var Scroller_1 =
<em>webpack_require</em>(39); var View_1 = <em>webpack_require</em>(41);
var BasicViewDateProfileGenerator_1 = <em>webpack_require</em>(228); var
DayGrid_1 = <em>webpack_require</em>(61); /* An abstract class for the
“basic” views, as well as month view. Renders one or more rows of day
cells. ———————————————————————————————————————-*/ // It is a manager for a
DayGrid subcomponent, which does most of the heavy lifting. // It is
responsible for managing width/height. var BasicView = /** @class */
(function (_super) {</p>

<pre>tslib_1.__extends(BasicView, _super);
function BasicView(calendar, viewSpec) {
    var _this = _super.call(this, calendar, viewSpec) || this;
    _this.dayGrid = _this.instantiateDayGrid();
    _this.dayGrid.isRigid = _this.hasRigidRows();
    if (_this.opt(&#39;weekNumbers&#39;)) {
        if (_this.opt(&#39;weekNumbersWithinDays&#39;)) {
            _this.dayGrid.cellWeekNumbersVisible = true;
            _this.dayGrid.colWeekNumbersVisible = false;
        }
        else {
            _this.dayGrid.cellWeekNumbersVisible = false;
            _this.dayGrid.colWeekNumbersVisible = true;
        }
    }
    _this.addChild(_this.dayGrid);
    _this.scroller = new Scroller_1.default({
        overflowX: &#39;hidden&#39;,
        overflowY: &#39;auto&#39;
    });
    return _this;
}
// Generates the DayGrid object this view needs. Draws from this.dayGridClass
BasicView.prototype.instantiateDayGrid = function () {
    // generate a subclass on the fly with BasicView-specific behavior
    // TODO: cache this subclass
    var subclass = makeDayGridSubclass(this.dayGridClass);
    return new subclass(this);
};
BasicView.prototype.executeDateRender = function (dateProfile) {
    this.dayGrid.breakOnWeeks = /year|month|week/.test(dateProfile.currentRangeUnit);
    _super.prototype.executeDateRender.call(this, dateProfile);
};
BasicView.prototype.renderSkeleton = function () {
    var dayGridContainerEl;
    var dayGridEl;
    this.el.addClass(&#39;fc-basic-view&#39;).html(this.renderSkeletonHtml());
    this.scroller.render();
    dayGridContainerEl = this.scroller.el.addClass(&#39;fc-day-grid-container&#39;);
    dayGridEl = $(&#39;&lt;div class=&quot;fc-day-grid&quot; /&gt;&#39;).appendTo(dayGridContainerEl);
    this.el.find(&#39;.fc-body &gt; tr &gt; td&#39;).append(dayGridContainerEl);
    this.dayGrid.headContainerEl = this.el.find(&#39;.fc-head-container&#39;);
    this.dayGrid.setElement(dayGridEl);
};
BasicView.prototype.unrenderSkeleton = function () {
    this.dayGrid.removeElement();
    this.scroller.destroy();
};
// Builds the HTML skeleton for the view.
// The day-grid component will render inside of a container defined by this HTML.
BasicView.prototype.renderSkeletonHtml = function () {
    var theme = this.calendar.theme;
    return &#39;&#39; +
        &#39;&lt;table class=&quot;&#39; + theme.getClass(&#39;tableGrid&#39;) + &#39;&quot;&gt;&#39; +
        (this.opt(&#39;columnHeader&#39;) ?
            &#39;&lt;thead class=&quot;fc-head&quot;&gt;&#39; +
                &#39;&lt;tr&gt;&#39; +
                &#39;&lt;td class=&quot;fc-head-container &#39; + theme.getClass(&#39;widgetHeader&#39;) + &#39;&quot;&gt;&amp;nbsp;&lt;/td&gt;&#39; +
                &#39;&lt;/tr&gt;&#39; +
                &#39;&lt;/thead&gt;&#39; :
            &#39;&#39;) +
        &#39;&lt;tbody class=&quot;fc-body&quot;&gt;&#39; +
        &#39;&lt;tr&gt;&#39; +
        &#39;&lt;td class=&quot;&#39; + theme.getClass(&#39;widgetContent&#39;) + &#39;&quot;&gt;&lt;/td&gt;&#39; +
        &#39;&lt;/tr&gt;&#39; +
        &#39;&lt;/tbody&gt;&#39; +
        &#39;&lt;/table&gt;&#39;;
};
// Generates an HTML attribute string for setting the width of the week number column, if it is known
BasicView.prototype.weekNumberStyleAttr = function () {
    if (this.weekNumberWidth != null) {
        return &#39;style=&quot;width:&#39; + this.weekNumberWidth + &#39;px&quot;&#39;;
    }
    return &#39;&#39;;
};
// Determines whether each row should have a constant height
BasicView.prototype.hasRigidRows = function () {
    var eventLimit = this.opt(&#39;eventLimit&#39;);
    return eventLimit &amp;&amp; typeof eventLimit !== &#39;number&#39;;
};
/* Dimensions
------------------------------------------------------------------------------------------------------------------*/
// Refreshes the horizontal dimensions of the view
BasicView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
    var eventLimit = this.opt(&#39;eventLimit&#39;);
    var headRowEl = this.dayGrid.headContainerEl.find(&#39;.fc-row&#39;);
    var scrollerHeight;
    var scrollbarWidths;
    // hack to give the view some height prior to dayGrid&#39;s columns being rendered
    // TODO: separate setting height from scroller VS dayGrid.
    if (!this.dayGrid.rowEls) {
        if (!isAuto) {
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.scroller.setHeight(scrollerHeight);
        }
        return;
    }
    _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
    if (this.dayGrid.colWeekNumbersVisible) {
        // Make sure all week number cells running down the side have the same width.
        // Record the width for cells created later.
        this.weekNumberWidth = util_1.matchCellWidths(this.el.find(&#39;.fc-week-number&#39;));
    }
    // reset all heights to be natural
    this.scroller.clear();
    util_1.uncompensateScroll(headRowEl);
    this.dayGrid.removeSegPopover(); // kill the &quot;more&quot; popover if displayed
    // is the event limit a constant level number?
    if (eventLimit &amp;&amp; typeof eventLimit === &#39;number&#39;) {
        this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
    }
    // distribute the height to the rows
    // (totalHeight is a &quot;recommended&quot; value if isAuto)
    scrollerHeight = this.computeScrollerHeight(totalHeight);
    this.setGridHeight(scrollerHeight, isAuto);
    // is the event limit dynamically calculated?
    if (eventLimit &amp;&amp; typeof eventLimit !== &#39;number&#39;) {
        this.dayGrid.limitRows(eventLimit); // limit the levels after the grid&#39;s row heights have been set
    }
    if (!isAuto) {
        this.scroller.setHeight(scrollerHeight);
        scrollbarWidths = this.scroller.getScrollbarWidths();
        if (scrollbarWidths.left || scrollbarWidths.right) {
            util_1.compensateScroll(headRowEl, scrollbarWidths);
            // doing the scrollbar compensation might have created text overflow which created more height. redo
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.scroller.setHeight(scrollerHeight);
        }
        // guarantees the same scrollbar widths
        this.scroller.lockOverflow(scrollbarWidths);
    }
};
// given a desired total height of the view, returns what the height of the scroller should be
BasicView.prototype.computeScrollerHeight = function (totalHeight) {
    return totalHeight -
        util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that&#39;s NOT the scroller
};
// Sets the height of just the DayGrid component in this view
BasicView.prototype.setGridHeight = function (height, isAuto) {
    if (isAuto) {
        util_1.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
    }
    else {
        util_1.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
    }
};
/* Scroll
------------------------------------------------------------------------------------------------------------------*/
BasicView.prototype.computeInitialDateScroll = function () {
    return { top: 0 };
};
BasicView.prototype.queryDateScroll = function () {
    return { top: this.scroller.getScrollTop() };
};
BasicView.prototype.applyDateScroll = function (scroll) {
    if (scroll.top !== undefined) {
        this.scroller.setScrollTop(scroll.top);
    }
};
return BasicView;</pre>

<p>}(View_1.default)); exports.default = BasicView;
BasicView.prototype.dateProfileGeneratorClass =
BasicViewDateProfileGenerator_1.default; BasicView.prototype.dayGridClass =
DayGrid_1.default; // customize the rendering behavior of BasicView&#39;s
dayGrid function makeDayGridSubclass(SuperClass) {</p>

<pre>return /** @class */ (function (_super) {
    tslib_1.__extends(SubClass, _super);
    function SubClass() {
        var _this = _super !== null &amp;&amp; _super.apply(this, arguments) || this;
        _this.colWeekNumbersVisible = false; // display week numbers along the side?
        return _this;
    }
    // Generates the HTML that will go before the day-of week header cells
    SubClass.prototype.renderHeadIntroHtml = function () {
        var view = this.view;
        if (this.colWeekNumbersVisible) {
            return &#39;&#39; +
                &#39;&lt;th class=&quot;fc-week-number &#39; + view.calendar.theme.getClass(&#39;widgetHeader&#39;) + &#39;&quot; &#39; + view.weekNumberStyleAttr() + &#39;&gt;&#39; +
                &#39;&lt;span&gt;&#39; + // needed for matchCellWidths
                util_1.htmlEscape(this.opt(&#39;weekNumberTitle&#39;)) +
                &#39;&lt;/span&gt;&#39; +
                &#39;&lt;/th&gt;&#39;;
        }
        return &#39;&#39;;
    };
    // Generates the HTML that will go before content-skeleton cells that display the day/week numbers
    SubClass.prototype.renderNumberIntroHtml = function (row) {
        var view = this.view;
        var weekStart = this.getCellDate(row, 0);
        if (this.colWeekNumbersVisible) {
            return &#39;&#39; +
                &#39;&lt;td class=&quot;fc-week-number&quot; &#39; + view.weekNumberStyleAttr() + &#39;&gt;&#39; +
                view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                { date: weekStart, type: &#39;week&#39;, forceOff: this.colCnt === 1 }, weekStart.format(&#39;w&#39;) // inner HTML
                ) +
                &#39;&lt;/td&gt;&#39;;
        }
        return &#39;&#39;;
    };
    // Generates the HTML that goes before the day bg cells for each day-row
    SubClass.prototype.renderBgIntroHtml = function () {
        var view = this.view;
        if (this.colWeekNumbersVisible) {
            return &#39;&lt;td class=&quot;fc-week-number &#39; + view.calendar.theme.getClass(&#39;widgetContent&#39;) + &#39;&quot; &#39; +
                view.weekNumberStyleAttr() + &#39;&gt;&lt;/td&gt;&#39;;
        }
        return &#39;&#39;;
    };
    // Generates the HTML that goes before every other type of row generated by DayGrid.
    // Affects helper-skeleton and highlight-skeleton rows.
    SubClass.prototype.renderIntroHtml = function () {
        var view = this.view;
        if (this.colWeekNumbersVisible) {
            return &#39;&lt;td class=&quot;fc-week-number&quot; &#39; + view.weekNumberStyleAttr() + &#39;&gt;&lt;/td&gt;&#39;;
        }
        return &#39;&#39;;
    };
    SubClass.prototype.getIsNumbersVisible = function () {
        return DayGrid_1.default.prototype.getIsNumbersVisible.apply(this, arguments) || this.colWeekNumbersVisible;
    };
    return SubClass;
}(SuperClass));</pre>

<p>}</p>

<p>/***/ }), /* 63 */, /* 64 */, /* 65 */, /* 66 */, /* 67 */, /* 68 */, /* 69
*/, /* 70 */, /* 71 */, /* 72 */, /* 73 */, /* 74 */, /* 75 */, /* 76 */,
/* 77 */, /* 78 */, /* 79 */, /* 80 */, /* 81 */, /* 82 */, /* 83 */, /* 84
*/, /* 85 */, /* 86 */, /* 87 */, /* 88 */, /* 89 */, /* 90 */, /* 91 */,
/* 92 */, /* 93 */, /* 94 */, /* 95 */, /* 96 */, /* 97 */, /* 98 */, /* 99
*/, /* 100 */, /* 101 */, /* 102 */, /* 103 */, /* 104 */, /* 105 */, /*
106 */, /* 107 */, /* 108 */, /* 109 */, /* 110 */, /* 111 */, /* 112 */,
/* 113 */, /* 114 */, /* 115 */, /* 116 */, /* 117 */, /* 118 */, /* 119
*/, /* 120 */, /* 121 */, /* 122 */, /* 123 */, /* 124 */, /* 125 */, /*
126 */, /* 127 */, /* 128 */, /* 129 */, /* 130 */, /* 131 */, /* 132 */,
/* 133 */, /* 134 */, /* 135 */, /* 136 */, /* 137 */, /* 138 */, /* 139
*/, /* 140 */, /* 141 */, /* 142 */, /* 143 */, /* 144 */, /* 145 */, /*
146 */, /* 147 */, /* 148 */, /* 149 */, /* 150 */, /* 151 */, /* 152 */,
/* 153 */, /* 154 */, /* 155 */, /* 156 */, /* 157 */, /* 158 */, /* 159
*/, /* 160 */, /* 161 */, /* 162 */, /* 163 */, /* 164 */, /* 165 */, /*
166 */, /* 167 */, /* 168 */, /* 169 */, /* 170 */, /* 171 */, /* 172 */,
/* 173 */, /* 174 */, /* 175 */, /* 176 */, /* 177 */, /* 178 */, /* 179
*/, /* 180 */, /* 181 */, /* 182 */, /* 183 */, /* 184 */, /* 185 */, /*
186 */, /* 187 */, /* 188 */, /* 189 */, /* 190 */, /* 191 */, /* 192 */,
/* 193 */, /* 194 */, /* 195 */, /* 196 */, /* 197 */, /* 198 */, /* 199
*/, /* 200 */, /* 201 */, /* 202 */, /* 203 */, /* 204 */, /* 205 */, /*
206 */, /* 207 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
UnzonedRange_1 = <em>webpack_require</em>(5); var ComponentFootprint_1 =
<em>webpack_require</em>(12); var EventDefParser_1 =
<em>webpack_require</em>(49); var EventSource_1 =
<em>webpack_require</em>(6); var util_1 = <em>webpack_require</em>(35); var
Constraints = /** @class */ (function () {</p>

<pre>function Constraints(eventManager, _calendar) {
    this.eventManager = eventManager;
    this._calendar = _calendar;
}
Constraints.prototype.opt = function (name) {
    return this._calendar.opt(name);
};
/*
determines if eventInstanceGroup is allowed,
in relation to other EVENTS and business hours.
 /
Constraints.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {
    var eventDef = eventInstanceGroup.getEventDef();
    var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
    var i;
    var peerEventInstances = this.getPeerEventInstances(eventDef);
    var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);
    var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);
    var constraintVal = eventDef.getConstraint();
    var overlapVal = eventDef.getOverlap();
    var eventAllowFunc = this.opt(&#39;eventAllow&#39;);
    for (i = 0; i &lt; eventFootprints.length; i++) {
        if (!this.isFootprintAllowed(eventFootprints[i].componentFootprint, peerEventFootprints, constraintVal, overlapVal, eventFootprints[i].eventInstance)) {
            return false;
        }
    }
    if (eventAllowFunc) {
        for (i = 0; i &lt; eventFootprints.length; i++) {
            if (eventAllowFunc(eventFootprints[i].componentFootprint.toLegacy(this._calendar), eventFootprints[i].getEventLegacy()) === false) {
                return false;
            }
        }
    }
    return true;
};
Constraints.prototype.getPeerEventInstances = function (eventDef) {
    return this.eventManager.getEventInstancesWithoutId(eventDef.id);
};
Constraints.prototype.isSelectionFootprintAllowed = function (componentFootprint) {
    var peerEventInstances = this.eventManager.getEventInstances();
    var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);
    var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);
    var selectAllowFunc;
    if (this.isFootprintAllowed(componentFootprint, peerEventFootprints, this.opt(&#39;selectConstraint&#39;), this.opt(&#39;selectOverlap&#39;))) {
        selectAllowFunc = this.opt(&#39;selectAllow&#39;);
        if (selectAllowFunc) {
            return selectAllowFunc(componentFootprint.toLegacy(this._calendar)) !== false;
        }
        else {
            return true;
        }
    }
    return false;
};
Constraints.prototype.isFootprintAllowed = function (componentFootprint, peerEventFootprints, constraintVal, overlapVal, subjectEventInstance // optional
) {
    var constraintFootprints; // ComponentFootprint[]
    var overlapEventFootprints; // EventFootprint[]
    if (constraintVal != null) {
        constraintFootprints = this.constraintValToFootprints(constraintVal, componentFootprint.isAllDay);
        if (!this.isFootprintWithinConstraints(componentFootprint, constraintFootprints)) {
            return false;
        }
    }
    overlapEventFootprints = this.collectOverlapEventFootprints(peerEventFootprints, componentFootprint);
    if (overlapVal === false) {
        if (overlapEventFootprints.length) {
            return false;
        }
    }
    else if (typeof overlapVal === &#39;function&#39;) {
        if (!isOverlapsAllowedByFunc(overlapEventFootprints, overlapVal, subjectEventInstance)) {
            return false;
        }
    }
    if (subjectEventInstance) {
        if (!isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance)) {
            return false;
        }
    }
    return true;
};
// Constraint
// ------------------------------------------------------------------------------------------------
Constraints.prototype.isFootprintWithinConstraints = function (componentFootprint, constraintFootprints) {
    var i;
    for (i = 0; i &lt; constraintFootprints.length; i++) {
        if (this.footprintContainsFootprint(constraintFootprints[i], componentFootprint)) {
            return true;
        }
    }
    return false;
};
Constraints.prototype.constraintValToFootprints = function (constraintVal, isAllDay) {
    var eventInstances;
    if (constraintVal === &#39;businessHours&#39;) {
        return this.buildCurrentBusinessFootprints(isAllDay);
    }
    else if (typeof constraintVal === &#39;object&#39;) {
        eventInstances = this.parseEventDefToInstances(constraintVal); // handles recurring events
        if (!eventInstances) {
            return this.parseFootprints(constraintVal);
        }
        else {
            return this.eventInstancesToFootprints(eventInstances);
        }
    }
    else if (constraintVal != null) {
        eventInstances = this.eventManager.getEventInstancesWithId(constraintVal);
        return this.eventInstancesToFootprints(eventInstances);
    }
};
// returns ComponentFootprint[]
// uses current view&#39;s range
Constraints.prototype.buildCurrentBusinessFootprints = function (isAllDay) {
    var view = this._calendar.view;
    var businessHourGenerator = view.get(&#39;businessHourGenerator&#39;);
    var unzonedRange = view.dateProfile.activeUnzonedRange;
    var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(isAllDay, unzonedRange);
    if (eventInstanceGroup) {
        return this.eventInstancesToFootprints(eventInstanceGroup.eventInstances);
    }
    else {
        return [];
    }
};
// conversion util
Constraints.prototype.eventInstancesToFootprints = function (eventInstances) {
    var eventRanges = eventInstances.map(util_1.eventInstanceToEventRange);
    var eventFootprints = this.eventRangesToEventFootprints(eventRanges);
    return eventFootprints.map(util_1.eventFootprintToComponentFootprint);
};
// Overlap
// ------------------------------------------------------------------------------------------------
Constraints.prototype.collectOverlapEventFootprints = function (peerEventFootprints, targetFootprint) {
    var overlapEventFootprints = [];
    var i;
    for (i = 0; i &lt; peerEventFootprints.length; i++) {
        if (this.footprintsIntersect(targetFootprint, peerEventFootprints[i].componentFootprint)) {
            overlapEventFootprints.push(peerEventFootprints[i]);
        }
    }
    return overlapEventFootprints;
};
// Conversion: eventDefs -&gt; eventInstances -&gt; eventRanges -&gt; eventFootprints -&gt; componentFootprints
// ------------------------------------------------------------------------------------------------
// NOTE: this might seem like repetitive code with the Grid class, however, this code is related to
// constraints whereas the Grid code is related to rendering. Each approach might want to convert
// eventRanges -&gt; eventFootprints in a different way. Regardless, there are opportunities to make
// this more DRY.
/*
Returns false on invalid input.
 /
Constraints.prototype.parseEventDefToInstances = function (eventInput) {
    var eventManager = this.eventManager;
    var eventDef = EventDefParser_1.default.parse(eventInput, new EventSource_1.default(this._calendar));
    if (!eventDef) {
        return false;
    }
    return eventDef.buildInstances(eventManager.currentPeriod.unzonedRange);
};
Constraints.prototype.eventRangesToEventFootprints = function (eventRanges) {
    var i;
    var eventFootprints = [];
    for (i = 0; i &lt; eventRanges.length; i++) {
        eventFootprints.push.apply(// footprints
        eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));
    }
    return eventFootprints;
};
Constraints.prototype.eventRangeToEventFootprints = function (eventRange) {
    return [util_1.eventRangeToEventFootprint(eventRange)];
};
/*
Parses footprints directly.
Very similar to EventDateProfile::parse :(
 /
Constraints.prototype.parseFootprints = function (rawInput) {
    var start;
    var end;
    if (rawInput.start) {
        start = this._calendar.moment(rawInput.start);
        if (!start.isValid()) {
            start = null;
        }
    }
    if (rawInput.end) {
        end = this._calendar.moment(rawInput.end);
        if (!end.isValid()) {
            end = null;
        }
    }
    return [
        new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), (start &amp;&amp; !start.hasTime()) || (end &amp;&amp; !end.hasTime()) // isAllDay
        )
    ];
};
// Footprint Utils
// ----------------------------------------------------------------------------------------
Constraints.prototype.footprintContainsFootprint = function (outerFootprint, innerFootprint) {
    return outerFootprint.unzonedRange.containsRange(innerFootprint.unzonedRange);
};
Constraints.prototype.footprintsIntersect = function (footprint0, footprint1) {
    return footprint0.unzonedRange.intersectsWith(footprint1.unzonedRange);
};
return Constraints;</pre>

<p>}()); exports.default = Constraints; // optional subjectEventInstance
function isOverlapsAllowedByFunc(overlapEventFootprints, overlapFunc,
subjectEventInstance) {</p>

<pre>var i;
for (i = 0; i &lt; overlapEventFootprints.length; i++) {
    if (!overlapFunc(overlapEventFootprints[i].eventInstance.toLegacy(), subjectEventInstance ? subjectEventInstance.toLegacy() : null)) {
        return false;
    }
}
return true;</pre>

<p>} function isOverlapEventInstancesAllowed(overlapEventFootprints,
subjectEventInstance) {</p>

<pre>var subjectLegacyInstance = subjectEventInstance.toLegacy();
var i;
var overlapEventInstance;
var overlapEventDef;
var overlapVal;
for (i = 0; i &lt; overlapEventFootprints.length; i++) {
    overlapEventInstance = overlapEventFootprints[i].eventInstance;
    overlapEventDef = overlapEventInstance.def;
    // don&#39;t need to pass in calendar, because don&#39;t want to consider global eventOverlap property,
    // because we already considered that earlier in the process.
    overlapVal = overlapEventDef.getOverlap();
    if (overlapVal === false) {
        return false;
    }
    else if (typeof overlapVal === &#39;function&#39;) {
        if (!overlapVal(overlapEventInstance.toLegacy(), subjectLegacyInstance)) {
            return false;
        }
    }
}
return true;</pre>

<p>}</p>

<p>/***/ }), /* 208 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>/* USAGE:</p>

<pre>import { default as ParsableModelMixin, ParsableModelInterface } from &#39;./ParsableModelMixin&#39;</pre>

<p>in class:</p>

<pre>applyProps: ParsableModelInterface[&#39;applyProps&#39;]
applyManualStandardProps: ParsableModelInterface[&#39;applyManualStandardProps&#39;]
applyMiscProps: ParsableModelInterface[&#39;applyMiscProps&#39;]
isStandardProp: ParsableModelInterface[&#39;isStandardProp&#39;]
static defineStandardProps = ParsableModelMixin.defineStandardProps
static copyVerbatimStandardProps = ParsableModelMixin.copyVerbatimStandardProps</pre>

<p>after class:</p>

<pre> ParsableModelMixin.mixInto(TheClass)
/</pre>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var util_1 = <em>webpack_require</em>(4);
var Mixin_1 = <em>webpack_require</em>(14); var ParsableModelMixin = /**
@class */ (function (_super) {</p>

<pre>tslib_1.__extends(ParsableModelMixin, _super);
function ParsableModelMixin() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
ParsableModelMixin.defineStandardProps = function (propDefs) {
    var proto = this.prototype;
    if (!proto.hasOwnProperty(&#39;standardPropMap&#39;)) {
        proto.standardPropMap = Object.create(proto.standardPropMap);
    }
    util_1.copyOwnProps(propDefs, proto.standardPropMap);
};
ParsableModelMixin.copyVerbatimStandardProps = function (src, dest) {
    var map = this.prototype.standardPropMap;
    var propName;
    for (propName in map) {
        if (src[propName] != null &amp;&amp; // in the src object?
            map[propName] === true // false means &quot;copy verbatim&quot;
        ) {
            dest[propName] = src[propName];
        }
    }
};
/*
Returns true/false for success.
Meant to be only called ONCE, at object creation.
 /
ParsableModelMixin.prototype.applyProps = function (rawProps) {
    var standardPropMap = this.standardPropMap;
    var manualProps = {};
    var miscProps = {};
    var propName;
    for (propName in rawProps) {
        if (standardPropMap[propName] === true) {
            this[propName] = rawProps[propName];
        }
        else if (standardPropMap[propName] === false) {
            manualProps[propName] = rawProps[propName];
        }
        else {
            miscProps[propName] = rawProps[propName];
        }
    }
    this.applyMiscProps(miscProps);
    return this.applyManualStandardProps(manualProps);
};
/*
If subclasses override, they must call this supermethod and return the boolean response.
Meant to be only called ONCE, at object creation.
 /
ParsableModelMixin.prototype.applyManualStandardProps = function (rawProps) {
    return true;
};
/*
Can be called even after initial object creation.
 /
ParsableModelMixin.prototype.applyMiscProps = function (rawProps) {
    // subclasses can implement
};
/*
TODO: why is this a method when defineStandardProps is static
 /
ParsableModelMixin.prototype.isStandardProp = function (propName) {
    return propName in this.standardPropMap;
};
return ParsableModelMixin;</pre>

<p>}(Mixin_1.default)); exports.default = ParsableModelMixin;
ParsableModelMixin.prototype.standardPropMap = {}; // will be cloned by
defineStandardProps</p>

<p>/***/ }), /* 209 */ /***/ (function(module, exports) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
EventInstance = /** @class */ (function () {</p>

<pre>function EventInstance(def, dateProfile) {
    this.def = def;
    this.dateProfile = dateProfile;
}
EventInstance.prototype.toLegacy = function () {
    var dateProfile = this.dateProfile;
    var obj = this.def.toLegacy();
    obj.start = dateProfile.start.clone();
    obj.end = dateProfile.end ? dateProfile.end.clone() : null;
    return obj;
};
return EventInstance;</pre>

<p>}()); exports.default = EventInstance;</p>

<p>/***/ }), /* 210 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
moment = <em>webpack_require</em>(0); var EventDef_1 =
<em>webpack_require</em>(34); var EventInstance_1 =
<em>webpack_require</em>(209); var EventDateProfile_1 =
<em>webpack_require</em>(17); var RecurringEventDef = /** @class */
(function (_super) {</p>

<pre>tslib_1.__extends(RecurringEventDef, _super);
function RecurringEventDef() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
RecurringEventDef.prototype.isAllDay = function () {
    return !this.startTime &amp;&amp; !this.endTime;
};
RecurringEventDef.prototype.buildInstances = function (unzonedRange) {
    var calendar = this.source.calendar;
    var unzonedDate = unzonedRange.getStart();
    var unzonedEnd = unzonedRange.getEnd();
    var zonedDayStart;
    var instanceStart;
    var instanceEnd;
    var instances = [];
    while (unzonedDate.isBefore(unzonedEnd)) {
        // if everyday, or this particular day-of-week
        if (!this.dowHash || this.dowHash[unzonedDate.day()]) {
            zonedDayStart = calendar.applyTimezone(unzonedDate);
            instanceStart = zonedDayStart.clone();
            instanceEnd = null;
            if (this.startTime) {
                instanceStart.time(this.startTime);
            }
            else {
                instanceStart.stripTime();
            }
            if (this.endTime) {
                instanceEnd = zonedDayStart.clone().time(this.endTime);
            }
            instances.push(new EventInstance_1.default(this, // definition
            new EventDateProfile_1.default(instanceStart, instanceEnd, calendar)));
        }
        unzonedDate.add(1, &#39;days&#39;);
    }
    return instances;
};
RecurringEventDef.prototype.setDow = function (dowNumbers) {
    if (!this.dowHash) {
        this.dowHash = {};
    }
    for (var i = 0; i &lt; dowNumbers.length; i++) {
        this.dowHash[dowNumbers[i]] = true;
    }
};
RecurringEventDef.prototype.clone = function () {
    var def = _super.prototype.clone.call(this);
    if (def.startTime) {
        def.startTime = moment.duration(this.startTime);
    }
    if (def.endTime) {
        def.endTime = moment.duration(this.endTime);
    }
    if (this.dowHash) {
        def.dowHash = $.extend({}, this.dowHash);
    }
    return def;
};
return RecurringEventDef;</pre>

<p>}(EventDef_1.default)); exports.default = RecurringEventDef; /* HACK to
work with TypeScript mixins NOTE: if super-method fails, should still
attempt to apply</p>

<pre>/</pre>

<p>RecurringEventDef.prototype.applyProps = function (rawProps) {</p>

<pre>var superSuccess = EventDef_1.default.prototype.applyProps.call(this, rawProps);
if (rawProps.start) {
    this.startTime = moment.duration(rawProps.start);
}
if (rawProps.end) {
    this.endTime = moment.duration(rawProps.end);
}
if (rawProps.dow) {
    this.setDow(rawProps.dow);
}
return superSuccess;</pre>

<p>}; // Parsing // ———————————————————————————————————————
RecurringEventDef.defineStandardProps({</p>

<pre>start: false,
end: false,
dow: false</pre>

<p>});</p>

<p>/***/ }), /* 211 */ /***/ (function(module, exports) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
EventRange = /** @class */ (function () {</p>

<pre>function EventRange(unzonedRange, eventDef, eventInstance) {
    this.unzonedRange = unzonedRange;
    this.eventDef = eventDef;
    if (eventInstance) {
        this.eventInstance = eventInstance;
    }
}
return EventRange;</pre>

<p>}()); exports.default = EventRange;</p>

<p>/***/ }), /* 212 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var util_1 = <em>webpack_require</em>(35); var
EventInstanceGroup_1 = <em>webpack_require</em>(18); var
RecurringEventDef_1 = <em>webpack_require</em>(210); var EventSource_1 =
<em>webpack_require</em>(6); var BUSINESS_HOUR_EVENT_DEFAULTS = {</p>

<pre>start: &#39;09:00&#39;,
end: &#39;17:00&#39;,
dow: [1, 2, 3, 4, 5],
rendering: &#39;inverse-background&#39;
// classNames are defined in businessHoursSegClasses</pre>

<p>}; var BusinessHourGenerator = /** @class */ (function () {</p>

<pre>function BusinessHourGenerator(rawComplexDef, calendar) {
    this.rawComplexDef = rawComplexDef;
    this.calendar = calendar;
}
BusinessHourGenerator.prototype.buildEventInstanceGroup = function (isAllDay, unzonedRange) {
    var eventDefs = this.buildEventDefs(isAllDay);
    var eventInstanceGroup;
    if (eventDefs.length) {
        eventInstanceGroup = new EventInstanceGroup_1.default(util_1.eventDefsToEventInstances(eventDefs, unzonedRange));
        // so that inverse-background rendering can happen even when no eventRanges in view
        eventInstanceGroup.explicitEventDef = eventDefs[0];
        return eventInstanceGroup;
    }
};
BusinessHourGenerator.prototype.buildEventDefs = function (isAllDay) {
    var rawComplexDef = this.rawComplexDef;
    var rawDefs = [];
    var requireDow = false;
    var i;
    var defs = [];
    if (rawComplexDef === true) {
        rawDefs = [{}]; // will get BUSINESS_HOUR_EVENT_DEFAULTS verbatim
    }
    else if ($.isPlainObject(rawComplexDef)) {
        rawDefs = [rawComplexDef];
    }
    else if ($.isArray(rawComplexDef)) {
        rawDefs = rawComplexDef;
        requireDow = true; // every sub-definition NEEDS a day-of-week
    }
    for (i = 0; i &lt; rawDefs.length; i++) {
        if (!requireDow || rawDefs[i].dow) {
            defs.push(this.buildEventDef(isAllDay, rawDefs[i]));
        }
    }
    return defs;
};
BusinessHourGenerator.prototype.buildEventDef = function (isAllDay, rawDef) {
    var fullRawDef = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, rawDef);
    if (isAllDay) {
        fullRawDef.start = null;
        fullRawDef.end = null;
    }
    return RecurringEventDef_1.default.parse(fullRawDef, new EventSource_1.default(this.calendar) // dummy source
    );
};
return BusinessHourGenerator;</pre>

<p>}()); exports.default = BusinessHourGenerator;</p>

<p>/***/ }), /* 213 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var Theme_1 = <em>webpack_require</em>(19);
var StandardTheme = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(StandardTheme, _super);
function StandardTheme() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
return StandardTheme;</pre>

<p>}(Theme_1.default)); exports.default = StandardTheme;
StandardTheme.prototype.classes = {</p>

<pre>widget: &#39;fc-unthemed&#39;,
widgetHeader: &#39;fc-widget-header&#39;,
widgetContent: &#39;fc-widget-content&#39;,
buttonGroup: &#39;fc-button-group&#39;,
button: &#39;fc-button&#39;,
cornerLeft: &#39;fc-corner-left&#39;,
cornerRight: &#39;fc-corner-right&#39;,
stateDefault: &#39;fc-state-default&#39;,
stateActive: &#39;fc-state-active&#39;,
stateDisabled: &#39;fc-state-disabled&#39;,
stateHover: &#39;fc-state-hover&#39;,
stateDown: &#39;fc-state-down&#39;,
popoverHeader: &#39;fc-widget-header&#39;,
popoverContent: &#39;fc-widget-content&#39;,
// day grid
headerRow: &#39;fc-widget-header&#39;,
dayRow: &#39;fc-widget-content&#39;,
// list view
listView: &#39;fc-widget-content&#39;</pre>

<p>}; StandardTheme.prototype.baseIconClass = &#39;fc-icon&#39;;
StandardTheme.prototype.iconClasses = {</p>

<pre>close: &#39;fc-icon-x&#39;,
prev: &#39;fc-icon-left-single-arrow&#39;,
next: &#39;fc-icon-right-single-arrow&#39;,
prevYear: &#39;fc-icon-left-double-arrow&#39;,
nextYear: &#39;fc-icon-right-double-arrow&#39;</pre>

<p>}; StandardTheme.prototype.iconOverrideOption = &#39;buttonIcons&#39;;
StandardTheme.prototype.iconOverrideCustomButtonOption = &#39;icon&#39;;
StandardTheme.prototype.iconOverridePrefix = &#39;fc-icon-&#39;;</p>

<p>/***/ }), /* 214 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var Theme_1 = <em>webpack_require</em>(19);
var JqueryUiTheme = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(JqueryUiTheme, _super);
function JqueryUiTheme() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
return JqueryUiTheme;</pre>

<p>}(Theme_1.default)); exports.default = JqueryUiTheme;
JqueryUiTheme.prototype.classes = {</p>

<pre>widget: &#39;ui-widget&#39;,
widgetHeader: &#39;ui-widget-header&#39;,
widgetContent: &#39;ui-widget-content&#39;,
buttonGroup: &#39;fc-button-group&#39;,
button: &#39;ui-button&#39;,
cornerLeft: &#39;ui-corner-left&#39;,
cornerRight: &#39;ui-corner-right&#39;,
stateDefault: &#39;ui-state-default&#39;,
stateActive: &#39;ui-state-active&#39;,
stateDisabled: &#39;ui-state-disabled&#39;,
stateHover: &#39;ui-state-hover&#39;,
stateDown: &#39;ui-state-down&#39;,
today: &#39;ui-state-highlight&#39;,
popoverHeader: &#39;ui-widget-header&#39;,
popoverContent: &#39;ui-widget-content&#39;,
// day grid
headerRow: &#39;ui-widget-header&#39;,
dayRow: &#39;ui-widget-content&#39;,
// list view
listView: &#39;ui-widget-content&#39;</pre>

<p>}; JqueryUiTheme.prototype.baseIconClass = &#39;ui-icon&#39;;
JqueryUiTheme.prototype.iconClasses = {</p>

<pre>close: &#39;ui-icon-closethick&#39;,
prev: &#39;ui-icon-circle-triangle-w&#39;,
next: &#39;ui-icon-circle-triangle-e&#39;,
prevYear: &#39;ui-icon-seek-prev&#39;,
nextYear: &#39;ui-icon-seek-next&#39;</pre>

<p>}; JqueryUiTheme.prototype.iconOverrideOption = &#39;themeButtonIcons&#39;;
JqueryUiTheme.prototype.iconOverrideCustomButtonOption =
&#39;themeIcon&#39;; JqueryUiTheme.prototype.iconOverridePrefix =
&#39;ui-icon-&#39;;</p>

<p>/***/ }), /* 215 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
Promise_1 = <em>webpack_require</em>(20); var EventSource_1 =
<em>webpack_require</em>(6); var FuncEventSource = /** @class */ (function
(_super) {</p>

<pre>tslib_1.__extends(FuncEventSource, _super);
function FuncEventSource() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
FuncEventSource.parse = function (rawInput, calendar) {
    var rawProps;
    // normalize raw input
    if ($.isFunction(rawInput.events)) {
        rawProps = rawInput;
    }
    else if ($.isFunction(rawInput)) {
        rawProps = { events: rawInput };
    }
    if (rawProps) {
        return EventSource_1.default.parse.call(this, rawProps, calendar);
    }
    return false;
};
FuncEventSource.prototype.fetch = function (start, end, timezone) {
    var _this = this;
    this.calendar.pushLoading();
    return Promise_1.default.construct(function (onResolve) {
        _this.func.call(_this.calendar, start.clone(), end.clone(), timezone, function (rawEventDefs) {
            _this.calendar.popLoading();
            onResolve(_this.parseEventDefs(rawEventDefs));
        });
    });
};
FuncEventSource.prototype.getPrimitive = function () {
    return this.func;
};
FuncEventSource.prototype.applyManualStandardProps = function (rawProps) {
    var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
    this.func = rawProps.events;
    return superSuccess;
};
return FuncEventSource;</pre>

<p>}(EventSource_1.default)); exports.default = FuncEventSource;
FuncEventSource.defineStandardProps({</p>

<pre>events: false // don&#39;t automatically transfer</pre>

<p>});</p>

<p>/***/ }), /* 216 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var Promise_1 =
<em>webpack_require</em>(20); var EventSource_1 =
<em>webpack_require</em>(6); var JsonFeedEventSource = /** @class */
(function (_super) {</p>

<pre>tslib_1.__extends(JsonFeedEventSource, _super);
function JsonFeedEventSource() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
JsonFeedEventSource.parse = function (rawInput, calendar) {
    var rawProps;
    // normalize raw input
    if (typeof rawInput.url === &#39;string&#39;) {
        rawProps = rawInput;
    }
    else if (typeof rawInput === &#39;string&#39;) {
        rawProps = { url: rawInput };
    }
    if (rawProps) {
        return EventSource_1.default.parse.call(this, rawProps, calendar);
    }
    return false;
};
JsonFeedEventSource.prototype.fetch = function (start, end, timezone) {
    var _this = this;
    var ajaxSettings = this.ajaxSettings;
    var onSuccess = ajaxSettings.success;
    var onError = ajaxSettings.error;
    var requestParams = this.buildRequestParams(start, end, timezone);
    // todo: eventually handle the promise&#39;s then,
    // don&#39;t intercept success/error
    // tho will be a breaking API change
    this.calendar.pushLoading();
    return Promise_1.default.construct(function (onResolve, onReject) {
        $.ajax($.extend({}, // destination
        JsonFeedEventSource.AJAX_DEFAULTS, ajaxSettings, {
            url: _this.url,
            data: requestParams,
            success: function (rawEventDefs, status, xhr) {
                var callbackRes;
                _this.calendar.popLoading();
                if (rawEventDefs) {
                    callbackRes = util_1.applyAll(onSuccess, _this, [rawEventDefs, status, xhr]); // redirect `this`
                    if ($.isArray(callbackRes)) {
                        rawEventDefs = callbackRes;
                    }
                    onResolve(_this.parseEventDefs(rawEventDefs));
                }
                else {
                    onReject();
                }
            },
            error: function (xhr, statusText, errorThrown) {
                _this.calendar.popLoading();
                util_1.applyAll(onError, _this, [xhr, statusText, errorThrown]); // redirect `this`
                onReject();
            }
        }));
    });
};
JsonFeedEventSource.prototype.buildRequestParams = function (start, end, timezone) {
    var calendar = this.calendar;
    var ajaxSettings = this.ajaxSettings;
    var startParam;
    var endParam;
    var timezoneParam;
    var customRequestParams;
    var params = {};
    startParam = this.startParam;
    if (startParam == null) {
        startParam = calendar.opt(&#39;startParam&#39;);
    }
    endParam = this.endParam;
    if (endParam == null) {
        endParam = calendar.opt(&#39;endParam&#39;);
    }
    timezoneParam = this.timezoneParam;
    if (timezoneParam == null) {
        timezoneParam = calendar.opt(&#39;timezoneParam&#39;);
    }
    // retrieve any outbound GET/POST $.ajax data from the options
    if ($.isFunction(ajaxSettings.data)) {
        // supplied as a function that returns a key/value object
        customRequestParams = ajaxSettings.data();
    }
    else {
        // probably supplied as a straight key/value object
        customRequestParams = ajaxSettings.data || {};
    }
    $.extend(params, customRequestParams);
    params[startParam] = start.format();
    params[endParam] = end.format();
    if (timezone &amp;&amp; timezone !== &#39;local&#39;) {
        params[timezoneParam] = timezone;
    }
    return params;
};
JsonFeedEventSource.prototype.getPrimitive = function () {
    return this.url;
};
JsonFeedEventSource.prototype.applyMiscProps = function (rawProps) {
    this.ajaxSettings = rawProps;
};
JsonFeedEventSource.AJAX_DEFAULTS = {
    dataType: &#39;json&#39;,
    cache: false
};
return JsonFeedEventSource;</pre>

<p>}(EventSource_1.default)); exports.default = JsonFeedEventSource;
JsonFeedEventSource.defineStandardProps({</p>

<pre>// automatically transfer (true)...
url: true,
startParam: true,
endParam: true,
timezoneParam: true</pre>

<p>});</p>

<p>/***/ }), /* 217 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
EmitterMixin_1 = <em>webpack_require</em>(11); var TaskQueue = /** @class
*/ (function () {</p>

<pre>function TaskQueue() {
    this.q = [];
    this.isPaused = false;
    this.isRunning = false;
}
TaskQueue.prototype.queue = function () {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    this.q.push.apply(this.q, args); // append
    this.tryStart();
};
TaskQueue.prototype.pause = function () {
    this.isPaused = true;
};
TaskQueue.prototype.resume = function () {
    this.isPaused = false;
    this.tryStart();
};
TaskQueue.prototype.getIsIdle = function () {
    return !this.isRunning &amp;&amp; !this.isPaused;
};
TaskQueue.prototype.tryStart = function () {
    if (!this.isRunning &amp;&amp; this.canRunNext()) {
        this.isRunning = true;
        this.trigger(&#39;start&#39;);
        this.runRemaining();
    }
};
TaskQueue.prototype.canRunNext = function () {
    return !this.isPaused &amp;&amp; this.q.length;
};
TaskQueue.prototype.runRemaining = function () {
    var _this = this;
    var task;
    var res;
    do {
        task = this.q.shift(); // always freshly reference q. might have been reassigned.
        res = this.runTask(task);
        if (res &amp;&amp; res.then) {
            res.then(function () {
                if (_this.canRunNext()) {
                    _this.runRemaining();
                }
            });
            return; // prevent marking as stopped
        }
    } while (this.canRunNext());
    this.trigger(&#39;stop&#39;); // not really a &#39;stop&#39; ... more of a &#39;drained&#39;
    this.isRunning = false;
    // if &#39;stop&#39; handler added more tasks.... TODO: write test for this
    this.tryStart();
};
TaskQueue.prototype.runTask = function (task) {
    return task(); // task *is* the function, but subclasses can change the format of a task
};
return TaskQueue;</pre>

<p>}()); exports.default = TaskQueue;
EmitterMixin_1.default.mixInto(TaskQueue);</p>

<p>/***/ }), /* 218 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var TaskQueue_1 =
<em>webpack_require</em>(217); var RenderQueue = /** @class */ (function
(_super) {</p>

<pre>tslib_1.__extends(RenderQueue, _super);
function RenderQueue(waitsByNamespace) {
    var _this = _super.call(this) || this;
    _this.waitsByNamespace = waitsByNamespace || {};
    return _this;
}
RenderQueue.prototype.queue = function (taskFunc, namespace, type) {
    var task = {
        func: taskFunc,
        namespace: namespace,
        type: type
    };
    var waitMs;
    if (namespace) {
        waitMs = this.waitsByNamespace[namespace];
    }
    if (this.waitNamespace) {
        if (namespace === this.waitNamespace &amp;&amp; waitMs != null) {
            this.delayWait(waitMs);
        }
        else {
            this.clearWait();
            this.tryStart();
        }
    }
    if (this.compoundTask(task)) {
        if (!this.waitNamespace &amp;&amp; waitMs != null) {
            this.startWait(namespace, waitMs);
        }
        else {
            this.tryStart();
        }
    }
};
RenderQueue.prototype.startWait = function (namespace, waitMs) {
    this.waitNamespace = namespace;
    this.spawnWait(waitMs);
};
RenderQueue.prototype.delayWait = function (waitMs) {
    clearTimeout(this.waitId);
    this.spawnWait(waitMs);
};
RenderQueue.prototype.spawnWait = function (waitMs) {
    var _this = this;
    this.waitId = setTimeout(function () {
        _this.waitNamespace = null;
        _this.tryStart();
    }, waitMs);
};
RenderQueue.prototype.clearWait = function () {
    if (this.waitNamespace) {
        clearTimeout(this.waitId);
        this.waitId = null;
        this.waitNamespace = null;
    }
};
RenderQueue.prototype.canRunNext = function () {
    if (!_super.prototype.canRunNext.call(this)) {
        return false;
    }
    // waiting for a certain namespace to stop receiving tasks?
    if (this.waitNamespace) {
        var q = this.q;
        // if there was a different namespace task in the meantime,
        // that forces all previously-waiting tasks to suddenly execute.
        // TODO: find a way to do this in constant time.
        for (var i = 0; i &lt; q.length; i++) {
            if (q[i].namespace !== this.waitNamespace) {
                return true; // allow execution
            }
        }
        return false;
    }
    return true;
};
RenderQueue.prototype.runTask = function (task) {
    task.func();
};
RenderQueue.prototype.compoundTask = function (newTask) {
    var q = this.q;
    var shouldAppend = true;
    var i;
    var task;
    if (newTask.namespace &amp;&amp; newTask.type === &#39;destroy&#39;) {
        // remove all init/add/remove ops with same namespace, regardless of order
        for (i = q.length - 1; i &gt;= 0; i--) {
            task = q[i];
            switch (task.type) {
                case &#39;init&#39;:
                    shouldAppend = false;
                // the latest destroy is cancelled out by not doing the init
                /* falls through */
                case &#39;add&#39;:
                /* falls through */
                case &#39;remove&#39;:
                    q.splice(i, 1); // remove task
            }
        }
    }
    if (shouldAppend) {
        q.push(newTask);
    }
    return shouldAppend;
};
return RenderQueue;</pre>

<p>}(TaskQueue_1.default)); exports.default = RenderQueue;</p>

<p>/***/ }), /* 219 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
moment = <em>webpack_require</em>(0); var util_1 =
<em>webpack_require</em>(4); var moment_ext_1 =
<em>webpack_require</em>(10); var date_formatting_1 =
<em>webpack_require</em>(47); var Component_1 =
<em>webpack_require</em>(237); var util_2 = <em>webpack_require</em>(35);
var DateComponent = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(DateComponent, _super);
function DateComponent(_view, _options) {
    var _this = _super.call(this) || this;
    _this.isRTL = false; // frequently accessed options
    _this.hitsNeededDepth = 0; // necessary because multiple callers might need the same hits
    _this.hasAllDayBusinessHours = false; // TODO: unify with largeUnit and isTimeScale?
    _this.isDatesRendered = false;
    // hack to set options prior to the this.opt calls
    if (_view) {
        _this[&#39;view&#39;] = _view;
    }
    if (_options) {
        _this[&#39;options&#39;] = _options;
    }
    _this.uid = String(DateComponent.guid++);
    _this.childrenByUid = {};
    _this.nextDayThreshold = moment.duration(_this.opt(&#39;nextDayThreshold&#39;));
    _this.isRTL = _this.opt(&#39;isRTL&#39;);
    if (_this.fillRendererClass) {
        _this.fillRenderer = new _this.fillRendererClass(_this);
    }
    if (_this.eventRendererClass) {
        _this.eventRenderer = new _this.eventRendererClass(_this, _this.fillRenderer);
    }
    if (_this.helperRendererClass &amp;&amp; _this.eventRenderer) {
        _this.helperRenderer = new _this.helperRendererClass(_this, _this.eventRenderer);
    }
    if (_this.businessHourRendererClass &amp;&amp; _this.fillRenderer) {
        _this.businessHourRenderer = new _this.businessHourRendererClass(_this, _this.fillRenderer);
    }
    return _this;
}
DateComponent.prototype.addChild = function (child) {
    if (!this.childrenByUid[child.uid]) {
        this.childrenByUid[child.uid] = child;
        return true;
    }
    return false;
};
DateComponent.prototype.removeChild = function (child) {
    if (this.childrenByUid[child.uid]) {
        delete this.childrenByUid[child.uid];
        return true;
    }
    return false;
};
// TODO: only do if isInDom?
// TODO: make part of Component, along with children/batch-render system?
DateComponent.prototype.updateSize = function (totalHeight, isAuto, isResize) {
    this.callChildren(&#39;updateSize&#39;, arguments);
};
// Options
// -----------------------------------------------------------------------------------------------------------------
DateComponent.prototype.opt = function (name) {
    return this._getView().opt(name); // default implementation
};
DateComponent.prototype.publiclyTrigger = function () {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var calendar = this._getCalendar();
    return calendar.publiclyTrigger.apply(calendar, args);
};
DateComponent.prototype.hasPublicHandlers = function () {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var calendar = this._getCalendar();
    return calendar.hasPublicHandlers.apply(calendar, args);
};
// Date
// -----------------------------------------------------------------------------------------------------------------
DateComponent.prototype.executeDateRender = function (dateProfile) {
    this.dateProfile = dateProfile; // for rendering
    this.renderDates(dateProfile);
    this.isDatesRendered = true;
    this.callChildren(&#39;executeDateRender&#39;, arguments);
};
DateComponent.prototype.executeDateUnrender = function () {
    this.callChildren(&#39;executeDateUnrender&#39;, arguments);
    this.dateProfile = null;
    this.unrenderDates();
    this.isDatesRendered = false;
};
// date-cell content only
DateComponent.prototype.renderDates = function (dateProfile) {
    // subclasses should implement
};
// date-cell content only
DateComponent.prototype.unrenderDates = function () {
    // subclasses should override
};
// Now-Indicator
// -----------------------------------------------------------------------------------------------------------------
// Returns a string unit, like &#39;second&#39; or &#39;minute&#39; that defined how often the current time indicator
// should be refreshed. If something falsy is returned, no time indicator is rendered at all.
DateComponent.prototype.getNowIndicatorUnit = function () {
    // subclasses should implement
};
// Renders a current time indicator at the given datetime
DateComponent.prototype.renderNowIndicator = function (date) {
    this.callChildren(&#39;renderNowIndicator&#39;, arguments);
};
// Undoes the rendering actions from renderNowIndicator
DateComponent.prototype.unrenderNowIndicator = function () {
    this.callChildren(&#39;unrenderNowIndicator&#39;, arguments);
};
// Business Hours
// ---------------------------------------------------------------------------------------------------------------
DateComponent.prototype.renderBusinessHours = function (businessHourGenerator) {
    if (this.businessHourRenderer) {
        this.businessHourRenderer.render(businessHourGenerator);
    }
    this.callChildren(&#39;renderBusinessHours&#39;, arguments);
};
// Unrenders previously-rendered business-hours
DateComponent.prototype.unrenderBusinessHours = function () {
    this.callChildren(&#39;unrenderBusinessHours&#39;, arguments);
    if (this.businessHourRenderer) {
        this.businessHourRenderer.unrender();
    }
};
// Event Displaying
// -----------------------------------------------------------------------------------------------------------------
DateComponent.prototype.executeEventRender = function (eventsPayload) {
    if (this.eventRenderer) {
        this.eventRenderer.rangeUpdated(); // poorly named now
        this.eventRenderer.render(eventsPayload);
    }
    else if (this[&#39;renderEvents&#39;]) {
        this[&#39;renderEvents&#39;](convertEventsPayloadToLegacyArray(eventsPayload));
    }
    this.callChildren(&#39;executeEventRender&#39;, arguments);
};
DateComponent.prototype.executeEventUnrender = function () {
    this.callChildren(&#39;executeEventUnrender&#39;, arguments);
    if (this.eventRenderer) {
        this.eventRenderer.unrender();
    }
    else if (this[&#39;destroyEvents&#39;]) {
        this[&#39;destroyEvents&#39;]();
    }
};
DateComponent.prototype.getBusinessHourSegs = function () {
    var segs = this.getOwnBusinessHourSegs();
    this.iterChildren(function (child) {
        segs.push.apply(segs, child.getBusinessHourSegs());
    });
    return segs;
};
DateComponent.prototype.getOwnBusinessHourSegs = function () {
    if (this.businessHourRenderer) {
        return this.businessHourRenderer.getSegs();
    }
    return [];
};
DateComponent.prototype.getEventSegs = function () {
    var segs = this.getOwnEventSegs();
    this.iterChildren(function (child) {
        segs.push.apply(segs, child.getEventSegs());
    });
    return segs;
};
DateComponent.prototype.getOwnEventSegs = function () {
    if (this.eventRenderer) {
        return this.eventRenderer.getSegs();
    }
    return [];
};
// Event Rendering Triggering
// -----------------------------------------------------------------------------------------------------------------
DateComponent.prototype.triggerAfterEventsRendered = function () {
    this.triggerAfterEventSegsRendered(this.getEventSegs());
    this.publiclyTrigger(&#39;eventAfterAllRender&#39;, {
        context: this,
        args: [this]
    });
};
DateComponent.prototype.triggerAfterEventSegsRendered = function (segs) {
    var _this = this;
    // an optimization, because getEventLegacy is expensive
    if (this.hasPublicHandlers(&#39;eventAfterRender&#39;)) {
        segs.forEach(function (seg) {
            var legacy;
            if (seg.el) {
                legacy = seg.footprint.getEventLegacy();
                _this.publiclyTrigger(&#39;eventAfterRender&#39;, {
                    context: legacy,
                    args: [legacy, seg.el, _this]
                });
            }
        });
    }
};
DateComponent.prototype.triggerBeforeEventsDestroyed = function () {
    this.triggerBeforeEventSegsDestroyed(this.getEventSegs());
};
DateComponent.prototype.triggerBeforeEventSegsDestroyed = function (segs) {
    var _this = this;
    if (this.hasPublicHandlers(&#39;eventDestroy&#39;)) {
        segs.forEach(function (seg) {
            var legacy;
            if (seg.el) {
                legacy = seg.footprint.getEventLegacy();
                _this.publiclyTrigger(&#39;eventDestroy&#39;, {
                    context: legacy,
                    args: [legacy, seg.el, _this]
                });
            }
        });
    }
};
// Event Rendering Utils
// -----------------------------------------------------------------------------------------------------------------
// Hides all rendered event segments linked to the given event
// RECURSIVE with subcomponents
DateComponent.prototype.showEventsWithId = function (eventDefId) {
    this.getEventSegs().forEach(function (seg) {
        if (seg.footprint.eventDef.id === eventDefId &amp;&amp;
            seg.el // necessary?
        ) {
            seg.el.css(&#39;visibility&#39;, &#39;&#39;);
        }
    });
    this.callChildren(&#39;showEventsWithId&#39;, arguments);
};
// Shows all rendered event segments linked to the given event
// RECURSIVE with subcomponents
DateComponent.prototype.hideEventsWithId = function (eventDefId) {
    this.getEventSegs().forEach(function (seg) {
        if (seg.footprint.eventDef.id === eventDefId &amp;&amp;
            seg.el // necessary?
        ) {
            seg.el.css(&#39;visibility&#39;, &#39;hidden&#39;);
        }
    });
    this.callChildren(&#39;hideEventsWithId&#39;, arguments);
};
// Drag-n-Drop Rendering (for both events and external elements)
// ---------------------------------------------------------------------------------------------------------------
// Renders a visual indication of a event or external-element drag over the given drop zone.
// If an external-element, seg will be `null`.
// Must return elements used for any mock events.
DateComponent.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
    var renderedHelper = false;
    this.iterChildren(function (child) {
        if (child.renderDrag(eventFootprints, seg, isTouch)) {
            renderedHelper = true;
        }
    });
    return renderedHelper;
};
// Unrenders a visual indication of an event or external-element being dragged.
DateComponent.prototype.unrenderDrag = function () {
    this.callChildren(&#39;unrenderDrag&#39;, arguments);
};
// Event Resizing
// ---------------------------------------------------------------------------------------------------------------
// Renders a visual indication of an event being resized.
DateComponent.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
    this.callChildren(&#39;renderEventResize&#39;, arguments);
};
// Unrenders a visual indication of an event being resized.
DateComponent.prototype.unrenderEventResize = function () {
    this.callChildren(&#39;unrenderEventResize&#39;, arguments);
};
// Selection
// ---------------------------------------------------------------------------------------------------------------
// Renders a visual indication of the selection
// TODO: rename to `renderSelection` after legacy is gone
DateComponent.prototype.renderSelectionFootprint = function (componentFootprint) {
    this.renderHighlight(componentFootprint);
    this.callChildren(&#39;renderSelectionFootprint&#39;, arguments);
};
// Unrenders a visual indication of selection
DateComponent.prototype.unrenderSelection = function () {
    this.unrenderHighlight();
    this.callChildren(&#39;unrenderSelection&#39;, arguments);
};
// Highlight
// ---------------------------------------------------------------------------------------------------------------
// Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
DateComponent.prototype.renderHighlight = function (componentFootprint) {
    if (this.fillRenderer) {
        this.fillRenderer.renderFootprint(&#39;highlight&#39;, componentFootprint, {
            getClasses: function () {
                return [&#39;fc-highlight&#39;];
            }
        });
    }
    this.callChildren(&#39;renderHighlight&#39;, arguments);
};
// Unrenders the emphasis on a date range
DateComponent.prototype.unrenderHighlight = function () {
    if (this.fillRenderer) {
        this.fillRenderer.unrender(&#39;highlight&#39;);
    }
    this.callChildren(&#39;unrenderHighlight&#39;, arguments);
};
// Hit Areas
// ---------------------------------------------------------------------------------------------------------------
// just because all DateComponents support this interface
// doesn&#39;t mean they need to have their own internal coord system. they can defer to sub-components.
DateComponent.prototype.hitsNeeded = function () {
    if (!(this.hitsNeededDepth++)) {
        this.prepareHits();
    }
    this.callChildren(&#39;hitsNeeded&#39;, arguments);
};
DateComponent.prototype.hitsNotNeeded = function () {
    if (this.hitsNeededDepth &amp;&amp; !(--this.hitsNeededDepth)) {
        this.releaseHits();
    }
    this.callChildren(&#39;hitsNotNeeded&#39;, arguments);
};
DateComponent.prototype.prepareHits = function () {
    // subclasses can implement
};
DateComponent.prototype.releaseHits = function () {
    // subclasses can implement
};
// Given coordinates from the topleft of the document, return data about the date-related area underneath.
// Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
// Must have a `grid` property, a reference to this current grid. TODO: avoid this
// The returned object will be processed by getHitFootprint and getHitEl.
DateComponent.prototype.queryHit = function (leftOffset, topOffset) {
    var childrenByUid = this.childrenByUid;
    var uid;
    var hit;
    for (uid in childrenByUid) {
        hit = childrenByUid[uid].queryHit(leftOffset, topOffset);
        if (hit) {
            break;
        }
    }
    return hit;
};
DateComponent.prototype.getSafeHitFootprint = function (hit) {
    var footprint = this.getHitFootprint(hit);
    if (!this.dateProfile.activeUnzonedRange.containsRange(footprint.unzonedRange)) {
        return null;
    }
    return footprint;
};
DateComponent.prototype.getHitFootprint = function (hit) {
    // what about being abstract!?
};
// Given position-level information about a date-related area within the grid,
// should return a jQuery element that best represents it. passed to dayClick callback.
DateComponent.prototype.getHitEl = function (hit) {
    // what about being abstract!?
};
/* Converting eventRange -&gt; eventFootprint
------------------------------------------------------------------------------------------------------------------*/
DateComponent.prototype.eventRangesToEventFootprints = function (eventRanges) {
    var eventFootprints = [];
    var i;
    for (i = 0; i &lt; eventRanges.length; i++) {
        eventFootprints.push.apply(// append
        eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));
    }
    return eventFootprints;
};
DateComponent.prototype.eventRangeToEventFootprints = function (eventRange) {
    return [util_2.eventRangeToEventFootprint(eventRange)];
};
/* Converting componentFootprint/eventFootprint -&gt; segs
------------------------------------------------------------------------------------------------------------------*/
DateComponent.prototype.eventFootprintsToSegs = function (eventFootprints) {
    var segs = [];
    var i;
    for (i = 0; i &lt; eventFootprints.length; i++) {
        segs.push.apply(segs, this.eventFootprintToSegs(eventFootprints[i]));
    }
    return segs;
};
// Given an event&#39;s span (unzoned start/end and other misc data), and the event itself,
// slices into segments and attaches event-derived properties to them.
// eventSpan - { start, end, isStart, isEnd, otherthings... }
DateComponent.prototype.eventFootprintToSegs = function (eventFootprint) {
    var unzonedRange = eventFootprint.componentFootprint.unzonedRange;
    var segs;
    var i;
    var seg;
    segs = this.componentFootprintToSegs(eventFootprint.componentFootprint);
    for (i = 0; i &lt; segs.length; i++) {
        seg = segs[i];
        if (!unzonedRange.isStart) {
            seg.isStart = false;
        }
        if (!unzonedRange.isEnd) {
            seg.isEnd = false;
        }
        seg.footprint = eventFootprint;
        // TODO: rename to seg.eventFootprint
    }
    return segs;
};
DateComponent.prototype.componentFootprintToSegs = function (componentFootprint) {
    return [];
};
// Utils
// ---------------------------------------------------------------------------------------------------------------
DateComponent.prototype.callChildren = function (methodName, args) {
    this.iterChildren(function (child) {
        child[methodName].apply(child, args);
    });
};
DateComponent.prototype.iterChildren = function (func) {
    var childrenByUid = this.childrenByUid;
    var uid;
    for (uid in childrenByUid) {
        func(childrenByUid[uid]);
    }
};
DateComponent.prototype._getCalendar = function () {
    var t = this;
    return t.calendar || t.view.calendar;
};
DateComponent.prototype._getView = function () {
    return this.view;
};
DateComponent.prototype._getDateProfile = function () {
    return this._getView().get(&#39;dateProfile&#39;);
};
// Generates HTML for an anchor to another view into the calendar.
// Will either generate an &lt;a&gt; tag or a non-clickable &lt;span&gt; tag, depending on enabled settings.
// `gotoOptions` can either be a moment input, or an object with the form:
// { date, type, forceOff }
// `type` is a view-type like &quot;day&quot; or &quot;week&quot;. default value is &quot;day&quot;.
// `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
DateComponent.prototype.buildGotoAnchorHtml = function (gotoOptions, attrs, innerHtml) {
    var date;
    var type;
    var forceOff;
    var finalOptions;
    if ($.isPlainObject(gotoOptions)) {
        date = gotoOptions.date;
        type = gotoOptions.type;
        forceOff = gotoOptions.forceOff;
    }
    else {
        date = gotoOptions; // a single moment input
    }
    date = moment_ext_1.default(date); // if a string, parse it
    finalOptions = {
        date: date.format(&#39;YYYY-MM-DD&#39;),
        type: type || &#39;day&#39;
    };
    if (typeof attrs === &#39;string&#39;) {
        innerHtml = attrs;
        attrs = null;
    }
    attrs = attrs ? &#39; &#39; + util_1.attrsToStr(attrs) : &#39;&#39;; // will have a leading space
    innerHtml = innerHtml || &#39;&#39;;
    if (!forceOff &amp;&amp; this.opt(&#39;navLinks&#39;)) {
        return &#39;&lt;a&#39; + attrs +
            &#39; data-goto=&quot;&#39; + util_1.htmlEscape(JSON.stringify(finalOptions)) + &#39;&quot;&gt;&#39; +
            innerHtml +
            &#39;&lt;/a&gt;&#39;;
    }
    else {
        return &#39;&lt;span&#39; + attrs + &#39;&gt;&#39; +
            innerHtml +
            &#39;&lt;/span&gt;&#39;;
    }
};
DateComponent.prototype.getAllDayHtml = function () {
    return this.opt(&#39;allDayHtml&#39;) || util_1.htmlEscape(this.opt(&#39;allDayText&#39;));
};
// Computes HTML classNames for a single-day element
DateComponent.prototype.getDayClasses = function (date, noThemeHighlight) {
    var view = this._getView();
    var classes = [];
    var today;
    if (!this.dateProfile.activeUnzonedRange.containsDate(date)) {
        classes.push(&#39;fc-disabled-day&#39;); // TODO: jQuery UI theme?
    }
    else {
        classes.push(&#39;fc-&#39; + util_1.dayIDs[date.day()]);
        if (view.isDateInOtherMonth(date, this.dateProfile)) {
            classes.push(&#39;fc-other-month&#39;);
        }
        today = view.calendar.getNow();
        if (date.isSame(today, &#39;day&#39;)) {
            classes.push(&#39;fc-today&#39;);
            if (noThemeHighlight !== true) {
                classes.push(view.calendar.theme.getClass(&#39;today&#39;));
            }
        }
        else if (date &lt; today) {
            classes.push(&#39;fc-past&#39;);
        }
        else {
            classes.push(&#39;fc-future&#39;);
        }
    }
    return classes;
};
// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
// The timezones of the dates within `range` will be respected.
DateComponent.prototype.formatRange = function (range, isAllDay, formatStr, separator) {
    var end = range.end;
    if (isAllDay) {
        end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
    }
    return date_formatting_1.formatRange(range.start, end, formatStr, separator, this.isRTL);
};
// Compute the number of the give units in the &quot;current&quot; range.
// Will return a floating-point number. Won&#39;t round.
DateComponent.prototype.currentRangeAs = function (unit) {
    return this._getDateProfile().currentUnzonedRange.as(unit);
};
// Returns the date range of the full days the given range visually appears to occupy.
// Returns a plain object with start/end, NOT an UnzonedRange!
DateComponent.prototype.computeDayRange = function (unzonedRange) {
    var calendar = this._getCalendar();
    var startDay = calendar.msToUtcMoment(unzonedRange.startMs, true); // the beginning of the day the range starts
    var end = calendar.msToUtcMoment(unzonedRange.endMs);
    var endTimeMS = +end.time(); // # of milliseconds into `endDay`
    var endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
    // If the end time is actually inclusively part of the next day and is equal to or
    // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
    // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
    if (endTimeMS &amp;&amp; endTimeMS &gt;= this.nextDayThreshold) {
        endDay.add(1, &#39;days&#39;);
    }
    // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.
    if (endDay &lt;= startDay) {
        endDay = startDay.clone().add(1, &#39;days&#39;);
    }
    return { start: startDay, end: endDay };
};
// Does the given range visually appear to occupy more than one day?
DateComponent.prototype.isMultiDayRange = function (unzonedRange) {
    var dayRange = this.computeDayRange(unzonedRange);
    return dayRange.end.diff(dayRange.start, &#39;days&#39;) &gt; 1;
};
DateComponent.guid = 0; // TODO: better system for this?
return DateComponent;</pre>

<p>}(Component_1.default)); exports.default = DateComponent; // legacy
function convertEventsPayloadToLegacyArray(eventsPayload) {</p>

<pre>var eventDefId;
var eventInstances;
var legacyEvents = [];
var i;
for (eventDefId in eventsPayload) {
    eventInstances = eventsPayload[eventDefId].eventInstances;
    for (i = 0; i &lt; eventInstances.length; i++) {
        legacyEvents.push(eventInstances[i].toLegacy());
    }
}
return legacyEvents;</pre>

<p>}</p>

<p>/***/ }), /* 220 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var moment = <em>webpack_require</em>(0); var
util_1 = <em>webpack_require</em>(4); var options_1 =
<em>webpack_require</em>(32); var Iterator_1 =
<em>webpack_require</em>(238); var GlobalEmitter_1 =
<em>webpack_require</em>(21); var EmitterMixin_1 =
<em>webpack_require</em>(11); var ListenerMixin_1 =
<em>webpack_require</em>(7); var Toolbar_1 = <em>webpack_require</em>(239);
var OptionsManager_1 = <em>webpack_require</em>(240); var ViewSpecManager_1
= <em>webpack_require</em>(241); var Constraints_1 =
<em>webpack_require</em>(207); var locale_1 = <em>webpack_require</em>(31);
var moment_ext_1 = <em>webpack_require</em>(10); var UnzonedRange_1 =
<em>webpack_require</em>(5); var ComponentFootprint_1 =
<em>webpack_require</em>(12); var EventDateProfile_1 =
<em>webpack_require</em>(17); var EventManager_1 =
<em>webpack_require</em>(242); var BusinessHourGenerator_1 =
<em>webpack_require</em>(212); var EventSourceParser_1 =
<em>webpack_require</em>(38); var EventDefParser_1 =
<em>webpack_require</em>(49); var SingleEventDef_1 =
<em>webpack_require</em>(13); var EventDefMutation_1 =
<em>webpack_require</em>(37); var EventSource_1 =
<em>webpack_require</em>(6); var ThemeRegistry_1 =
<em>webpack_require</em>(51); var Calendar = /** @class */ (function () {</p>

<pre>function Calendar(el, overrides) {
    this.loadingLevel = 0; // number of simultaneous loading tasks
    this.ignoreUpdateViewSize = 0;
    this.freezeContentHeightDepth = 0;
    // declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.
    // unneeded() is called in destroy.
    GlobalEmitter_1.default.needed();
    this.el = el;
    this.viewsByType = {};
    this.optionsManager = new OptionsManager_1.default(this, overrides);
    this.viewSpecManager = new ViewSpecManager_1.default(this.optionsManager, this);
    this.initMomentInternals(); // needs to happen after options hash initialized
    this.initCurrentDate();
    this.initEventManager();
    this.constraints = new Constraints_1.default(this.eventManager, this);
    this.constructed();
}
Calendar.prototype.constructed = function () {
    // useful for monkeypatching. used?
};
Calendar.prototype.getView = function () {
    return this.view;
};
Calendar.prototype.publiclyTrigger = function (name, triggerInfo) {
    var optHandler = this.opt(name);
    var context;
    var args;
    if ($.isPlainObject(triggerInfo)) {
        context = triggerInfo.context;
        args = triggerInfo.args;
    }
    else if ($.isArray(triggerInfo)) {
        args = triggerInfo;
    }
    if (context == null) {
        context = this.el[0]; // fallback context
    }
    if (!args) {
        args = [];
    }
    this.triggerWith(name, context, args); // Emitter&#39;s method
    if (optHandler) {
        return optHandler.apply(context, args);
    }
};
Calendar.prototype.hasPublicHandlers = function (name) {
    return this.hasHandlers(name) ||
        this.opt(name); // handler specified in options
};
// Options Public API
// -----------------------------------------------------------------------------------------------------------------
// public getter/setter
Calendar.prototype.option = function (name, value) {
    var newOptionHash;
    if (typeof name === &#39;string&#39;) {
        if (value === undefined) {
            return this.optionsManager.get(name);
        }
        else {
            newOptionHash = {};
            newOptionHash[name] = value;
            this.optionsManager.add(newOptionHash);
        }
    }
    else if (typeof name === &#39;object&#39;) {
        this.optionsManager.add(name);
    }
};
// private getter
Calendar.prototype.opt = function (name) {
    return this.optionsManager.get(name);
};
// View
// -----------------------------------------------------------------------------------------------------------------
// Given a view name for a custom view or a standard view, creates a ready-to-go View object
Calendar.prototype.instantiateView = function (viewType) {
    var spec = this.viewSpecManager.getViewSpec(viewType);
    if (!spec) {
        throw new Error(&quot;View type \&quot;&quot; + viewType + &quot;\&quot; is not valid&quot;);
    }
    return new spec[&#39;class&#39;](this, spec);
};
// Returns a boolean about whether the view is okay to instantiate at some point
Calendar.prototype.isValidViewType = function (viewType) {
    return Boolean(this.viewSpecManager.getViewSpec(viewType));
};
Calendar.prototype.changeView = function (viewName, dateOrRange) {
    if (dateOrRange) {
        if (dateOrRange.start &amp;&amp; dateOrRange.end) {
            this.optionsManager.recordOverrides({
                visibleRange: dateOrRange
            });
        }
        else {
            this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate
        }
    }
    this.renderView(viewName);
};
// Forces navigation to a view for the given date.
// `viewType` can be a specific view name or a generic one like &quot;week&quot; or &quot;day&quot;.
Calendar.prototype.zoomTo = function (newDate, viewType) {
    var spec;
    viewType = viewType || &#39;day&#39;; // day is default zoom
    spec = this.viewSpecManager.getViewSpec(viewType) ||
        this.viewSpecManager.getUnitViewSpec(viewType);
    this.currentDate = newDate.clone();
    this.renderView(spec ? spec.type : null);
};
// Current Date
// -----------------------------------------------------------------------------------------------------------------
Calendar.prototype.initCurrentDate = function () {
    var defaultDateInput = this.opt(&#39;defaultDate&#39;);
    // compute the initial ambig-timezone date
    if (defaultDateInput != null) {
        this.currentDate = this.moment(defaultDateInput).stripZone();
    }
    else {
        this.currentDate = this.getNow(); // getNow already returns unzoned
    }
};
Calendar.prototype.prev = function () {
    var view = this.view;
    var prevInfo = view.dateProfileGenerator.buildPrev(view.get(&#39;dateProfile&#39;));
    if (prevInfo.isValid) {
        this.currentDate = prevInfo.date;
        this.renderView();
    }
};
Calendar.prototype.next = function () {
    var view = this.view;
    var nextInfo = view.dateProfileGenerator.buildNext(view.get(&#39;dateProfile&#39;));
    if (nextInfo.isValid) {
        this.currentDate = nextInfo.date;
        this.renderView();
    }
};
Calendar.prototype.prevYear = function () {
    this.currentDate.add(-1, &#39;years&#39;);
    this.renderView();
};
Calendar.prototype.nextYear = function () {
    this.currentDate.add(1, &#39;years&#39;);
    this.renderView();
};
Calendar.prototype.today = function () {
    this.currentDate = this.getNow(); // should deny like prev/next?
    this.renderView();
};
Calendar.prototype.gotoDate = function (zonedDateInput) {
    this.currentDate = this.moment(zonedDateInput).stripZone();
    this.renderView();
};
Calendar.prototype.incrementDate = function (delta) {
    this.currentDate.add(moment.duration(delta));
    this.renderView();
};
// for external API
Calendar.prototype.getDate = function () {
    return this.applyTimezone(this.currentDate); // infuse the calendar&#39;s timezone
};
// Loading Triggering
// -----------------------------------------------------------------------------------------------------------------
// Should be called when any type of async data fetching begins
Calendar.prototype.pushLoading = function () {
    if (!(this.loadingLevel++)) {
        this.publiclyTrigger(&#39;loading&#39;, [true, this.view]);
    }
};
// Should be called when any type of async data fetching completes
Calendar.prototype.popLoading = function () {
    if (!(--this.loadingLevel)) {
        this.publiclyTrigger(&#39;loading&#39;, [false, this.view]);
    }
};
// High-level Rendering
// -----------------------------------------------------------------------------------
Calendar.prototype.render = function () {
    if (!this.contentEl) {
        this.initialRender();
    }
    else if (this.elementVisible()) {
        // mainly for the public API
        this.calcSize();
        this.updateViewSize();
    }
};
Calendar.prototype.initialRender = function () {
    var _this = this;
    var el = this.el;
    el.addClass(&#39;fc&#39;);
    // event delegation for nav links
    el.on(&#39;click.fc&#39;, &#39;a[data-goto]&#39;, function (ev) {
        var anchorEl = $(ev.currentTarget);
        var gotoOptions = anchorEl.data(&#39;goto&#39;); // will automatically parse JSON
        var date = _this.moment(gotoOptions.date);
        var viewType = gotoOptions.type;
        // property like &quot;navLinkDayClick&quot;. might be a string or a function
        var customAction = _this.view.opt(&#39;navLink&#39; + util_1.capitaliseFirstLetter(viewType) + &#39;Click&#39;);
        if (typeof customAction === &#39;function&#39;) {
            customAction(date, ev);
        }
        else {
            if (typeof customAction === &#39;string&#39;) {
                viewType = customAction;
            }
            _this.zoomTo(date, viewType);
        }
    });
    // called immediately, and upon option change
    this.optionsManager.watch(&#39;settingTheme&#39;, [&#39;?theme&#39;, &#39;?themeSystem&#39;], function (opts) {
        var themeClass = ThemeRegistry_1.getThemeSystemClass(opts.themeSystem || opts.theme);
        var theme = new themeClass(_this.optionsManager);
        var widgetClass = theme.getClass(&#39;widget&#39;);
        _this.theme = theme;
        if (widgetClass) {
            el.addClass(widgetClass);
        }
    }, function () {
        var widgetClass = _this.theme.getClass(&#39;widget&#39;);
        _this.theme = null;
        if (widgetClass) {
            el.removeClass(widgetClass);
        }
    });
    this.optionsManager.watch(&#39;settingBusinessHourGenerator&#39;, [&#39;?businessHours&#39;], function (deps) {
        _this.businessHourGenerator = new BusinessHourGenerator_1.default(deps.businessHours, _this);
        if (_this.view) {
            _this.view.set(&#39;businessHourGenerator&#39;, _this.businessHourGenerator);
        }
    }, function () {
        _this.businessHourGenerator = null;
    });
    // called immediately, and upon option change.
    // HACK: locale often affects isRTL, so we explicitly listen to that too.
    this.optionsManager.watch(&#39;applyingDirClasses&#39;, [&#39;?isRTL&#39;, &#39;?locale&#39;], function (opts) {
        el.toggleClass(&#39;fc-ltr&#39;, !opts.isRTL);
        el.toggleClass(&#39;fc-rtl&#39;, opts.isRTL);
    });
    this.contentEl = $(&quot;&lt;div class=&#39;fc-view-container&#39;/&gt;&quot;).prependTo(el);
    this.initToolbars();
    this.renderHeader();
    this.renderFooter();
    this.renderView(this.opt(&#39;defaultView&#39;));
    if (this.opt(&#39;handleWindowResize&#39;)) {
        $(window).resize(this.windowResizeProxy = util_1.debounce(// prevents rapid calls
        this.windowResize.bind(this), this.opt(&#39;windowResizeDelay&#39;)));
    }
};
Calendar.prototype.destroy = function () {
    if (this.view) {
        this.clearView();
    }
    this.toolbarsManager.proxyCall(&#39;removeElement&#39;);
    this.contentEl.remove();
    this.el.removeClass(&#39;fc fc-ltr fc-rtl&#39;);
    // removes theme-related root className
    this.optionsManager.unwatch(&#39;settingTheme&#39;);
    this.optionsManager.unwatch(&#39;settingBusinessHourGenerator&#39;);
    this.el.off(&#39;.fc&#39;); // unbind nav link handlers
    if (this.windowResizeProxy) {
        $(window).unbind(&#39;resize&#39;, this.windowResizeProxy);
        this.windowResizeProxy = null;
    }
    GlobalEmitter_1.default.unneeded();
};
Calendar.prototype.elementVisible = function () {
    return this.el.is(&#39;:visible&#39;);
};
// Render Queue
// -----------------------------------------------------------------------------------------------------------------
Calendar.prototype.bindViewHandlers = function (view) {
    var _this = this;
    view.watch(&#39;titleForCalendar&#39;, [&#39;title&#39;], function (deps) {
        if (view === _this.view) {
            _this.setToolbarsTitle(deps.title);
        }
    });
    view.watch(&#39;dateProfileForCalendar&#39;, [&#39;dateProfile&#39;], function (deps) {
        if (view === _this.view) {
            _this.currentDate = deps.dateProfile.date; // might have been constrained by view dates
            _this.updateToolbarButtons(deps.dateProfile);
        }
    });
};
Calendar.prototype.unbindViewHandlers = function (view) {
    view.unwatch(&#39;titleForCalendar&#39;);
    view.unwatch(&#39;dateProfileForCalendar&#39;);
};
// View Rendering
// -----------------------------------------------------------------------------------
// Renders a view because of a date change, view-type change, or for the first time.
// If not given a viewType, keep the current view but render different dates.
// Accepts an optional scroll state to restore to.
Calendar.prototype.renderView = function (viewType) {
    var oldView = this.view;
    var newView;
    this.freezeContentHeight();
    if (oldView &amp;&amp; viewType &amp;&amp; oldView.type !== viewType) {
        this.clearView();
    }
    // if viewType changed, or the view was never created, create a fresh view
    if (!this.view &amp;&amp; viewType) {
        newView = this.view =
            this.viewsByType[viewType] ||
                (this.viewsByType[viewType] = this.instantiateView(viewType));
        this.bindViewHandlers(newView);
        newView.startBatchRender(); // so that setElement+setDate rendering are joined
        newView.setElement($(&quot;&lt;div class=&#39;fc-view fc-&quot; + viewType + &quot;-view&#39; /&gt;&quot;).appendTo(this.contentEl));
        this.toolbarsManager.proxyCall(&#39;activateButton&#39;, viewType);
    }
    if (this.view) {
        // prevent unnecessary change firing
        if (this.view.get(&#39;businessHourGenerator&#39;) !== this.businessHourGenerator) {
            this.view.set(&#39;businessHourGenerator&#39;, this.businessHourGenerator);
        }
        this.view.setDate(this.currentDate);
        if (newView) {
            newView.stopBatchRender();
        }
    }
    this.thawContentHeight();
};
// Unrenders the current view and reflects this change in the Header.
// Unregsiters the `view`, but does not remove from viewByType hash.
Calendar.prototype.clearView = function () {
    var currentView = this.view;
    this.toolbarsManager.proxyCall(&#39;deactivateButton&#39;, currentView.type);
    this.unbindViewHandlers(currentView);
    currentView.removeElement();
    currentView.unsetDate(); // so bindViewHandlers doesn&#39;t fire with old values next time
    this.view = null;
};
// Destroys the view, including the view object. Then, re-instantiates it and renders it.
// Maintains the same scroll state.
// TODO: maintain any other user-manipulated state.
Calendar.prototype.reinitView = function () {
    var oldView = this.view;
    var scroll = oldView.queryScroll(); // wouldn&#39;t be so complicated if Calendar owned the scroll
    this.freezeContentHeight();
    this.clearView();
    this.calcSize();
    this.renderView(oldView.type); // needs the type to freshly render
    this.view.applyScroll(scroll);
    this.thawContentHeight();
};
// Resizing
// -----------------------------------------------------------------------------------
Calendar.prototype.getSuggestedViewHeight = function () {
    if (this.suggestedViewHeight == null) {
        this.calcSize();
    }
    return this.suggestedViewHeight;
};
Calendar.prototype.isHeightAuto = function () {
    return this.opt(&#39;contentHeight&#39;) === &#39;auto&#39; || this.opt(&#39;height&#39;) === &#39;auto&#39;;
};
Calendar.prototype.updateViewSize = function (isResize) {
    if (isResize === void 0) { isResize = false; }
    var view = this.view;
    var scroll;
    if (!this.ignoreUpdateViewSize &amp;&amp; view) {
        if (isResize) {
            this.calcSize();
            scroll = view.queryScroll();
        }
        this.ignoreUpdateViewSize++;
        view.updateSize(this.getSuggestedViewHeight(), this.isHeightAuto(), isResize);
        this.ignoreUpdateViewSize--;
        if (isResize) {
            view.applyScroll(scroll);
        }
        return true; // signal success
    }
};
Calendar.prototype.calcSize = function () {
    if (this.elementVisible()) {
        this._calcSize();
    }
};
Calendar.prototype._calcSize = function () {
    var contentHeightInput = this.opt(&#39;contentHeight&#39;);
    var heightInput = this.opt(&#39;height&#39;);
    if (typeof contentHeightInput === &#39;number&#39;) {
        this.suggestedViewHeight = contentHeightInput;
    }
    else if (typeof contentHeightInput === &#39;function&#39;) {
        this.suggestedViewHeight = contentHeightInput();
    }
    else if (typeof heightInput === &#39;number&#39;) {
        this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();
    }
    else if (typeof heightInput === &#39;function&#39;) {
        this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();
    }
    else if (heightInput === &#39;parent&#39;) {
        this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();
    }
    else {
        this.suggestedViewHeight = Math.round(this.contentEl.width() /
            Math.max(this.opt(&#39;aspectRatio&#39;), .5));
    }
};
Calendar.prototype.windowResize = function (ev) {
    if (
    // the purpose: so we don&#39;t process jqui &quot;resize&quot; events that have bubbled up
    // cast to any because .target, which is Element, can&#39;t be compared to window for some reason.
    ev.target === window &amp;&amp;
        this.view &amp;&amp;
        this.view.isDatesRendered) {
        if (this.updateViewSize(true)) {
            this.publiclyTrigger(&#39;windowResize&#39;, [this.view]);
        }
    }
};
/* Height &quot;Freezing&quot;
-----------------------------------------------------------------------------*/
Calendar.prototype.freezeContentHeight = function () {
    if (!(this.freezeContentHeightDepth++)) {
        this.forceFreezeContentHeight();
    }
};
Calendar.prototype.forceFreezeContentHeight = function () {
    this.contentEl.css({
        width: &#39;100%&#39;,
        height: this.contentEl.height(),
        overflow: &#39;hidden&#39;
    });
};
Calendar.prototype.thawContentHeight = function () {
    this.freezeContentHeightDepth--;
    // always bring back to natural height
    this.contentEl.css({
        width: &#39;&#39;,
        height: &#39;&#39;,
        overflow: &#39;&#39;
    });
    // but if there are future thaws, re-freeze
    if (this.freezeContentHeightDepth) {
        this.forceFreezeContentHeight();
    }
};
// Toolbar
// -----------------------------------------------------------------------------------------------------------------
Calendar.prototype.initToolbars = function () {
    this.header = new Toolbar_1.default(this, this.computeHeaderOptions());
    this.footer = new Toolbar_1.default(this, this.computeFooterOptions());
    this.toolbarsManager = new Iterator_1.default([this.header, this.footer]);
};
Calendar.prototype.computeHeaderOptions = function () {
    return {
        extraClasses: &#39;fc-header-toolbar&#39;,
        layout: this.opt(&#39;header&#39;)
    };
};
Calendar.prototype.computeFooterOptions = function () {
    return {
        extraClasses: &#39;fc-footer-toolbar&#39;,
        layout: this.opt(&#39;footer&#39;)
    };
};
// can be called repeatedly and Header will rerender
Calendar.prototype.renderHeader = function () {
    var header = this.header;
    header.setToolbarOptions(this.computeHeaderOptions());
    header.render();
    if (header.el) {
        this.el.prepend(header.el);
    }
};
// can be called repeatedly and Footer will rerender
Calendar.prototype.renderFooter = function () {
    var footer = this.footer;
    footer.setToolbarOptions(this.computeFooterOptions());
    footer.render();
    if (footer.el) {
        this.el.append(footer.el);
    }
};
Calendar.prototype.setToolbarsTitle = function (title) {
    this.toolbarsManager.proxyCall(&#39;updateTitle&#39;, title);
};
Calendar.prototype.updateToolbarButtons = function (dateProfile) {
    var now = this.getNow();
    var view = this.view;
    var todayInfo = view.dateProfileGenerator.build(now);
    var prevInfo = view.dateProfileGenerator.buildPrev(view.get(&#39;dateProfile&#39;));
    var nextInfo = view.dateProfileGenerator.buildNext(view.get(&#39;dateProfile&#39;));
    this.toolbarsManager.proxyCall((todayInfo.isValid &amp;&amp; !dateProfile.currentUnzonedRange.containsDate(now)) ?
        &#39;enableButton&#39; :
        &#39;disableButton&#39;, &#39;today&#39;);
    this.toolbarsManager.proxyCall(prevInfo.isValid ?
        &#39;enableButton&#39; :
        &#39;disableButton&#39;, &#39;prev&#39;);
    this.toolbarsManager.proxyCall(nextInfo.isValid ?
        &#39;enableButton&#39; :
        &#39;disableButton&#39;, &#39;next&#39;);
};
Calendar.prototype.queryToolbarsHeight = function () {
    return this.toolbarsManager.items.reduce(function (accumulator, toolbar) {
        var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin
        return accumulator + toolbarHeight;
    }, 0);
};
// Selection
// -----------------------------------------------------------------------------------------------------------------
// this public method receives start/end dates in any format, with any timezone
Calendar.prototype.select = function (zonedStartInput, zonedEndInput) {
    this.view.select(this.buildSelectFootprint.apply(this, arguments));
};
Calendar.prototype.unselect = function () {
    if (this.view) {
        this.view.unselect();
    }
};
// Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
Calendar.prototype.buildSelectFootprint = function (zonedStartInput, zonedEndInput) {
    var start = this.moment(zonedStartInput).stripZone();
    var end;
    if (zonedEndInput) {
        end = this.moment(zonedEndInput).stripZone();
    }
    else if (start.hasTime()) {
        end = start.clone().add(this.defaultTimedEventDuration);
    }
    else {
        end = start.clone().add(this.defaultAllDayEventDuration);
    }
    return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), !start.hasTime());
};
// Date Utils
// -----------------------------------------------------------------------------------------------------------------
Calendar.prototype.initMomentInternals = function () {
    var _this = this;
    this.defaultAllDayEventDuration = moment.duration(this.opt(&#39;defaultAllDayEventDuration&#39;));
    this.defaultTimedEventDuration = moment.duration(this.opt(&#39;defaultTimedEventDuration&#39;));
    // Called immediately, and when any of the options change.
    // Happens before any internal objects rebuild or rerender, because this is very core.
    this.optionsManager.watch(&#39;buildingMomentLocale&#39;, [
        &#39;?locale&#39;, &#39;?monthNames&#39;, &#39;?monthNamesShort&#39;, &#39;?dayNames&#39;, &#39;?dayNamesShort&#39;,
        &#39;?firstDay&#39;, &#39;?weekNumberCalculation&#39;
    ], function (opts) {
        var weekNumberCalculation = opts.weekNumberCalculation;
        var firstDay = opts.firstDay;
        var _week;
        // normalize
        if (weekNumberCalculation === &#39;iso&#39;) {
            weekNumberCalculation = &#39;ISO&#39;; // normalize
        }
        var localeData = Object.create(// make a cheap copy
        locale_1.getMomentLocaleData(opts.locale) // will fall back to en
        );
        if (opts.monthNames) {
            localeData._months = opts.monthNames;
        }
        if (opts.monthNamesShort) {
            localeData._monthsShort = opts.monthNamesShort;
        }
        if (opts.dayNames) {
            localeData._weekdays = opts.dayNames;
        }
        if (opts.dayNamesShort) {
            localeData._weekdaysShort = opts.dayNamesShort;
        }
        if (firstDay == null &amp;&amp; weekNumberCalculation === &#39;ISO&#39;) {
            firstDay = 1;
        }
        if (firstDay != null) {
            _week = Object.create(localeData._week); // _week: { dow: # }
            _week.dow = firstDay;
            localeData._week = _week;
        }
        if (weekNumberCalculation === &#39;ISO&#39; ||
            weekNumberCalculation === &#39;local&#39; ||
            typeof weekNumberCalculation === &#39;function&#39;) {
            localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it
        }
        _this.localeData = localeData;
        // If the internal current date object already exists, move to new locale.
        // We do NOT need to do this technique for event dates, because this happens when converting to &quot;segments&quot;.
        if (_this.currentDate) {
            _this.localizeMoment(_this.currentDate); // sets to localeData
        }
    });
};
// Builds a moment using the settings of the current calendar: timezone and locale.
// Accepts anything the vanilla moment() constructor accepts.
Calendar.prototype.moment = function () {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var mom;
    if (this.opt(&#39;timezone&#39;) === &#39;local&#39;) {
        mom = moment_ext_1.default.apply(null, args);
        // Force the moment to be local, because momentExt doesn&#39;t guarantee it.
        if (mom.hasTime()) {
            mom.local();
        }
    }
    else if (this.opt(&#39;timezone&#39;) === &#39;UTC&#39;) {
        mom = moment_ext_1.default.utc.apply(null, args); // process as UTC
    }
    else {
        mom = moment_ext_1.default.parseZone.apply(null, args); // let the input decide the zone
    }
    this.localizeMoment(mom); // TODO
    return mom;
};
Calendar.prototype.msToMoment = function (ms, forceAllDay) {
    var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC
    if (forceAllDay) {
        mom.stripTime();
    }
    else {
        mom = this.applyTimezone(mom); // may or may not apply locale
    }
    this.localizeMoment(mom);
    return mom;
};
Calendar.prototype.msToUtcMoment = function (ms, forceAllDay) {
    var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC
    if (forceAllDay) {
        mom.stripTime();
    }
    this.localizeMoment(mom);
    return mom;
};
// Updates the given moment&#39;s locale settings to the current calendar locale settings.
Calendar.prototype.localizeMoment = function (mom) {
    mom._locale = this.localeData;
};
// Returns a boolean about whether or not the calendar knows how to calculate
// the timezone offset of arbitrary dates in the current timezone.
Calendar.prototype.getIsAmbigTimezone = function () {
    return this.opt(&#39;timezone&#39;) !== &#39;local&#39; &amp;&amp; this.opt(&#39;timezone&#39;) !== &#39;UTC&#39;;
};
// Returns a copy of the given date in the current timezone. Has no effect on dates without times.
Calendar.prototype.applyTimezone = function (date) {
    if (!date.hasTime()) {
        return date.clone();
    }
    var zonedDate = this.moment(date.toArray());
    var timeAdjust = date.time().asMilliseconds() - zonedDate.time().asMilliseconds();
    var adjustedZonedDate;
    // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
    if (timeAdjust) {
        adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
        if (date.time().asMilliseconds() - adjustedZonedDate.time().asMilliseconds() === 0) {
            zonedDate = adjustedZonedDate;
        }
    }
    return zonedDate;
};
/*
Assumes the footprint is non-open-ended.
 /
Calendar.prototype.footprintToDateProfile = function (componentFootprint, ignoreEnd) {
    if (ignoreEnd === void 0) { ignoreEnd = false; }
    var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs);
    var end;
    if (!ignoreEnd) {
        end = moment_ext_1.default.utc(componentFootprint.unzonedRange.endMs);
    }
    if (componentFootprint.isAllDay) {
        start.stripTime();
        if (end) {
            end.stripTime();
        }
    }
    else {
        start = this.applyTimezone(start);
        if (end) {
            end = this.applyTimezone(end);
        }
    }
    return new EventDateProfile_1.default(start, end, this);
};
// Returns a moment for the current date, as defined by the client&#39;s computer or from the `now` option.
// Will return an moment with an ambiguous timezone.
Calendar.prototype.getNow = function () {
    var now = this.opt(&#39;now&#39;);
    if (typeof now === &#39;function&#39;) {
        now = now();
    }
    return this.moment(now).stripZone();
};
// Produces a human-readable string for the given duration.
// Side-effect: changes the locale of the given duration.
Calendar.prototype.humanizeDuration = function (duration) {
    return duration.locale(this.opt(&#39;locale&#39;)).humanize();
};
// will return `null` if invalid range
Calendar.prototype.parseUnzonedRange = function (rangeInput) {
    var start = null;
    var end = null;
    if (rangeInput.start) {
        start = this.moment(rangeInput.start).stripZone();
    }
    if (rangeInput.end) {
        end = this.moment(rangeInput.end).stripZone();
    }
    if (!start &amp;&amp; !end) {
        return null;
    }
    if (start &amp;&amp; end &amp;&amp; end.isBefore(start)) {
        return null;
    }
    return new UnzonedRange_1.default(start, end);
};
// Event-Date Utilities
// -----------------------------------------------------------------------------------------------------------------
Calendar.prototype.initEventManager = function () {
    var _this = this;
    var eventManager = new EventManager_1.default(this);
    var rawSources = this.opt(&#39;eventSources&#39;) || [];
    var singleRawSource = this.opt(&#39;events&#39;);
    this.eventManager = eventManager;
    if (singleRawSource) {
        rawSources.unshift(singleRawSource);
    }
    eventManager.on(&#39;release&#39;, function (eventsPayload) {
        _this.trigger(&#39;eventsReset&#39;, eventsPayload);
    });
    eventManager.freeze();
    rawSources.forEach(function (rawSource) {
        var source = EventSourceParser_1.default.parse(rawSource, _this);
        if (source) {
            eventManager.addSource(source);
        }
    });
    eventManager.thaw();
};
Calendar.prototype.requestEvents = function (start, end) {
    return this.eventManager.requestEvents(start, end, this.opt(&#39;timezone&#39;), !this.opt(&#39;lazyFetching&#39;));
};
// Get an event&#39;s normalized end date. If not present, calculate it from the defaults.
Calendar.prototype.getEventEnd = function (event) {
    if (event.end) {
        return event.end.clone();
    }
    else {
        return this.getDefaultEventEnd(event.allDay, event.start);
    }
};
// Given an event&#39;s allDay status and start date, return what its fallback end date should be.
// TODO: rename to computeDefaultEventEnd
Calendar.prototype.getDefaultEventEnd = function (allDay, zonedStart) {
    var end = zonedStart.clone();
    if (allDay) {
        end.stripTime().add(this.defaultAllDayEventDuration);
    }
    else {
        end.add(this.defaultTimedEventDuration);
    }
    if (this.getIsAmbigTimezone()) {
        end.stripZone(); // we don&#39;t know what the tzo should be
    }
    return end;
};
// Public Events API
// -----------------------------------------------------------------------------------------------------------------
Calendar.prototype.rerenderEvents = function () {
    this.view.flash(&#39;displayingEvents&#39;);
};
Calendar.prototype.refetchEvents = function () {
    this.eventManager.refetchAllSources();
};
Calendar.prototype.renderEvents = function (eventInputs, isSticky) {
    this.eventManager.freeze();
    for (var i = 0; i &lt; eventInputs.length; i++) {
        this.renderEvent(eventInputs[i], isSticky);
    }
    this.eventManager.thaw();
};
Calendar.prototype.renderEvent = function (eventInput, isSticky) {
    if (isSticky === void 0) { isSticky = false; }
    var eventManager = this.eventManager;
    var eventDef = EventDefParser_1.default.parse(eventInput, eventInput.source || eventManager.stickySource);
    if (eventDef) {
        eventManager.addEventDef(eventDef, isSticky);
    }
};
// legacyQuery operates on legacy event instance objects
Calendar.prototype.removeEvents = function (legacyQuery) {
    var eventManager = this.eventManager;
    var legacyInstances = [];
    var idMap = {};
    var eventDef;
    var i;
    if (legacyQuery == null) {
        eventManager.removeAllEventDefs(); // persist=true
    }
    else {
        eventManager.getEventInstances().forEach(function (eventInstance) {
            legacyInstances.push(eventInstance.toLegacy());
        });
        legacyInstances = filterLegacyEventInstances(legacyInstances, legacyQuery);
        // compute unique IDs
        for (i = 0; i &lt; legacyInstances.length; i++) {
            eventDef = this.eventManager.getEventDefByUid(legacyInstances[i]._id);
            idMap[eventDef.id] = true;
        }
        eventManager.freeze();
        for (i in idMap) {
            eventManager.removeEventDefsById(i); // persist=true
        }
        eventManager.thaw();
    }
};
// legacyQuery operates on legacy event instance objects
Calendar.prototype.clientEvents = function (legacyQuery) {
    var legacyEventInstances = [];
    this.eventManager.getEventInstances().forEach(function (eventInstance) {
        legacyEventInstances.push(eventInstance.toLegacy());
    });
    return filterLegacyEventInstances(legacyEventInstances, legacyQuery);
};
Calendar.prototype.updateEvents = function (eventPropsArray) {
    this.eventManager.freeze();
    for (var i = 0; i &lt; eventPropsArray.length; i++) {
        this.updateEvent(eventPropsArray[i]);
    }
    this.eventManager.thaw();
};
Calendar.prototype.updateEvent = function (eventProps) {
    var eventDef = this.eventManager.getEventDefByUid(eventProps._id);
    var eventInstance;
    var eventDefMutation;
    if (eventDef instanceof SingleEventDef_1.default) {
        eventInstance = eventDef.buildInstance();
        eventDefMutation = EventDefMutation_1.default.createFromRawProps(eventInstance, eventProps, // raw props
        null // largeUnit -- who uses it?
        );
        this.eventManager.mutateEventsWithId(eventDef.id, eventDefMutation); // will release
    }
};
// Public Event Sources API
// ------------------------------------------------------------------------------------
Calendar.prototype.getEventSources = function () {
    return this.eventManager.otherSources.slice(); // clone
};
Calendar.prototype.getEventSourceById = function (id) {
    return this.eventManager.getSourceById(EventSource_1.default.normalizeId(id));
};
Calendar.prototype.addEventSource = function (sourceInput) {
    var source = EventSourceParser_1.default.parse(sourceInput, this);
    if (source) {
        this.eventManager.addSource(source);
    }
};
Calendar.prototype.removeEventSources = function (sourceMultiQuery) {
    var eventManager = this.eventManager;
    var sources;
    var i;
    if (sourceMultiQuery == null) {
        this.eventManager.removeAllSources();
    }
    else {
        sources = eventManager.multiQuerySources(sourceMultiQuery);
        eventManager.freeze();
        for (i = 0; i &lt; sources.length; i++) {
            eventManager.removeSource(sources[i]);
        }
        eventManager.thaw();
    }
};
Calendar.prototype.removeEventSource = function (sourceQuery) {
    var eventManager = this.eventManager;
    var sources = eventManager.querySources(sourceQuery);
    var i;
    eventManager.freeze();
    for (i = 0; i &lt; sources.length; i++) {
        eventManager.removeSource(sources[i]);
    }
    eventManager.thaw();
};
Calendar.prototype.refetchEventSources = function (sourceMultiQuery) {
    var eventManager = this.eventManager;
    var sources = eventManager.multiQuerySources(sourceMultiQuery);
    var i;
    eventManager.freeze();
    for (i = 0; i &lt; sources.length; i++) {
        eventManager.refetchSource(sources[i]);
    }
    eventManager.thaw();
};
// not for internal use. use options module directly instead.
Calendar.defaults = options_1.globalDefaults;
Calendar.englishDefaults = options_1.englishDefaults;
Calendar.rtlDefaults = options_1.rtlDefaults;
return Calendar;</pre>

<p>}()); exports.default = Calendar; EmitterMixin_1.default.mixInto(Calendar);
ListenerMixin_1.default.mixInto(Calendar); function
filterLegacyEventInstances(legacyEventInstances, legacyQuery) {</p>

<pre>if (legacyQuery == null) {
    return legacyEventInstances;
}
else if ($.isFunction(legacyQuery)) {
    return legacyEventInstances.filter(legacyQuery);
}
else {
    legacyQuery += &#39;&#39;; // normalize to string
    return legacyEventInstances.filter(function (legacyEventInstance) {
        // soft comparison because id not be normalized to string
        // tslint:disable-next-line
        return legacyEventInstance.id == legacyQuery ||
            legacyEventInstance._id === legacyQuery; // can specify internal id, but must exactly match
    });
}</pre>

<p>}</p>

<p>/***/ }), /* 221 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var moment =
<em>webpack_require</em>(0); var util_1 = <em>webpack_require</em>(4); var
UnzonedRange_1 = <em>webpack_require</em>(5); var DateProfileGenerator =
/** @class */ (function () {</p>

<pre>function DateProfileGenerator(_view) {
    this._view = _view;
}
DateProfileGenerator.prototype.opt = function (name) {
    return this._view.opt(name);
};
DateProfileGenerator.prototype.trimHiddenDays = function (unzonedRange) {
    return this._view.trimHiddenDays(unzonedRange);
};
DateProfileGenerator.prototype.msToUtcMoment = function (ms, forceAllDay) {
    return this._view.calendar.msToUtcMoment(ms, forceAllDay);
};
/* Date Range Computation
------------------------------------------------------------------------------------------------------------------*/
// Builds a structure with info about what the dates/ranges will be for the &quot;prev&quot; view.
DateProfileGenerator.prototype.buildPrev = function (currentDateProfile) {
    var prevDate = currentDateProfile.date.clone()
        .startOf(currentDateProfile.currentRangeUnit)
        .subtract(currentDateProfile.dateIncrement);
    return this.build(prevDate, -1);
};
// Builds a structure with info about what the dates/ranges will be for the &quot;next&quot; view.
DateProfileGenerator.prototype.buildNext = function (currentDateProfile) {
    var nextDate = currentDateProfile.date.clone()
        .startOf(currentDateProfile.currentRangeUnit)
        .add(currentDateProfile.dateIncrement);
    return this.build(nextDate, 1);
};
// Builds a structure holding dates/ranges for rendering around the given date.
// Optional direction param indicates whether the date is being incremented/decremented
// from its previous value. decremented = -1, incremented = 1 (default).
DateProfileGenerator.prototype.build = function (date, direction, forceToValid) {
    if (forceToValid === void 0) { forceToValid = false; }
    var isDateAllDay = !date.hasTime();
    var validUnzonedRange;
    var minTime = null;
    var maxTime = null;
    var currentInfo;
    var isRangeAllDay;
    var renderUnzonedRange;
    var activeUnzonedRange;
    var isValid;
    validUnzonedRange = this.buildValidRange();
    validUnzonedRange = this.trimHiddenDays(validUnzonedRange);
    if (forceToValid) {
        date = this.msToUtcMoment(validUnzonedRange.constrainDate(date), // returns MS
        isDateAllDay);
    }
    currentInfo = this.buildCurrentRangeInfo(date, direction);
    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
    renderUnzonedRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.unzonedRange), currentInfo.unit, isRangeAllDay);
    renderUnzonedRange = this.trimHiddenDays(renderUnzonedRange);
    activeUnzonedRange = renderUnzonedRange.clone();
    if (!this.opt(&#39;showNonCurrentDates&#39;)) {
        activeUnzonedRange = activeUnzonedRange.intersect(currentInfo.unzonedRange);
    }
    minTime = moment.duration(this.opt(&#39;minTime&#39;));
    maxTime = moment.duration(this.opt(&#39;maxTime&#39;));
    activeUnzonedRange = this.adjustActiveRange(activeUnzonedRange, minTime, maxTime);
    activeUnzonedRange = activeUnzonedRange.intersect(validUnzonedRange); // might return null
    if (activeUnzonedRange) {
        date = this.msToUtcMoment(activeUnzonedRange.constrainDate(date), // returns MS
        isDateAllDay);
    }
    // it&#39;s invalid if the originally requested date is not contained,
    // or if the range is completely outside of the valid range.
    isValid = currentInfo.unzonedRange.intersectsWith(validUnzonedRange);
    return {
        // constraint for where prev/next operations can go and where events can be dragged/resized to.
        // an object with optional start and end properties.
        validUnzonedRange: validUnzonedRange,
        // range the view is formally responsible for.
        // for example, a month view might have 1st-31st, excluding padded dates
        currentUnzonedRange: currentInfo.unzonedRange,
        // name of largest unit being displayed, like &quot;month&quot; or &quot;week&quot;
        currentRangeUnit: currentInfo.unit,
        isRangeAllDay: isRangeAllDay,
        // dates that display events and accept drag-n-drop
        // will be `null` if no dates accept events
        activeUnzonedRange: activeUnzonedRange,
        // date range with a rendered skeleton
        // includes not-active days that need some sort of DOM
        renderUnzonedRange: renderUnzonedRange,
        // Duration object that denotes the first visible time of any given day
        minTime: minTime,
        // Duration object that denotes the exclusive visible end time of any given day
        maxTime: maxTime,
        isValid: isValid,
        date: date,
        // how far the current date will move for a prev/next operation
        dateIncrement: this.buildDateIncrement(currentInfo.duration)
        // pass a fallback (might be null) ^
    };
};
// Builds an object with optional start/end properties.
// Indicates the minimum/maximum dates to display.
// not responsible for trimming hidden days.
DateProfileGenerator.prototype.buildValidRange = function () {
    return this._view.getUnzonedRangeOption(&#39;validRange&#39;, this._view.calendar.getNow()) ||
        new UnzonedRange_1.default(); // completely open-ended
};
// Builds a structure with info about the &quot;current&quot; range, the range that is
// highlighted as being the current month for example.
// See build() for a description of `direction`.
// Guaranteed to have `range` and `unit` properties. `duration` is optional.
// TODO: accept a MS-time instead of a moment `date`?
DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
    var viewSpec = this._view.viewSpec;
    var duration = null;
    var unit = null;
    var unzonedRange = null;
    var dayCount;
    if (viewSpec.duration) {
        duration = viewSpec.duration;
        unit = viewSpec.durationUnit;
        unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);
    }
    else if ((dayCount = this.opt(&#39;dayCount&#39;))) {
        unit = &#39;day&#39;;
        unzonedRange = this.buildRangeFromDayCount(date, direction, dayCount);
    }
    else if ((unzonedRange = this.buildCustomVisibleRange(date))) {
        unit = util_1.computeGreatestUnit(unzonedRange.getStart(), unzonedRange.getEnd());
    }
    else {
        duration = this.getFallbackDuration();
        unit = util_1.computeGreatestUnit(duration);
        unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);
    }
    return { duration: duration, unit: unit, unzonedRange: unzonedRange };
};
DateProfileGenerator.prototype.getFallbackDuration = function () {
    return moment.duration({ days: 1 });
};
// Returns a new activeUnzonedRange to have time values (un-ambiguate)
// minTime or maxTime causes the range to expand.
DateProfileGenerator.prototype.adjustActiveRange = function (unzonedRange, minTime, maxTime) {
    var start = unzonedRange.getStart();
    var end = unzonedRange.getEnd();
    if (this._view.usesMinMaxTime) {
        if (minTime &lt; 0) {
            start.time(0).add(minTime);
        }
        if (maxTime &gt; 24 * 60 * 60 * 1000) {
            end.time(maxTime - (24 * 60 * 60 * 1000));
        }
    }
    return new UnzonedRange_1.default(start, end);
};
// Builds the &quot;current&quot; range when it is specified as an explicit duration.
// `unit` is the already-computed computeGreatestUnit value of duration.
// TODO: accept a MS-time instead of a moment `date`?
DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
    var alignment = this.opt(&#39;dateAlignment&#39;);
    var dateIncrementInput;
    var dateIncrementDuration;
    var start;
    var end;
    var res;
    // compute what the alignment should be
    if (!alignment) {
        dateIncrementInput = this.opt(&#39;dateIncrement&#39;);
        if (dateIncrementInput) {
            dateIncrementDuration = moment.duration(dateIncrementInput);
            // use the smaller of the two units
            if (dateIncrementDuration &lt; duration) {
                alignment = util_1.computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);
            }
            else {
                alignment = unit;
            }
        }
        else {
            alignment = unit;
        }
    }
    // if the view displays a single day or smaller
    if (duration.as(&#39;days&#39;) &lt;= 1) {
        if (this._view.isHiddenDay(start)) {
            start = this._view.skipHiddenDays(start, direction);
            start.startOf(&#39;day&#39;);
        }
    }
    function computeRes() {
        start = date.clone().startOf(alignment);
        end = start.clone().add(duration);
        res = new UnzonedRange_1.default(start, end);
    }
    computeRes();
    // if range is completely enveloped by hidden days, go past the hidden days
    if (!this.trimHiddenDays(res)) {
        date = this._view.skipHiddenDays(date, direction);
        computeRes();
    }
    return res;
};
// Builds the &quot;current&quot; range when a dayCount is specified.
// TODO: accept a MS-time instead of a moment `date`?
DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
    var customAlignment = this.opt(&#39;dateAlignment&#39;);
    var runningCount = 0;
    var start = date.clone();
    var end;
    if (customAlignment) {
        start.startOf(customAlignment);
    }
    start.startOf(&#39;day&#39;);
    start = this._view.skipHiddenDays(start, direction);
    end = start.clone();
    do {
        end.add(1, &#39;day&#39;);
        if (!this._view.isHiddenDay(end)) {
            runningCount++;
        }
    } while (runningCount &lt; dayCount);
    return new UnzonedRange_1.default(start, end);
};
// Builds a normalized range object for the &quot;visible&quot; range,
// which is a way to define the currentUnzonedRange and activeUnzonedRange at the same time.
// TODO: accept a MS-time instead of a moment `date`?
DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
    var visibleUnzonedRange = this._view.getUnzonedRangeOption(&#39;visibleRange&#39;, this._view.calendar.applyTimezone(date) // correct zone. also generates new obj that avoids mutations
    );
    if (visibleUnzonedRange &amp;&amp; (visibleUnzonedRange.startMs == null || visibleUnzonedRange.endMs == null)) {
        return null;
    }
    return visibleUnzonedRange;
};
// Computes the range that will represent the element/cells for *rendering*,
// but which may have voided days/times.
// not responsible for trimming hidden days.
DateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
    return currentUnzonedRange.clone();
};
// Compute the duration value that should be added/substracted to the current date
// when a prev/next operation happens.
DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
    var dateIncrementInput = this.opt(&#39;dateIncrement&#39;);
    var customAlignment;
    if (dateIncrementInput) {
        return moment.duration(dateIncrementInput);
    }
    else if ((customAlignment = this.opt(&#39;dateAlignment&#39;))) {
        return moment.duration(1, customAlignment);
    }
    else if (fallback) {
        return fallback;
    }
    else {
        return moment.duration({ days: 1 });
    }
};
return DateProfileGenerator;</pre>

<p>}()); exports.default = DateProfileGenerator;</p>

<p>/***/ }), /* 222 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
moment = <em>webpack_require</em>(0); var exportHooks =
<em>webpack_require</em>(16); var util_1 = <em>webpack_require</em>(4); var
moment_ext_1 = <em>webpack_require</em>(10); var ListenerMixin_1 =
<em>webpack_require</em>(7); var HitDragListener_1 =
<em>webpack_require</em>(23); var SingleEventDef_1 =
<em>webpack_require</em>(13); var EventInstanceGroup_1 =
<em>webpack_require</em>(18); var EventSource_1 =
<em>webpack_require</em>(6); var Interaction_1 =
<em>webpack_require</em>(15); var ExternalDropping = /** @class */
(function (_super) {</p>

<pre>tslib_1.__extends(ExternalDropping, _super);
function ExternalDropping() {
    var _this = _super !== null &amp;&amp; _super.apply(this, arguments) || this;
    _this.isDragging = false; // jqui-dragging an external element? boolean
    return _this;
}
/*
component impements:
  - eventRangesToEventFootprints
  - isEventInstanceGroupAllowed
  - isExternalInstanceGroupAllowed
  - renderDrag
  - unrenderDrag
 /
ExternalDropping.prototype.end = function () {
    if (this.dragListener) {
        this.dragListener.endInteraction();
    }
};
ExternalDropping.prototype.bindToDocument = function () {
    this.listenTo($(document), {
        dragstart: this.handleDragStart,
        sortstart: this.handleDragStart // jqui
    });
};
ExternalDropping.prototype.unbindFromDocument = function () {
    this.stopListeningTo($(document));
};
// Called when a jQuery UI drag is initiated anywhere in the DOM
ExternalDropping.prototype.handleDragStart = function (ev, ui) {
    var el;
    var accept;
    if (this.opt(&#39;droppable&#39;)) {
        el = $((ui ? ui.item : null) || ev.target);
        // Test that the dragged element passes the dropAccept selector or filter function.
        // FYI, the default is &quot;*&quot; (matches all)
        accept = this.opt(&#39;dropAccept&#39;);
        if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
            if (!this.isDragging) {
                this.listenToExternalDrag(el, ev, ui);
            }
        }
    }
};
// Called when a jQuery UI drag starts and it needs to be monitored for dropping
ExternalDropping.prototype.listenToExternalDrag = function (el, ev, ui) {
    var _this = this;
    var component = this.component;
    var view = this.view;
    var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
    var singleEventDef; // a null value signals an unsuccessful drag
    // listener that tracks mouse movement over date-associated pixel regions
    var dragListener = this.dragListener = new HitDragListener_1.default(component, {
        interactionStart: function () {
            _this.isDragging = true;
        },
        hitOver: function (hit) {
            var isAllowed = true;
            var hitFootprint = hit.component.getSafeHitFootprint(hit); // hit might not belong to this grid
            var mutatedEventInstanceGroup;
            if (hitFootprint) {
                singleEventDef = _this.computeExternalDrop(hitFootprint, meta);
                if (singleEventDef) {
                    mutatedEventInstanceGroup = new EventInstanceGroup_1.default(singleEventDef.buildInstances());
                    isAllowed = meta.eventProps ? // isEvent?
                        component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup) :
                        component.isExternalInstanceGroupAllowed(mutatedEventInstanceGroup);
                }
                else {
                    isAllowed = false;
                }
            }
            else {
                isAllowed = false;
            }
            if (!isAllowed) {
                singleEventDef = null;
                util_1.disableCursor();
            }
            if (singleEventDef) {
                component.renderDrag(// called without a seg parameter
                component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, view.calendar)));
            }
        },
        hitOut: function () {
            singleEventDef = null; // signal unsuccessful
        },
        hitDone: function () {
            util_1.enableCursor();
            component.unrenderDrag();
        },
        interactionEnd: function (ev) {
            if (singleEventDef) {
                view.reportExternalDrop(singleEventDef, Boolean(meta.eventProps), // isEvent
                Boolean(meta.stick), // isSticky
                el, ev, ui);
            }
            _this.isDragging = false;
            _this.dragListener = null;
        }
    });
    dragListener.startDrag(ev); // start listening immediately
};
// Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
// returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
// Returning a null value signals an invalid drop hit.
// DOES NOT consider overlap/constraint.
// Assumes both footprints are non-open-ended.
ExternalDropping.prototype.computeExternalDrop = function (componentFootprint, meta) {
    var calendar = this.view.calendar;
    var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs).stripZone();
    var end;
    var eventDef;
    if (componentFootprint.isAllDay) {
        // if dropped on an all-day span, and element&#39;s metadata specified a time, set it
        if (meta.startTime) {
            start.time(meta.startTime);
        }
        else {
            start.stripTime();
        }
    }
    if (meta.duration) {
        end = start.clone().add(meta.duration);
    }
    start = calendar.applyTimezone(start);
    if (end) {
        end = calendar.applyTimezone(end);
    }
    eventDef = SingleEventDef_1.default.parse($.extend({}, meta.eventProps, {
        start: start,
        end: end
    }), new EventSource_1.default(calendar));
    return eventDef;
};
return ExternalDropping;</pre>

<p>}(Interaction_1.default)); exports.default = ExternalDropping;
ListenerMixin_1.default.mixInto(ExternalDropping); /*
External-Dragging-Element Data ———————————————————————————————————————-*/
// Require all HTML5 data-* attributes used by FullCalendar to have this
prefix. // A value of &#39;&#39; will query attributes like data-event. A
value of &#39;fc&#39; will query attributes like data-fc-event.
exportHooks.dataAttrPrefix = &#39;&#39;; // Given a jQuery element that
might represent a dragged FullCalendar event, returns an intermediate data
structure // to be used for Event <a href="../../Object.html">Object</a>
creation. // A defined `.eventProps`, even when empty, indicates that an
event should be created. function getDraggedElMeta(el) {</p>

<pre>var prefix = exportHooks.dataAttrPrefix;
var eventProps; // properties for creating the event, not related to date/time
var startTime; // a Duration
var duration;
var stick;
if (prefix) {
    prefix += &#39;-&#39;;
}
eventProps = el.data(prefix + &#39;event&#39;) || null;
if (eventProps) {
    if (typeof eventProps === &#39;object&#39;) {
        eventProps = $.extend({}, eventProps); // make a copy
    }
    else {
        eventProps = {};
    }
    // pluck special-cased date/time properties
    startTime = eventProps.start;
    if (startTime == null) {
        startTime = eventProps.time;
    } // accept &#39;time&#39; as well
    duration = eventProps.duration;
    stick = eventProps.stick;
    delete eventProps.start;
    delete eventProps.time;
    delete eventProps.duration;
    delete eventProps.stick;
}
// fallback to standalone attribute values for each of the date/time properties
if (startTime == null) {
    startTime = el.data(prefix + &#39;start&#39;);
}
if (startTime == null) {
    startTime = el.data(prefix + &#39;time&#39;);
} // accept &#39;time&#39; as well
if (duration == null) {
    duration = el.data(prefix + &#39;duration&#39;);
}
if (stick == null) {
    stick = el.data(prefix + &#39;stick&#39;);
}
// massage into correct data types
startTime = startTime != null ? moment.duration(startTime) : null;
duration = duration != null ? moment.duration(duration) : null;
stick = Boolean(stick);
return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };</pre>

<p>}</p>

<p>/***/ }), /* 223 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var EventDefMutation_1 =
<em>webpack_require</em>(37); var EventDefDateMutation_1 =
<em>webpack_require</em>(50); var HitDragListener_1 =
<em>webpack_require</em>(23); var Interaction_1 =
<em>webpack_require</em>(15); var EventResizing = /** @class */ (function
(_super) {</p>

<pre>tslib_1.__extends(EventResizing, _super);
/*
component impements:
  - bindSegHandlerToEl
  - publiclyTrigger
  - diffDates
  - eventRangesToEventFootprints
  - isEventInstanceGroupAllowed
  - getSafeHitFootprint
 /
function EventResizing(component, eventPointing) {
    var _this = _super.call(this, component) || this;
    _this.isResizing = false;
    _this.eventPointing = eventPointing;
    return _this;
}
EventResizing.prototype.end = function () {
    if (this.dragListener) {
        this.dragListener.endInteraction();
    }
};
EventResizing.prototype.bindToEl = function (el) {
    var component = this.component;
    component.bindSegHandlerToEl(el, &#39;mousedown&#39;, this.handleMouseDown.bind(this));
    component.bindSegHandlerToEl(el, &#39;touchstart&#39;, this.handleTouchStart.bind(this));
};
EventResizing.prototype.handleMouseDown = function (seg, ev) {
    if (this.component.canStartResize(seg, ev)) {
        this.buildDragListener(seg, $(ev.target).is(&#39;.fc-start-resizer&#39;))
            .startInteraction(ev, { distance: 5 });
    }
};
EventResizing.prototype.handleTouchStart = function (seg, ev) {
    if (this.component.canStartResize(seg, ev)) {
        this.buildDragListener(seg, $(ev.target).is(&#39;.fc-start-resizer&#39;))
            .startInteraction(ev);
    }
};
// Creates a listener that tracks the user as they resize an event segment.
// Generic enough to work with any type of Grid.
EventResizing.prototype.buildDragListener = function (seg, isStart) {
    var _this = this;
    var component = this.component;
    var view = this.view;
    var calendar = view.calendar;
    var eventManager = calendar.eventManager;
    var el = seg.el;
    var eventDef = seg.footprint.eventDef;
    var eventInstance = seg.footprint.eventInstance;
    var isDragging;
    var resizeMutation; // zoned event date properties. falsy if invalid resize
    // Tracks mouse movement over the *grid&#39;s* coordinate map
    var dragListener = this.dragListener = new HitDragListener_1.default(component, {
        scroll: this.opt(&#39;dragScroll&#39;),
        subjectEl: el,
        interactionStart: function () {
            isDragging = false;
        },
        dragStart: function (ev) {
            isDragging = true;
            // ensure a mouseout on the manipulated event has been reported
            _this.eventPointing.handleMouseout(seg, ev);
            _this.segResizeStart(seg, ev);
        },
        hitOver: function (hit, isOrig, origHit) {
            var isAllowed = true;
            var origHitFootprint = component.getSafeHitFootprint(origHit);
            var hitFootprint = component.getSafeHitFootprint(hit);
            var mutatedEventInstanceGroup;
            if (origHitFootprint &amp;&amp; hitFootprint) {
                resizeMutation = isStart ?
                    _this.computeEventStartResizeMutation(origHitFootprint, hitFootprint, seg.footprint) :
                    _this.computeEventEndResizeMutation(origHitFootprint, hitFootprint, seg.footprint);
                if (resizeMutation) {
                    mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, resizeMutation);
                    isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);
                }
                else {
                    isAllowed = false;
                }
            }
            else {
                isAllowed = false;
            }
            if (!isAllowed) {
                resizeMutation = null;
                util_1.disableCursor();
            }
            else if (resizeMutation.isEmpty()) {
                // no change. (FYI, event dates might have zones)
                resizeMutation = null;
            }
            if (resizeMutation) {
                view.hideEventsWithId(seg.footprint.eventDef.id);
                view.renderEventResize(component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg);
            }
        },
        hitOut: function () {
            resizeMutation = null;
        },
        hitDone: function () {
            view.unrenderEventResize(seg);
            view.showEventsWithId(seg.footprint.eventDef.id);
            util_1.enableCursor();
        },
        interactionEnd: function (ev) {
            if (isDragging) {
                _this.segResizeStop(seg, ev);
            }
            if (resizeMutation) {
                // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                view.reportEventResize(eventInstance, resizeMutation, el, ev);
            }
            _this.dragListener = null;
        }
    });
    return dragListener;
};
// Called before event segment resizing starts
EventResizing.prototype.segResizeStart = function (seg, ev) {
    this.isResizing = true;
    this.component.publiclyTrigger(&#39;eventResizeStart&#39;, {
        context: seg.el[0],
        args: [
            seg.footprint.getEventLegacy(),
            ev,
            {},
            this.view
        ]
    });
};
// Called after event segment resizing stops
EventResizing.prototype.segResizeStop = function (seg, ev) {
    this.isResizing = false;
    this.component.publiclyTrigger(&#39;eventResizeStop&#39;, {
        context: seg.el[0],
        args: [
            seg.footprint.getEventLegacy(),
            ev,
            {},
            this.view
        ]
    });
};
// Returns new date-information for an event segment being resized from its start
EventResizing.prototype.computeEventStartResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {
    var origRange = origEventFootprint.componentFootprint.unzonedRange;
    var startDelta = this.component.diffDates(endFootprint.unzonedRange.getStart(), startFootprint.unzonedRange.getStart());
    var dateMutation;
    var eventDefMutation;
    if (origRange.getStart().add(startDelta) &lt; origRange.getEnd()) {
        dateMutation = new EventDefDateMutation_1.default();
        dateMutation.setStartDelta(startDelta);
        eventDefMutation = new EventDefMutation_1.default();
        eventDefMutation.setDateMutation(dateMutation);
        return eventDefMutation;
    }
    return false;
};
// Returns new date-information for an event segment being resized from its end
EventResizing.prototype.computeEventEndResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {
    var origRange = origEventFootprint.componentFootprint.unzonedRange;
    var endDelta = this.component.diffDates(endFootprint.unzonedRange.getEnd(), startFootprint.unzonedRange.getEnd());
    var dateMutation;
    var eventDefMutation;
    if (origRange.getEnd().add(endDelta) &gt; origRange.getStart()) {
        dateMutation = new EventDefDateMutation_1.default();
        dateMutation.setEndDelta(endDelta);
        eventDefMutation = new EventDefMutation_1.default();
        eventDefMutation.setDateMutation(dateMutation);
        return eventDefMutation;
    }
    return false;
};
return EventResizing;</pre>

<p>}(Interaction_1.default)); exports.default = EventResizing;</p>

<p>/***/ }), /* 224 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var util_1 = <em>webpack_require</em>(4);
var EventDefMutation_1 = <em>webpack_require</em>(37); var
EventDefDateMutation_1 = <em>webpack_require</em>(50); var DragListener_1 =
<em>webpack_require</em>(54); var HitDragListener_1 =
<em>webpack_require</em>(23); var MouseFollower_1 =
<em>webpack_require</em>(244); var Interaction_1 =
<em>webpack_require</em>(15); var EventDragging = /** @class */ (function
(_super) {</p>

<pre>tslib_1.__extends(EventDragging, _super);
/*
component implements:
  - bindSegHandlerToEl
  - publiclyTrigger
  - diffDates
  - eventRangesToEventFootprints
  - isEventInstanceGroupAllowed
 /
function EventDragging(component, eventPointing) {
    var _this = _super.call(this, component) || this;
    _this.isDragging = false;
    _this.eventPointing = eventPointing;
    return _this;
}
EventDragging.prototype.end = function () {
    if (this.dragListener) {
        this.dragListener.endInteraction();
    }
};
EventDragging.prototype.getSelectionDelay = function () {
    var delay = this.opt(&#39;eventLongPressDelay&#39;);
    if (delay == null) {
        delay = this.opt(&#39;longPressDelay&#39;); // fallback
    }
    return delay;
};
EventDragging.prototype.bindToEl = function (el) {
    var component = this.component;
    component.bindSegHandlerToEl(el, &#39;mousedown&#39;, this.handleMousedown.bind(this));
    component.bindSegHandlerToEl(el, &#39;touchstart&#39;, this.handleTouchStart.bind(this));
};
EventDragging.prototype.handleMousedown = function (seg, ev) {
    if (!this.component.shouldIgnoreMouse() &amp;&amp;
        this.component.canStartDrag(seg, ev)) {
        this.buildDragListener(seg).startInteraction(ev, { distance: 5 });
    }
};
EventDragging.prototype.handleTouchStart = function (seg, ev) {
    var component = this.component;
    var settings = {
        delay: this.view.isEventDefSelected(seg.footprint.eventDef) ? // already selected?
            0 : this.getSelectionDelay()
    };
    if (component.canStartDrag(seg, ev)) {
        this.buildDragListener(seg).startInteraction(ev, settings);
    }
    else if (component.canStartSelection(seg, ev)) {
        this.buildSelectListener(seg).startInteraction(ev, settings);
    }
};
// seg isn&#39;t draggable, but let&#39;s use a generic DragListener
// simply for the delay, so it can be selected.
// Has side effect of setting/unsetting `dragListener`
EventDragging.prototype.buildSelectListener = function (seg) {
    var _this = this;
    var view = this.view;
    var eventDef = seg.footprint.eventDef;
    var eventInstance = seg.footprint.eventInstance; // null for inverse-background events
    if (this.dragListener) {
        return this.dragListener;
    }
    var dragListener = this.dragListener = new DragListener_1.default({
        dragStart: function (ev) {
            if (dragListener.isTouch &amp;&amp;
                !view.isEventDefSelected(eventDef) &amp;&amp;
                eventInstance) {
                // if not previously selected, will fire after a delay. then, select the event
                view.selectEventInstance(eventInstance);
            }
        },
        interactionEnd: function (ev) {
            _this.dragListener = null;
        }
    });
    return dragListener;
};
// Builds a listener that will track user-dragging on an event segment.
// Generic enough to work with any type of Grid.
// Has side effect of setting/unsetting `dragListener`
EventDragging.prototype.buildDragListener = function (seg) {
    var _this = this;
    var component = this.component;
    var view = this.view;
    var calendar = view.calendar;
    var eventManager = calendar.eventManager;
    var el = seg.el;
    var eventDef = seg.footprint.eventDef;
    var eventInstance = seg.footprint.eventInstance; // null for inverse-background events
    var isDragging;
    var mouseFollower; // A clone of the original element that will move with the mouse
    var eventDefMutation;
    if (this.dragListener) {
        return this.dragListener;
    }
    // Tracks mouse movement over the *view&#39;s* coordinate map. Allows dragging and dropping between subcomponents
    // of the view.
    var dragListener = this.dragListener = new HitDragListener_1.default(view, {
        scroll: this.opt(&#39;dragScroll&#39;),
        subjectEl: el,
        subjectCenter: true,
        interactionStart: function (ev) {
            seg.component = component; // for renderDrag
            isDragging = false;
            mouseFollower = new MouseFollower_1.default(seg.el, {
                additionalClass: &#39;fc-dragging&#39;,
                parentEl: view.el,
                opacity: dragListener.isTouch ? null : _this.opt(&#39;dragOpacity&#39;),
                revertDuration: _this.opt(&#39;dragRevertDuration&#39;),
                zIndex: 2 // one above the .fc-view
            });
            mouseFollower.hide(); // don&#39;t show until we know this is a real drag
            mouseFollower.start(ev);
        },
        dragStart: function (ev) {
            if (dragListener.isTouch &amp;&amp;
                !view.isEventDefSelected(eventDef) &amp;&amp;
                eventInstance) {
                // if not previously selected, will fire after a delay. then, select the event
                view.selectEventInstance(eventInstance);
            }
            isDragging = true;
            // ensure a mouseout on the manipulated event has been reported
            _this.eventPointing.handleMouseout(seg, ev);
            _this.segDragStart(seg, ev);
            view.hideEventsWithId(seg.footprint.eventDef.id);
        },
        hitOver: function (hit, isOrig, origHit) {
            var isAllowed = true;
            var origFootprint;
            var footprint;
            var mutatedEventInstanceGroup;
            // starting hit could be forced (DayGrid.limit)
            if (seg.hit) {
                origHit = seg.hit;
            }
            // hit might not belong to this grid, so query origin grid
            origFootprint = origHit.component.getSafeHitFootprint(origHit);
            footprint = hit.component.getSafeHitFootprint(hit);
            if (origFootprint &amp;&amp; footprint) {
                eventDefMutation = _this.computeEventDropMutation(origFootprint, footprint, eventDef);
                if (eventDefMutation) {
                    mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, eventDefMutation);
                    isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);
                }
                else {
                    isAllowed = false;
                }
            }
            else {
                isAllowed = false;
            }
            if (!isAllowed) {
                eventDefMutation = null;
                util_1.disableCursor();
            }
            // if a valid drop location, have the subclass render a visual indication
            if (eventDefMutation &amp;&amp;
                view.renderDrag(// truthy if rendered something
                component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg, dragListener.isTouch)) {
                mouseFollower.hide(); // if the subclass is already using a mock event &quot;helper&quot;, hide our own
            }
            else {
                mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
            }
            if (isOrig) {
                // needs to have moved hits to be a valid drop
                eventDefMutation = null;
            }
        },
        hitOut: function () {
            view.unrenderDrag(seg); // unrender whatever was done in renderDrag
            mouseFollower.show(); // show in case we are moving out of all hits
            eventDefMutation = null;
        },
        hitDone: function () {
            util_1.enableCursor();
        },
        interactionEnd: function (ev) {
            delete seg.component; // prevent side effects
            // do revert animation if hasn&#39;t changed. calls a callback when finished (whether animation or not)
            mouseFollower.stop(!eventDefMutation, function () {
                if (isDragging) {
                    view.unrenderDrag(seg);
                    _this.segDragStop(seg, ev);
                }
                view.showEventsWithId(seg.footprint.eventDef.id);
                if (eventDefMutation) {
                    // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                    view.reportEventDrop(eventInstance, eventDefMutation, el, ev);
                }
            });
            _this.dragListener = null;
        }
    });
    return dragListener;
};
// Called before event segment dragging starts
EventDragging.prototype.segDragStart = function (seg, ev) {
    this.isDragging = true;
    this.component.publiclyTrigger(&#39;eventDragStart&#39;, {
        context: seg.el[0],
        args: [
            seg.footprint.getEventLegacy(),
            ev,
            {},
            this.view
        ]
    });
};
// Called after event segment dragging stops
EventDragging.prototype.segDragStop = function (seg, ev) {
    this.isDragging = false;
    this.component.publiclyTrigger(&#39;eventDragStop&#39;, {
        context: seg.el[0],
        args: [
            seg.footprint.getEventLegacy(),
            ev,
            {},
            this.view
        ]
    });
};
// DOES NOT consider overlap/constraint
EventDragging.prototype.computeEventDropMutation = function (startFootprint, endFootprint, eventDef) {
    var eventDefMutation = new EventDefMutation_1.default();
    eventDefMutation.setDateMutation(this.computeEventDateMutation(startFootprint, endFootprint));
    return eventDefMutation;
};
EventDragging.prototype.computeEventDateMutation = function (startFootprint, endFootprint) {
    var date0 = startFootprint.unzonedRange.getStart();
    var date1 = endFootprint.unzonedRange.getStart();
    var clearEnd = false;
    var forceTimed = false;
    var forceAllDay = false;
    var dateDelta;
    var dateMutation;
    if (startFootprint.isAllDay !== endFootprint.isAllDay) {
        clearEnd = true;
        if (endFootprint.isAllDay) {
            forceAllDay = true;
            date0.stripTime();
        }
        else {
            forceTimed = true;
        }
    }
    dateDelta = this.component.diffDates(date1, date0);
    dateMutation = new EventDefDateMutation_1.default();
    dateMutation.clearEnd = clearEnd;
    dateMutation.forceTimed = forceTimed;
    dateMutation.forceAllDay = forceAllDay;
    dateMutation.setDateDelta(dateDelta);
    return dateMutation;
};
return EventDragging;</pre>

<p>}(Interaction_1.default)); exports.default = EventDragging;</p>

<p>/***/ }), /* 225 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var util_1 = <em>webpack_require</em>(4);
var HitDragListener_1 = <em>webpack_require</em>(23); var
ComponentFootprint_1 = <em>webpack_require</em>(12); var UnzonedRange_1 =
<em>webpack_require</em>(5); var Interaction_1 =
<em>webpack_require</em>(15); var DateSelecting = /** @class */ (function
(_super) {</p>

<pre>tslib_1.__extends(DateSelecting, _super);
/*
component must implement:
  - bindDateHandlerToEl
  - getSafeHitFootprint
  - renderHighlight
  - unrenderHighlight
 /
function DateSelecting(component) {
    var _this = _super.call(this, component) || this;
    _this.dragListener = _this.buildDragListener();
    return _this;
}
DateSelecting.prototype.end = function () {
    this.dragListener.endInteraction();
};
DateSelecting.prototype.getDelay = function () {
    var delay = this.opt(&#39;selectLongPressDelay&#39;);
    if (delay == null) {
        delay = this.opt(&#39;longPressDelay&#39;); // fallback
    }
    return delay;
};
DateSelecting.prototype.bindToEl = function (el) {
    var _this = this;
    var component = this.component;
    var dragListener = this.dragListener;
    component.bindDateHandlerToEl(el, &#39;mousedown&#39;, function (ev) {
        if (_this.opt(&#39;selectable&#39;) &amp;&amp; !component.shouldIgnoreMouse()) {
            dragListener.startInteraction(ev, {
                distance: _this.opt(&#39;selectMinDistance&#39;)
            });
        }
    });
    component.bindDateHandlerToEl(el, &#39;touchstart&#39;, function (ev) {
        if (_this.opt(&#39;selectable&#39;) &amp;&amp; !component.shouldIgnoreTouch()) {
            dragListener.startInteraction(ev, {
                delay: _this.getDelay()
            });
        }
    });
    util_1.preventSelection(el);
};
// Creates a listener that tracks the user&#39;s drag across day elements, for day selecting.
DateSelecting.prototype.buildDragListener = function () {
    var _this = this;
    var component = this.component;
    var selectionFootprint; // null if invalid selection
    var dragListener = new HitDragListener_1.default(component, {
        scroll: this.opt(&#39;dragScroll&#39;),
        interactionStart: function () {
            selectionFootprint = null;
        },
        dragStart: function (ev) {
            _this.view.unselect(ev); // since we could be rendering a new selection, we want to clear any old one
        },
        hitOver: function (hit, isOrig, origHit) {
            var origHitFootprint;
            var hitFootprint;
            if (origHit) {
                origHitFootprint = component.getSafeHitFootprint(origHit);
                hitFootprint = component.getSafeHitFootprint(hit);
                if (origHitFootprint &amp;&amp; hitFootprint) {
                    selectionFootprint = _this.computeSelection(origHitFootprint, hitFootprint);
                }
                else {
                    selectionFootprint = null;
                }
                if (selectionFootprint) {
                    component.renderSelectionFootprint(selectionFootprint);
                }
                else if (selectionFootprint === false) {
                    util_1.disableCursor();
                }
            }
        },
        hitOut: function () {
            selectionFootprint = null;
            component.unrenderSelection();
        },
        hitDone: function () {
            util_1.enableCursor();
        },
        interactionEnd: function (ev, isCancelled) {
            if (!isCancelled &amp;&amp; selectionFootprint) {
                // the selection will already have been rendered. just report it
                _this.view.reportSelection(selectionFootprint, ev);
            }
        }
    });
    return dragListener;
};
// Given the first and last date-spans of a selection, returns another date-span object.
// Subclasses can override and provide additional data in the span object. Will be passed to renderSelectionFootprint().
// Will return false if the selection is invalid and this should be indicated to the user.
// Will return null/undefined if a selection invalid but no error should be reported.
DateSelecting.prototype.computeSelection = function (footprint0, footprint1) {
    var wholeFootprint = this.computeSelectionFootprint(footprint0, footprint1);
    if (wholeFootprint &amp;&amp; !this.isSelectionFootprintAllowed(wholeFootprint)) {
        return false;
    }
    return wholeFootprint;
};
// Given two spans, must return the combination of the two.
// TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
// Assumes both footprints are non-open-ended.
DateSelecting.prototype.computeSelectionFootprint = function (footprint0, footprint1) {
    var ms = [
        footprint0.unzonedRange.startMs,
        footprint0.unzonedRange.endMs,
        footprint1.unzonedRange.startMs,
        footprint1.unzonedRange.endMs
    ];
    ms.sort(util_1.compareNumbers);
    return new ComponentFootprint_1.default(new UnzonedRange_1.default(ms[0], ms[3]), footprint0.isAllDay);
};
DateSelecting.prototype.isSelectionFootprintAllowed = function (componentFootprint) {
    return this.component.dateProfile.validUnzonedRange.containsRange(componentFootprint.unzonedRange) &amp;&amp;
        this.view.calendar.constraints.isSelectionFootprintAllowed(componentFootprint);
};
return DateSelecting;</pre>

<p>}(Interaction_1.default)); exports.default = DateSelecting;</p>

<p>/***/ }), /* 226 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var moment = <em>webpack_require</em>(0);
var $ = <em>webpack_require</em>(3); var util_1 =
<em>webpack_require</em>(4); var Scroller_1 = <em>webpack_require</em>(39);
var View_1 = <em>webpack_require</em>(41); var TimeGrid_1 =
<em>webpack_require</em>(227); var DayGrid_1 =
<em>webpack_require</em>(61); var AGENDA_ALL_DAY_EVENT_LIMIT = 5; var
agendaTimeGridMethods; var agendaDayGridMethods; /* An abstract class for
all agenda-related views. Displays one more columns with time slots running
vertically. ———————————————————————————————————————-*/ // Is a manager for
the TimeGrid subcomponent and possibly the DayGrid subcomponent (if
allDaySlot is on). // Responsible for managing width/height. var AgendaView
= /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(AgendaView, _super);
function AgendaView(calendar, viewSpec) {
    var _this = _super.call(this, calendar, viewSpec) || this;
    _this.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering
    _this.timeGrid = _this.instantiateTimeGrid();
    _this.addChild(_this.timeGrid);
    if (_this.opt(&#39;allDaySlot&#39;)) {
        _this.dayGrid = _this.instantiateDayGrid(); // the all-day subcomponent of this view
        _this.addChild(_this.dayGrid);
    }
    _this.scroller = new Scroller_1.default({
        overflowX: &#39;hidden&#39;,
        overflowY: &#39;auto&#39;
    });
    return _this;
}
// Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
AgendaView.prototype.instantiateTimeGrid = function () {
    var timeGrid = new this.timeGridClass(this);
    util_1.copyOwnProps(agendaTimeGridMethods, timeGrid);
    return timeGrid;
};
// Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
AgendaView.prototype.instantiateDayGrid = function () {
    var dayGrid = new this.dayGridClass(this);
    util_1.copyOwnProps(agendaDayGridMethods, dayGrid);
    return dayGrid;
};
/* Rendering
------------------------------------------------------------------------------------------------------------------*/
AgendaView.prototype.renderSkeleton = function () {
    var timeGridWrapEl;
    var timeGridEl;
    this.el.addClass(&#39;fc-agenda-view&#39;).html(this.renderSkeletonHtml());
    this.scroller.render();
    timeGridWrapEl = this.scroller.el.addClass(&#39;fc-time-grid-container&#39;);
    timeGridEl = $(&#39;&lt;div class=&quot;fc-time-grid&quot; /&gt;&#39;).appendTo(timeGridWrapEl);
    this.el.find(&#39;.fc-body &gt; tr &gt; td&#39;).append(timeGridWrapEl);
    this.timeGrid.headContainerEl = this.el.find(&#39;.fc-head-container&#39;);
    this.timeGrid.setElement(timeGridEl);
    if (this.dayGrid) {
        this.dayGrid.setElement(this.el.find(&#39;.fc-day-grid&#39;));
        // have the day-grid extend it&#39;s coordinate area over the &lt;hr&gt; dividing the two grids
        this.dayGrid.bottomCoordPadding = this.dayGrid.el.next(&#39;hr&#39;).outerHeight();
    }
};
AgendaView.prototype.unrenderSkeleton = function () {
    this.timeGrid.removeElement();
    if (this.dayGrid) {
        this.dayGrid.removeElement();
    }
    this.scroller.destroy();
};
// Builds the HTML skeleton for the view.
// The day-grid and time-grid components will render inside containers defined by this HTML.
AgendaView.prototype.renderSkeletonHtml = function () {
    var theme = this.calendar.theme;
    return &#39;&#39; +
        &#39;&lt;table class=&quot;&#39; + theme.getClass(&#39;tableGrid&#39;) + &#39;&quot;&gt;&#39; +
        (this.opt(&#39;columnHeader&#39;) ?
            &#39;&lt;thead class=&quot;fc-head&quot;&gt;&#39; +
                &#39;&lt;tr&gt;&#39; +
                &#39;&lt;td class=&quot;fc-head-container &#39; + theme.getClass(&#39;widgetHeader&#39;) + &#39;&quot;&gt;&amp;nbsp;&lt;/td&gt;&#39; +
                &#39;&lt;/tr&gt;&#39; +
                &#39;&lt;/thead&gt;&#39; :
            &#39;&#39;) +
        &#39;&lt;tbody class=&quot;fc-body&quot;&gt;&#39; +
        &#39;&lt;tr&gt;&#39; +
        &#39;&lt;td class=&quot;&#39; + theme.getClass(&#39;widgetContent&#39;) + &#39;&quot;&gt;&#39; +
        (this.dayGrid ?
            &#39;&lt;div class=&quot;fc-day-grid&quot;/&gt;&#39; +
                &#39;&lt;hr class=&quot;fc-divider &#39; + theme.getClass(&#39;widgetHeader&#39;) + &#39;&quot;/&gt;&#39; :
            &#39;&#39;) +
        &#39;&lt;/td&gt;&#39; +
        &#39;&lt;/tr&gt;&#39; +
        &#39;&lt;/tbody&gt;&#39; +
        &#39;&lt;/table&gt;&#39;;
};
// Generates an HTML attribute string for setting the width of the axis, if it is known
AgendaView.prototype.axisStyleAttr = function () {
    if (this.axisWidth != null) {
        return &#39;style=&quot;width:&#39; + this.axisWidth + &#39;px&quot;&#39;;
    }
    return &#39;&#39;;
};
/* Now Indicator
------------------------------------------------------------------------------------------------------------------*/
AgendaView.prototype.getNowIndicatorUnit = function () {
    return this.timeGrid.getNowIndicatorUnit();
};
/* Dimensions
------------------------------------------------------------------------------------------------------------------*/
// Adjusts the vertical dimensions of the view to the specified values
AgendaView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
    var eventLimit;
    var scrollerHeight;
    var scrollbarWidths;
    _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
    // make all axis cells line up, and record the width so newly created axis cells will have it
    this.axisWidth = util_1.matchCellWidths(this.el.find(&#39;.fc-axis&#39;));
    // hack to give the view some height prior to timeGrid&#39;s columns being rendered
    // TODO: separate setting height from scroller VS timeGrid.
    if (!this.timeGrid.colEls) {
        if (!isAuto) {
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.scroller.setHeight(scrollerHeight);
        }
        return;
    }
    // set of fake row elements that must compensate when scroller has scrollbars
    var noScrollRowEls = this.el.find(&#39;.fc-row:not(.fc-scroller *)&#39;);
    // reset all dimensions back to the original state
    this.timeGrid.bottomRuleEl.hide(); // .show() will be called later if this &lt;hr&gt; is necessary
    this.scroller.clear(); // sets height to &#39;auto&#39; and clears overflow
    util_1.uncompensateScroll(noScrollRowEls);
    // limit number of events in the all-day area
    if (this.dayGrid) {
        this.dayGrid.removeSegPopover(); // kill the &quot;more&quot; popover if displayed
        eventLimit = this.opt(&#39;eventLimit&#39;);
        if (eventLimit &amp;&amp; typeof eventLimit !== &#39;number&#39;) {
            eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure &quot;auto&quot; goes to a real number
        }
        if (eventLimit) {
            this.dayGrid.limitRows(eventLimit);
        }
    }
    if (!isAuto) {
        scrollerHeight = this.computeScrollerHeight(totalHeight);
        this.scroller.setHeight(scrollerHeight);
        scrollbarWidths = this.scroller.getScrollbarWidths();
        if (scrollbarWidths.left || scrollbarWidths.right) {
            // make the all-day and header rows lines up
            util_1.compensateScroll(noScrollRowEls, scrollbarWidths);
            // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
            // and reapply the desired height to the scroller.
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.scroller.setHeight(scrollerHeight);
        }
        // guarantees the same scrollbar widths
        this.scroller.lockOverflow(scrollbarWidths);
        // if there&#39;s any space below the slats, show the horizontal rule.
        // this won&#39;t cause any new overflow, because lockOverflow already called.
        if (this.timeGrid.getTotalSlatHeight() &lt; scrollerHeight) {
            this.timeGrid.bottomRuleEl.show();
        }
    }
};
// given a desired total height of the view, returns what the height of the scroller should be
AgendaView.prototype.computeScrollerHeight = function (totalHeight) {
    return totalHeight -
        util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that&#39;s NOT the scroller
};
/* Scroll
------------------------------------------------------------------------------------------------------------------*/
// Computes the initial pre-configured scroll state prior to allowing the user to change it
AgendaView.prototype.computeInitialDateScroll = function () {
    var scrollTime = moment.duration(this.opt(&#39;scrollTime&#39;));
    var top = this.timeGrid.computeTimeTop(scrollTime);
    // zoom can give weird floating-point values. rather scroll a little bit further
    top = Math.ceil(top);
    if (top) {
        top++; // to overcome top border that slots beyond the first have. looks better
    }
    return { top: top };
};
AgendaView.prototype.queryDateScroll = function () {
    return { top: this.scroller.getScrollTop() };
};
AgendaView.prototype.applyDateScroll = function (scroll) {
    if (scroll.top !== undefined) {
        this.scroller.setScrollTop(scroll.top);
    }
};
/* Hit Areas
------------------------------------------------------------------------------------------------------------------*/
// forward all hit-related method calls to the grids (dayGrid might not be defined)
AgendaView.prototype.getHitFootprint = function (hit) {
    // TODO: hit.component is set as a hack to identify where the hit came from
    return hit.component.getHitFootprint(hit);
};
AgendaView.prototype.getHitEl = function (hit) {
    // TODO: hit.component is set as a hack to identify where the hit came from
    return hit.component.getHitEl(hit);
};
/* Event Rendering
------------------------------------------------------------------------------------------------------------------*/
AgendaView.prototype.executeEventRender = function (eventsPayload) {
    var dayEventsPayload = {};
    var timedEventsPayload = {};
    var id;
    var eventInstanceGroup;
    // separate the events into all-day and timed
    for (id in eventsPayload) {
        eventInstanceGroup = eventsPayload[id];
        if (eventInstanceGroup.getEventDef().isAllDay()) {
            dayEventsPayload[id] = eventInstanceGroup;
        }
        else {
            timedEventsPayload[id] = eventInstanceGroup;
        }
    }
    this.timeGrid.executeEventRender(timedEventsPayload);
    if (this.dayGrid) {
        this.dayGrid.executeEventRender(dayEventsPayload);
    }
};
/* Dragging/Resizing Routing
------------------------------------------------------------------------------------------------------------------*/
// A returned value of `true` signals that a mock &quot;helper&quot; event has been rendered.
AgendaView.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
    var groups = groupEventFootprintsByAllDay(eventFootprints);
    var renderedHelper = false;
    renderedHelper = this.timeGrid.renderDrag(groups.timed, seg, isTouch);
    if (this.dayGrid) {
        renderedHelper = this.dayGrid.renderDrag(groups.allDay, seg, isTouch) || renderedHelper;
    }
    return renderedHelper;
};
AgendaView.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
    var groups = groupEventFootprintsByAllDay(eventFootprints);
    this.timeGrid.renderEventResize(groups.timed, seg, isTouch);
    if (this.dayGrid) {
        this.dayGrid.renderEventResize(groups.allDay, seg, isTouch);
    }
};
/* Selection
------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of a selection
AgendaView.prototype.renderSelectionFootprint = function (componentFootprint) {
    if (!componentFootprint.isAllDay) {
        this.timeGrid.renderSelectionFootprint(componentFootprint);
    }
    else if (this.dayGrid) {
        this.dayGrid.renderSelectionFootprint(componentFootprint);
    }
};
return AgendaView;</pre>

<p>}(View_1.default)); exports.default = AgendaView;
AgendaView.prototype.timeGridClass = TimeGrid_1.default;
AgendaView.prototype.dayGridClass = DayGrid_1.default; // Will customize
the rendering behavior of the AgendaView&#39;s timeGrid
agendaTimeGridMethods = {</p>

<pre>// Generates the HTML that will go before the day-of week header cells
renderHeadIntroHtml: function () {
    var view = this.view;
    var calendar = view.calendar;
    var weekStart = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.startMs, true);
    var weekText;
    if (this.opt(&#39;weekNumbers&#39;)) {
        weekText = weekStart.format(this.opt(&#39;smallWeekFormat&#39;));
        return &#39;&#39; +
            &#39;&lt;th class=&quot;fc-axis fc-week-number &#39; + calendar.theme.getClass(&#39;widgetHeader&#39;) + &#39;&quot; &#39; + view.axisStyleAttr() + &#39;&gt;&#39; +
            view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
            { date: weekStart, type: &#39;week&#39;, forceOff: this.colCnt &gt; 1 }, util_1.htmlEscape(weekText) // inner HTML
            ) +
            &#39;&lt;/th&gt;&#39;;
    }
    else {
        return &#39;&lt;th class=&quot;fc-axis &#39; + calendar.theme.getClass(&#39;widgetHeader&#39;) + &#39;&quot; &#39; + view.axisStyleAttr() + &#39;&gt;&lt;/th&gt;&#39;;
    }
},
// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
renderBgIntroHtml: function () {
    var view = this.view;
    return &#39;&lt;td class=&quot;fc-axis &#39; + view.calendar.theme.getClass(&#39;widgetContent&#39;) + &#39;&quot; &#39; + view.axisStyleAttr() + &#39;&gt;&lt;/td&gt;&#39;;
},
// Generates the HTML that goes before all other types of cells.
// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
renderIntroHtml: function () {
    var view = this.view;
    return &#39;&lt;td class=&quot;fc-axis&quot; &#39; + view.axisStyleAttr() + &#39;&gt;&lt;/td&gt;&#39;;
}</pre>

<p>}; // Will customize the rendering behavior of the AgendaView&#39;s dayGrid
agendaDayGridMethods = {</p>

<pre>// Generates the HTML that goes before the all-day cells
renderBgIntroHtml: function () {
    var view = this.view;
    return &#39;&#39; +
        &#39;&lt;td class=&quot;fc-axis &#39; + view.calendar.theme.getClass(&#39;widgetContent&#39;) + &#39;&quot; &#39; + view.axisStyleAttr() + &#39;&gt;&#39; +
        &#39;&lt;span&gt;&#39; + // needed for matchCellWidths
        view.getAllDayHtml() +
        &#39;&lt;/span&gt;&#39; +
        &#39;&lt;/td&gt;&#39;;
},
// Generates the HTML that goes before all other types of cells.
// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
renderIntroHtml: function () {
    var view = this.view;
    return &#39;&lt;td class=&quot;fc-axis&quot; &#39; + view.axisStyleAttr() + &#39;&gt;&lt;/td&gt;&#39;;
}</pre>

<p>}; function groupEventFootprintsByAllDay(eventFootprints) {</p>

<pre>var allDay = [];
var timed = [];
var i;
for (i = 0; i &lt; eventFootprints.length; i++) {
    if (eventFootprints[i].componentFootprint.isAllDay) {
        allDay.push(eventFootprints[i]);
    }
    else {
        timed.push(eventFootprints[i]);
    }
}
return { allDay: allDay, timed: timed };</pre>

<p>}</p>

<p>/***/ }), /* 227 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
moment = <em>webpack_require</em>(0); var util_1 =
<em>webpack_require</em>(4); var InteractiveDateComponent_1 =
<em>webpack_require</em>(40); var BusinessHourRenderer_1 =
<em>webpack_require</em>(56); var StandardInteractionsMixin_1 =
<em>webpack_require</em>(60); var DayTableMixin_1 =
<em>webpack_require</em>(55); var CoordCache_1 =
<em>webpack_require</em>(53); var UnzonedRange_1 =
<em>webpack_require</em>(5); var ComponentFootprint_1 =
<em>webpack_require</em>(12); var TimeGridEventRenderer_1 =
<em>webpack_require</em>(246); var TimeGridHelperRenderer_1 =
<em>webpack_require</em>(247); var TimeGridFillRenderer_1 =
<em>webpack_require</em>(248); /* A component that renders one or more
columns of vertical time slots ———————————————————————————————————————-*/
// We mixin DayTable, even though there is only a single row of days //
potential nice values for the slot-duration and interval-duration // from
largest to smallest var AGENDA_STOCK_SUB_DURATIONS = [</p>

<pre>{ hours: 1 },
{ minutes: 30 },
{ minutes: 15 },
{ seconds: 30 },
{ seconds: 15 }</pre>

<p>]; var TimeGrid = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(TimeGrid, _super);
function TimeGrid(view) {
    var _this = _super.call(this, view) || this;
    _this.processOptions();
    return _this;
}
// Slices up the given span (unzoned start/end with other misc data) into an array of segments
TimeGrid.prototype.componentFootprintToSegs = function (componentFootprint) {
    var segs = this.sliceRangeByTimes(componentFootprint.unzonedRange);
    var i;
    for (i = 0; i &lt; segs.length; i++) {
        if (this.isRTL) {
            segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
        }
        else {
            segs[i].col = segs[i].dayIndex;
        }
    }
    return segs;
};
/* Date Handling
------------------------------------------------------------------------------------------------------------------*/
TimeGrid.prototype.sliceRangeByTimes = function (unzonedRange) {
    var segs = [];
    var segRange;
    var dayIndex;
    for (dayIndex = 0; dayIndex &lt; this.daysPerRow; dayIndex++) {
        segRange = unzonedRange.intersect(this.dayRanges[dayIndex]);
        if (segRange) {
            segs.push({
                startMs: segRange.startMs,
                endMs: segRange.endMs,
                isStart: segRange.isStart,
                isEnd: segRange.isEnd,
                dayIndex: dayIndex
            });
        }
    }
    return segs;
};
/* Options
------------------------------------------------------------------------------------------------------------------*/
// Parses various options into properties of this object
TimeGrid.prototype.processOptions = function () {
    var slotDuration = this.opt(&#39;slotDuration&#39;);
    var snapDuration = this.opt(&#39;snapDuration&#39;);
    var input;
    slotDuration = moment.duration(slotDuration);
    snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;
    this.slotDuration = slotDuration;
    this.snapDuration = snapDuration;
    this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?
    // might be an array value (for TimelineView).
    // if so, getting the most granular entry (the last one probably).
    input = this.opt(&#39;slotLabelFormat&#39;);
    if ($.isArray(input)) {
        input = input[input.length - 1];
    }
    this.labelFormat = input ||
        this.opt(&#39;smallTimeFormat&#39;); // the computed default
    input = this.opt(&#39;slotLabelInterval&#39;);
    this.labelInterval = input ?
        moment.duration(input) :
        this.computeLabelInterval(slotDuration);
};
// Computes an automatic value for slotLabelInterval
TimeGrid.prototype.computeLabelInterval = function (slotDuration) {
    var i;
    var labelInterval;
    var slotsPerLabel;
    // find the smallest stock label interval that results in more than one slots-per-label
    for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i &gt;= 0; i--) {
        labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
        slotsPerLabel = util_1.divideDurationByDuration(labelInterval, slotDuration);
        if (util_1.isInt(slotsPerLabel) &amp;&amp; slotsPerLabel &gt; 1) {
            return labelInterval;
        }
    }
    return moment.duration(slotDuration); // fall back. clone
};
/* Date Rendering
------------------------------------------------------------------------------------------------------------------*/
TimeGrid.prototype.renderDates = function (dateProfile) {
    this.dateProfile = dateProfile;
    this.updateDayTable();
    this.renderSlats();
    this.renderColumns();
};
TimeGrid.prototype.unrenderDates = function () {
    // this.unrenderSlats(); // don&#39;t need this because repeated .html() calls clear
    this.unrenderColumns();
};
TimeGrid.prototype.renderSkeleton = function () {
    var theme = this.view.calendar.theme;
    this.el.html(&#39;&lt;div class=&quot;fc-bg&quot;&gt;&lt;/div&gt;&#39; +
        &#39;&lt;div class=&quot;fc-slats&quot;&gt;&lt;/div&gt;&#39; +
        &#39;&lt;hr class=&quot;fc-divider &#39; + theme.getClass(&#39;widgetHeader&#39;) + &#39;&quot; style=&quot;display:none&quot; /&gt;&#39;);
    this.bottomRuleEl = this.el.find(&#39;hr&#39;);
};
TimeGrid.prototype.renderSlats = function () {
    var theme = this.view.calendar.theme;
    this.slatContainerEl = this.el.find(&#39;&gt; .fc-slats&#39;)
        .html(// avoids needing ::unrenderSlats()
    &#39;&lt;table class=&quot;&#39; + theme.getClass(&#39;tableGrid&#39;) + &#39;&quot;&gt;&#39; +
        this.renderSlatRowHtml() +
        &#39;&lt;/table&gt;&#39;);
    this.slatEls = this.slatContainerEl.find(&#39;tr&#39;);
    this.slatCoordCache = new CoordCache_1.default({
        els: this.slatEls,
        isVertical: true
    });
};
// Generates the HTML for the horizontal &quot;slats&quot; that run width-wise. Has a time axis on a side. Depends on RTL.
TimeGrid.prototype.renderSlatRowHtml = function () {
    var view = this.view;
    var calendar = view.calendar;
    var theme = calendar.theme;
    var isRTL = this.isRTL;
    var dateProfile = this.dateProfile;
    var html = &#39;&#39;;
    var slotTime = moment.duration(+dateProfile.minTime); // wish there was .clone() for durations
    var slotIterator = moment.duration(0);
    var slotDate; // will be on the view&#39;s first day, but we only care about its time
    var isLabeled;
    var axisHtml;
    // Calculate the time for each slot
    while (slotTime &lt; dateProfile.maxTime) {
        slotDate = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs).time(slotTime);
        isLabeled = util_1.isInt(util_1.divideDurationByDuration(slotIterator, this.labelInterval));
        axisHtml =
            &#39;&lt;td class=&quot;fc-axis fc-time &#39; + theme.getClass(&#39;widgetContent&#39;) + &#39;&quot; &#39; + view.axisStyleAttr() + &#39;&gt;&#39; +
                (isLabeled ?
                    &#39;&lt;span&gt;&#39; + // for matchCellWidths
                        util_1.htmlEscape(slotDate.format(this.labelFormat)) +
                        &#39;&lt;/span&gt;&#39; :
                    &#39;&#39;) +
                &#39;&lt;/td&gt;&#39;;
        html +=
            &#39;&lt;tr data-time=&quot;&#39; + slotDate.format(&#39;HH:mm:ss&#39;) + &#39;&quot;&#39; +
                (isLabeled ? &#39;&#39; : &#39; class=&quot;fc-minor&quot;&#39;) +
                &#39;&gt;&#39; +
                (!isRTL ? axisHtml : &#39;&#39;) +
                &#39;&lt;td class=&quot;&#39; + theme.getClass(&#39;widgetContent&#39;) + &#39;&quot;/&gt;&#39; +
                (isRTL ? axisHtml : &#39;&#39;) +
                &#39;&lt;/tr&gt;&#39;;
        slotTime.add(this.slotDuration);
        slotIterator.add(this.slotDuration);
    }
    return html;
};
TimeGrid.prototype.renderColumns = function () {
    var dateProfile = this.dateProfile;
    var theme = this.view.calendar.theme;
    this.dayRanges = this.dayDates.map(function (dayDate) {
        return new UnzonedRange_1.default(dayDate.clone().add(dateProfile.minTime), dayDate.clone().add(dateProfile.maxTime));
    });
    if (this.headContainerEl) {
        this.headContainerEl.html(this.renderHeadHtml());
    }
    this.el.find(&#39;&gt; .fc-bg&#39;).html(&#39;&lt;table class=&quot;&#39; + theme.getClass(&#39;tableGrid&#39;) + &#39;&quot;&gt;&#39; +
        this.renderBgTrHtml(0) + // row=0
        &#39;&lt;/table&gt;&#39;);
    this.colEls = this.el.find(&#39;.fc-day, .fc-disabled-day&#39;);
    this.colCoordCache = new CoordCache_1.default({
        els: this.colEls,
        isHorizontal: true
    });
    this.renderContentSkeleton();
};
TimeGrid.prototype.unrenderColumns = function () {
    this.unrenderContentSkeleton();
};
/* Content Skeleton
------------------------------------------------------------------------------------------------------------------*/
// Renders the DOM that the view&#39;s content will live in
TimeGrid.prototype.renderContentSkeleton = function () {
    var cellHtml = &#39;&#39;;
    var i;
    var skeletonEl;
    for (i = 0; i &lt; this.colCnt; i++) {
        cellHtml +=
            &#39;&lt;td&gt;&#39; +
                &#39;&lt;div class=&quot;fc-content-col&quot;&gt;&#39; +
                &#39;&lt;div class=&quot;fc-event-container fc-helper-container&quot;&gt;&lt;/div&gt;&#39; +
                &#39;&lt;div class=&quot;fc-event-container&quot;&gt;&lt;/div&gt;&#39; +
                &#39;&lt;div class=&quot;fc-highlight-container&quot;&gt;&lt;/div&gt;&#39; +
                &#39;&lt;div class=&quot;fc-bgevent-container&quot;&gt;&lt;/div&gt;&#39; +
                &#39;&lt;div class=&quot;fc-business-container&quot;&gt;&lt;/div&gt;&#39; +
                &#39;&lt;/div&gt;&#39; +
                &#39;&lt;/td&gt;&#39;;
    }
    skeletonEl = this.contentSkeletonEl = $(&#39;&lt;div class=&quot;fc-content-skeleton&quot;&gt;&#39; +
        &#39;&lt;table&gt;&#39; +
        &#39;&lt;tr&gt;&#39; + cellHtml + &#39;&lt;/tr&gt;&#39; +
        &#39;&lt;/table&gt;&#39; +
        &#39;&lt;/div&gt;&#39;);
    this.colContainerEls = skeletonEl.find(&#39;.fc-content-col&#39;);
    this.helperContainerEls = skeletonEl.find(&#39;.fc-helper-container&#39;);
    this.fgContainerEls = skeletonEl.find(&#39;.fc-event-container:not(.fc-helper-container)&#39;);
    this.bgContainerEls = skeletonEl.find(&#39;.fc-bgevent-container&#39;);
    this.highlightContainerEls = skeletonEl.find(&#39;.fc-highlight-container&#39;);
    this.businessContainerEls = skeletonEl.find(&#39;.fc-business-container&#39;);
    this.bookendCells(skeletonEl.find(&#39;tr&#39;)); // TODO: do this on string level
    this.el.append(skeletonEl);
};
TimeGrid.prototype.unrenderContentSkeleton = function () {
    if (this.contentSkeletonEl) {
        this.contentSkeletonEl.remove();
        this.contentSkeletonEl = null;
        this.colContainerEls = null;
        this.helperContainerEls = null;
        this.fgContainerEls = null;
        this.bgContainerEls = null;
        this.highlightContainerEls = null;
        this.businessContainerEls = null;
    }
};
// Given a flat array of segments, return an array of sub-arrays, grouped by each segment&#39;s col
TimeGrid.prototype.groupSegsByCol = function (segs) {
    var segsByCol = [];
    var i;
    for (i = 0; i &lt; this.colCnt; i++) {
        segsByCol.push([]);
    }
    for (i = 0; i &lt; segs.length; i++) {
        segsByCol[segs[i].col].push(segs[i]);
    }
    return segsByCol;
};
// Given segments grouped by column, insert the segments&#39; elements into a parallel array of container
// elements, each living within a column.
TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {
    var col;
    var segs;
    var i;
    for (col = 0; col &lt; this.colCnt; col++) {
        segs = segsByCol[col];
        for (i = 0; i &lt; segs.length; i++) {
            containerEls.eq(col).append(segs[i].el);
        }
    }
};
/* Now Indicator
------------------------------------------------------------------------------------------------------------------*/
TimeGrid.prototype.getNowIndicatorUnit = function () {
    return &#39;minute&#39;; // will refresh on the minute
};
TimeGrid.prototype.renderNowIndicator = function (date) {
    // HACK: if date columns not ready for some reason (scheduler)
    if (!this.colContainerEls) {
        return;
    }
    // seg system might be overkill, but it handles scenario where line needs to be rendered
    //  more than once because of columns with the same date (resources columns for example)
    var segs = this.componentFootprintToSegs(new ComponentFootprint_1.default(new UnzonedRange_1.default(date, date.valueOf() + 1), // protect against null range
    false // all-day
    ));
    var top = this.computeDateTop(date, date);
    var nodes = [];
    var i;
    // render lines within the columns
    for (i = 0; i &lt; segs.length; i++) {
        nodes.push($(&#39;&lt;div class=&quot;fc-now-indicator fc-now-indicator-line&quot;&gt;&lt;/div&gt;&#39;)
            .css(&#39;top&#39;, top)
            .appendTo(this.colContainerEls.eq(segs[i].col))[0]);
    }
    // render an arrow over the axis
    if (segs.length &gt; 0) {
        nodes.push($(&#39;&lt;div class=&quot;fc-now-indicator fc-now-indicator-arrow&quot;&gt;&lt;/div&gt;&#39;)
            .css(&#39;top&#39;, top)
            .appendTo(this.el.find(&#39;.fc-content-skeleton&#39;))[0]);
    }
    this.nowIndicatorEls = $(nodes);
};
TimeGrid.prototype.unrenderNowIndicator = function () {
    if (this.nowIndicatorEls) {
        this.nowIndicatorEls.remove();
        this.nowIndicatorEls = null;
    }
};
/* Coordinates
------------------------------------------------------------------------------------------------------------------*/
TimeGrid.prototype.updateSize = function (totalHeight, isAuto, isResize) {
    _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
    this.slatCoordCache.build();
    if (isResize) {
        this.updateSegVerticals([].concat(this.eventRenderer.getSegs(), this.businessSegs || []));
    }
};
TimeGrid.prototype.getTotalSlatHeight = function () {
    return this.slatContainerEl.outerHeight();
};
// Computes the top coordinate, relative to the bounds of the grid, of the given date.
// `ms` can be a millisecond UTC time OR a UTC moment.
// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
TimeGrid.prototype.computeDateTop = function (ms, startOfDayDate) {
    return this.computeTimeTop(moment.duration(ms - startOfDayDate.clone().stripTime()));
};
// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
TimeGrid.prototype.computeTimeTop = function (time) {
    var len = this.slatEls.length;
    var dateProfile = this.dateProfile;
    var slatCoverage = (time - dateProfile.minTime) / this.slotDuration; // floating-point value of # of slots covered
    var slatIndex;
    var slatRemainder;
    // compute a floating-point number for how many slats should be progressed through.
    // from 0 to number of slats (inclusive)
    // constrained because minTime/maxTime might be customized.
    slatCoverage = Math.max(0, slatCoverage);
    slatCoverage = Math.min(len, slatCoverage);
    // an integer index of the furthest whole slat
    // from 0 to number slats (*exclusive*, so len-1)
    slatIndex = Math.floor(slatCoverage);
    slatIndex = Math.min(slatIndex, len - 1);
    // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
    // could be 1.0 if slatCoverage is covering *all* the slots
    slatRemainder = slatCoverage - slatIndex;
    return this.slatCoordCache.getTopPosition(slatIndex) +
        this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
};
// Refreshes the CSS top/bottom coordinates for each segment element.
// Works when called after initial render, after a window resize/zoom for example.
TimeGrid.prototype.updateSegVerticals = function (segs) {
    this.computeSegVerticals(segs);
    this.assignSegVerticals(segs);
};
// For each segment in an array, computes and assigns its top and bottom properties
TimeGrid.prototype.computeSegVerticals = function (segs) {
    var eventMinHeight = this.opt(&#39;agendaEventMinHeight&#39;);
    var i;
    var seg;
    var dayDate;
    for (i = 0; i &lt; segs.length; i++) {
        seg = segs[i];
        dayDate = this.dayDates[seg.dayIndex];
        seg.top = this.computeDateTop(seg.startMs, dayDate);
        seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.endMs, dayDate));
    }
};
// Given segments that already have their top/bottom properties computed, applies those values to
// the segments&#39; elements.
TimeGrid.prototype.assignSegVerticals = function (segs) {
    var i;
    var seg;
    for (i = 0; i &lt; segs.length; i++) {
        seg = segs[i];
        seg.el.css(this.generateSegVerticalCss(seg));
    }
};
// Generates an object with CSS properties for the top/bottom coordinates of a segment element
TimeGrid.prototype.generateSegVerticalCss = function (seg) {
    return {
        top: seg.top,
        bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
    };
};
/* Hit System
------------------------------------------------------------------------------------------------------------------*/
TimeGrid.prototype.prepareHits = function () {
    this.colCoordCache.build();
    this.slatCoordCache.build();
};
TimeGrid.prototype.releaseHits = function () {
    this.colCoordCache.clear();
    // NOTE: don&#39;t clear slatCoordCache because we rely on it for computeTimeTop
};
TimeGrid.prototype.queryHit = function (leftOffset, topOffset) {
    var snapsPerSlot = this.snapsPerSlot;
    var colCoordCache = this.colCoordCache;
    var slatCoordCache = this.slatCoordCache;
    if (colCoordCache.isLeftInBounds(leftOffset) &amp;&amp; slatCoordCache.isTopInBounds(topOffset)) {
        var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
        var slatIndex = slatCoordCache.getVerticalIndex(topOffset);
        if (colIndex != null &amp;&amp; slatIndex != null) {
            var slatTop = slatCoordCache.getTopOffset(slatIndex);
            var slatHeight = slatCoordCache.getHeight(slatIndex);
            var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
            var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
            var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
            var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
            var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;
            return {
                col: colIndex,
                snap: snapIndex,
                component: this,
                left: colCoordCache.getLeftOffset(colIndex),
                right: colCoordCache.getRightOffset(colIndex),
                top: snapTop,
                bottom: snapBottom
            };
        }
    }
};
TimeGrid.prototype.getHitFootprint = function (hit) {
    var start = this.getCellDate(0, hit.col); // row=0
    var time = this.computeSnapTime(hit.snap); // pass in the snap-index
    var end;
    start.time(time);
    end = start.clone().add(this.snapDuration);
    return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), false // all-day?
    );
};
// Given a row number of the grid, representing a &quot;snap&quot;, returns a time (Duration) from its start-of-day
TimeGrid.prototype.computeSnapTime = function (snapIndex) {
    return moment.duration(this.dateProfile.minTime + this.snapDuration * snapIndex);
};
TimeGrid.prototype.getHitEl = function (hit) {
    return this.colEls.eq(hit.col);
};
/* Event Drag Visualization
------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event being dragged over the specified date(s).
// A returned value of `true` signals that a mock &quot;helper&quot; event has been rendered.
TimeGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
    var i;
    if (seg) {
        if (eventFootprints.length) {
            this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);
            // signal that a helper has been rendered
            return true;
        }
    }
    else {
        for (i = 0; i &lt; eventFootprints.length; i++) {
            this.renderHighlight(eventFootprints[i].componentFootprint);
        }
    }
};
// Unrenders any visual indication of an event being dragged
TimeGrid.prototype.unrenderDrag = function () {
    this.unrenderHighlight();
    this.helperRenderer.unrender();
};
/* Event Resize Visualization
------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event being resized
TimeGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
    this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);
};
// Unrenders any visual indication of an event being resized
TimeGrid.prototype.unrenderEventResize = function () {
    this.helperRenderer.unrender();
};
/* Selection
------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
TimeGrid.prototype.renderSelectionFootprint = function (componentFootprint) {
    if (this.opt(&#39;selectHelper&#39;)) {
        this.helperRenderer.renderComponentFootprint(componentFootprint);
    }
    else {
        this.renderHighlight(componentFootprint);
    }
};
// Unrenders any visual indication of a selection
TimeGrid.prototype.unrenderSelection = function () {
    this.helperRenderer.unrender();
    this.unrenderHighlight();
};
return TimeGrid;</pre>

<p>}(InteractiveDateComponent_1.default)); exports.default = TimeGrid;
TimeGrid.prototype.eventRendererClass = TimeGridEventRenderer_1.default;
TimeGrid.prototype.businessHourRendererClass =
BusinessHourRenderer_1.default; TimeGrid.prototype.helperRendererClass =
TimeGridHelperRenderer_1.default; TimeGrid.prototype.fillRendererClass =
TimeGridFillRenderer_1.default;
StandardInteractionsMixin_1.default.mixInto(TimeGrid);
DayTableMixin_1.default.mixInto(TimeGrid);</p>

<p>/***/ }), /* 228 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var UnzonedRange_1 =
<em>webpack_require</em>(5); var DateProfileGenerator_1 =
<em>webpack_require</em>(221); var BasicViewDateProfileGenerator = /**
@class */ (function (_super) {</p>

<pre>tslib_1.__extends(BasicViewDateProfileGenerator, _super);
function BasicViewDateProfileGenerator() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
// Computes the date range that will be rendered.
BasicViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
    var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay); // an UnzonedRange
    var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);
    var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);
    // year and month views should be aligned with weeks. this is already done for week
    if (/^(year|month)$/.test(currentRangeUnit)) {
        start.startOf(&#39;week&#39;);
        // make end-of-week if not already
        if (end.weekday()) {
            end.add(1, &#39;week&#39;).startOf(&#39;week&#39;); // exclusively move backwards
        }
    }
    return new UnzonedRange_1.default(start, end);
};
return BasicViewDateProfileGenerator;</pre>

<p>}(DateProfileGenerator_1.default)); exports.default =
BasicViewDateProfileGenerator;</p>

<p>/***/ }), /* 229 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var moment = <em>webpack_require</em>(0);
var util_1 = <em>webpack_require</em>(4); var BasicView_1 =
<em>webpack_require</em>(62); var MonthViewDateProfileGenerator_1 =
<em>webpack_require</em>(253); /* A month view with day cells running in
rows (one-per-week) and columns ———————————————————————————————————————-*/
var MonthView = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(MonthView, _super);
function MonthView() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
// Overrides the default BasicView behavior to have special multi-week auto-height logic
MonthView.prototype.setGridHeight = function (height, isAuto) {
    // if auto, make the height of each row the height that it would be if there were 6 weeks
    if (isAuto) {
        height *= this.dayGrid.rowCnt / 6;
    }
    util_1.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don&#39;t compensate for height-hogging rows
};
MonthView.prototype.isDateInOtherMonth = function (date, dateProfile) {
    return date.month() !== moment.utc(dateProfile.currentUnzonedRange.startMs).month(); // TODO: optimize
};
return MonthView;</pre>

<p>}(BasicView_1.default)); exports.default = MonthView;
MonthView.prototype.dateProfileGeneratorClass =
MonthViewDateProfileGenerator_1.default;</p>

<p>/***/ }), /* 230 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var UnzonedRange_1 =
<em>webpack_require</em>(5); var View_1 = <em>webpack_require</em>(41); var
Scroller_1 = <em>webpack_require</em>(39); var ListEventRenderer_1 =
<em>webpack_require</em>(254); var ListEventPointing_1 =
<em>webpack_require</em>(255); /* Responsible for the scroller, and
forwarding event-related actions into the “grid”.</p>

<pre>/</pre>

<p>var ListView = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(ListView, _super);
function ListView(calendar, viewSpec) {
    var _this = _super.call(this, calendar, viewSpec) || this;
    _this.segSelector = &#39;.fc-list-item&#39;; // which elements accept event actions
    _this.scroller = new Scroller_1.default({
        overflowX: &#39;hidden&#39;,
        overflowY: &#39;auto&#39;
    });
    return _this;
}
ListView.prototype.renderSkeleton = function () {
    this.el.addClass(&#39;fc-list-view &#39; +
        this.calendar.theme.getClass(&#39;listView&#39;));
    this.scroller.render();
    this.scroller.el.appendTo(this.el);
    this.contentEl = this.scroller.scrollEl; // shortcut
};
ListView.prototype.unrenderSkeleton = function () {
    this.scroller.destroy(); // will remove the Grid too
};
ListView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
    _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
    this.scroller.clear(); // sets height to &#39;auto&#39; and clears overflow
    if (!isAuto) {
        this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
    }
};
ListView.prototype.computeScrollerHeight = function (totalHeight) {
    return totalHeight -
        util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that&#39;s NOT the scroller
};
ListView.prototype.renderDates = function (dateProfile) {
    var calendar = this.calendar;
    var dayStart = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs, true);
    var viewEnd = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.endMs, true);
    var dayDates = [];
    var dayRanges = [];
    while (dayStart &lt; viewEnd) {
        dayDates.push(dayStart.clone());
        dayRanges.push(new UnzonedRange_1.default(dayStart, dayStart.clone().add(1, &#39;day&#39;)));
        dayStart.add(1, &#39;day&#39;);
    }
    this.dayDates = dayDates;
    this.dayRanges = dayRanges;
    // all real rendering happens in EventRenderer
};
// slices by day
ListView.prototype.componentFootprintToSegs = function (footprint) {
    var dayRanges = this.dayRanges;
    var dayIndex;
    var segRange;
    var seg;
    var segs = [];
    for (dayIndex = 0; dayIndex &lt; dayRanges.length; dayIndex++) {
        segRange = footprint.unzonedRange.intersect(dayRanges[dayIndex]);
        if (segRange) {
            seg = {
                startMs: segRange.startMs,
                endMs: segRange.endMs,
                isStart: segRange.isStart,
                isEnd: segRange.isEnd,
                dayIndex: dayIndex
            };
            segs.push(seg);
            // detect when footprint won&#39;t go fully into the next day,
            // and mutate the latest seg to the be the end.
            if (!seg.isEnd &amp;&amp; !footprint.isAllDay &amp;&amp;
                dayIndex + 1 &lt; dayRanges.length &amp;&amp;
                footprint.unzonedRange.endMs &lt; dayRanges[dayIndex + 1].startMs + this.nextDayThreshold) {
                seg.endMs = footprint.unzonedRange.endMs;
                seg.isEnd = true;
                break;
            }
        }
    }
    return segs;
};
ListView.prototype.renderEmptyMessage = function () {
    this.contentEl.html(&#39;&lt;div class=&quot;fc-list-empty-wrap2&quot;&gt;&#39; + // TODO: try less wraps
        &#39;&lt;div class=&quot;fc-list-empty-wrap1&quot;&gt;&#39; +
        &#39;&lt;div class=&quot;fc-list-empty&quot;&gt;&#39; +
        util_1.htmlEscape(this.opt(&#39;noEventsMessage&#39;)) +
        &#39;&lt;/div&gt;&#39; +
        &#39;&lt;/div&gt;&#39; +
        &#39;&lt;/div&gt;&#39;);
};
// render the event segments in the view
ListView.prototype.renderSegList = function (allSegs) {
    var segsByDay = this.groupSegsByDay(allSegs); // sparse array
    var dayIndex;
    var daySegs;
    var i;
    var tableEl = $(&#39;&lt;table class=&quot;fc-list-table &#39; + this.calendar.theme.getClass(&#39;tableList&#39;) + &#39;&quot;&gt;&lt;tbody/&gt;&lt;/table&gt;&#39;);
    var tbodyEl = tableEl.find(&#39;tbody&#39;);
    for (dayIndex = 0; dayIndex &lt; segsByDay.length; dayIndex++) {
        daySegs = segsByDay[dayIndex];
        if (daySegs) {
            // append a day header
            tbodyEl.append(this.dayHeaderHtml(this.dayDates[dayIndex]));
            this.eventRenderer.sortEventSegs(daySegs);
            for (i = 0; i &lt; daySegs.length; i++) {
                tbodyEl.append(daySegs[i].el); // append event row
            }
        }
    }
    this.contentEl.empty().append(tableEl);
};
// Returns a sparse array of arrays, segs grouped by their dayIndex
ListView.prototype.groupSegsByDay = function (segs) {
    var segsByDay = []; // sparse array
    var i;
    var seg;
    for (i = 0; i &lt; segs.length; i++) {
        seg = segs[i];
        (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
            .push(seg);
    }
    return segsByDay;
};
// generates the HTML for the day headers that live amongst the event rows
ListView.prototype.dayHeaderHtml = function (dayDate) {
    var mainFormat = this.opt(&#39;listDayFormat&#39;);
    var altFormat = this.opt(&#39;listDayAltFormat&#39;);
    return &#39;&lt;tr class=&quot;fc-list-heading&quot; data-date=&quot;&#39; + dayDate.format(&#39;YYYY-MM-DD&#39;) + &#39;&quot;&gt;&#39; +
        &#39;&lt;td class=&quot;&#39; + (this.calendar.theme.getClass(&#39;tableListHeading&#39;) ||
        this.calendar.theme.getClass(&#39;widgetHeader&#39;)) + &#39;&quot; colspan=&quot;3&quot;&gt;&#39; +
        (mainFormat ?
            this.buildGotoAnchorHtml(dayDate, { &#39;class&#39;: &#39;fc-list-heading-main&#39; }, util_1.htmlEscape(dayDate.format(mainFormat)) // inner HTML
            ) :
            &#39;&#39;) +
        (altFormat ?
            this.buildGotoAnchorHtml(dayDate, { &#39;class&#39;: &#39;fc-list-heading-alt&#39; }, util_1.htmlEscape(dayDate.format(altFormat)) // inner HTML
            ) :
            &#39;&#39;) +
        &#39;&lt;/td&gt;&#39; +
        &#39;&lt;/tr&gt;&#39;;
};
return ListView;</pre>

<p>}(View_1.default)); exports.default = ListView;
ListView.prototype.eventRendererClass = ListEventRenderer_1.default;
ListView.prototype.eventPointingClass = ListEventPointing_1.default;</p>

<p>/***/ }), /* 231 */, /* 232 */, /* 233 */, /* 234 */, /* 235 */, /* 236 */
/***/ (function(module, exports, <em>webpack_require</em>) {</p>

<p>var $ = <em>webpack_require</em>(3); var exportHooks =
<em>webpack_require</em>(16); var util_1 = <em>webpack_require</em>(4); var
Calendar_1 = <em>webpack_require</em>(220); // for intentional side-effects
<em>webpack_require</em>(10); <em>webpack_require</em>(47);
<em>webpack_require</em>(256); <em>webpack_require</em>(257);
<em>webpack_require</em>(260); <em>webpack_require</em>(261);
<em>webpack_require</em>(262); <em>webpack_require</em>(263);
$.fullCalendar = exportHooks; $.fn.fullCalendar = function (options) {</p>

<pre>var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
var res = this; // what this function will return (this jQuery object by default)
this.each(function (i, _element) {
    var element = $(_element);
    var calendar = element.data(&#39;fullCalendar&#39;); // get the existing calendar object (if any)
    var singleRes; // the returned value of this single method call
    // a method call
    if (typeof options === &#39;string&#39;) {
        if (options === &#39;getCalendar&#39;) {
            if (!i) {
                res = calendar;
            }
        }
        else if (options === &#39;destroy&#39;) {
            if (calendar) {
                calendar.destroy();
                element.removeData(&#39;fullCalendar&#39;);
            }
        }
        else if (!calendar) {
            util_1.warn(&#39;Attempting to call a FullCalendar method on an element with no calendar.&#39;);
        }
        else if ($.isFunction(calendar[options])) {
            singleRes = calendar[options].apply(calendar, args);
            if (!i) {
                res = singleRes; // record the first method call result
            }
            if (options === &#39;destroy&#39;) {
                element.removeData(&#39;fullCalendar&#39;);
            }
        }
        else {
            util_1.warn(&quot;&#39;&quot; + options + &quot;&#39; is an unknown FullCalendar method.&quot;);
        }
    }
    else if (!calendar) {
        calendar = new Calendar_1.default(element, options);
        element.data(&#39;fullCalendar&#39;, calendar);
        calendar.render();
    }
});
return res;</pre>

<p>}; module.exports = exportHooks;</p>

<p>/***/ }), /* 237 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var Model_1 = <em>webpack_require</em>(48);
var Component = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(Component, _super);
function Component() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
Component.prototype.setElement = function (el) {
    this.el = el;
    this.bindGlobalHandlers();
    this.renderSkeleton();
    this.set(&#39;isInDom&#39;, true);
};
Component.prototype.removeElement = function () {
    this.unset(&#39;isInDom&#39;);
    this.unrenderSkeleton();
    this.unbindGlobalHandlers();
    this.el.remove();
    // NOTE: don&#39;t null-out this.el in case the View was destroyed within an API callback.
    // We don&#39;t null-out the View&#39;s other jQuery element references upon destroy,
    //  so we shouldn&#39;t kill this.el either.
};
Component.prototype.bindGlobalHandlers = function () {
    // subclasses can override
};
Component.prototype.unbindGlobalHandlers = function () {
    // subclasses can override
};
/*
NOTE: Can&#39;t have a `render` method. Read the deprecation notice in View::executeDateRender
 /
// Renders the basic structure of the view before any content is rendered
Component.prototype.renderSkeleton = function () {
    // subclasses should implement
};
// Unrenders the basic structure of the view
Component.prototype.unrenderSkeleton = function () {
    // subclasses should implement
};
return Component;</pre>

<p>}(Model_1.default)); exports.default = Component;</p>

<p>/***/ }), /* 238 */ /***/ (function(module, exports) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var Iterator
= /** @class */ (function () {</p>

<pre>function Iterator(items) {
    this.items = items || [];
}
/* Calls a method on every item passing the arguments through */
Iterator.prototype.proxyCall = function (methodName) {
    var args = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var results = [];
    this.items.forEach(function (item) {
        results.push(item[methodName].apply(item, args));
    });
    return results;
};
return Iterator;</pre>

<p>}()); exports.default = Iterator;</p>

<p>/***/ }), /* 239 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var util_1 = <em>webpack_require</em>(4); /*
Toolbar with buttons and title ———————————————————————————————————————-*/
var Toolbar = /** @class */ (function () {</p>

<pre>function Toolbar(calendar, toolbarOptions) {
    this.el = null; // mirrors local `el`
    this.viewsWithButtons = [];
    this.calendar = calendar;
    this.toolbarOptions = toolbarOptions;
}
// method to update toolbar-specific options, not calendar-wide options
Toolbar.prototype.setToolbarOptions = function (newToolbarOptions) {
    this.toolbarOptions = newToolbarOptions;
};
// can be called repeatedly and will rerender
Toolbar.prototype.render = function () {
    var sections = this.toolbarOptions.layout;
    var el = this.el;
    if (sections) {
        if (!el) {
            el = this.el = $(&quot;&lt;div class=&#39;fc-toolbar &quot; + this.toolbarOptions.extraClasses + &quot;&#39;/&gt;&quot;);
        }
        else {
            el.empty();
        }
        el.append(this.renderSection(&#39;left&#39;))
            .append(this.renderSection(&#39;right&#39;))
            .append(this.renderSection(&#39;center&#39;))
            .append(&#39;&lt;div class=&quot;fc-clear&quot;/&gt;&#39;);
    }
    else {
        this.removeElement();
    }
};
Toolbar.prototype.removeElement = function () {
    if (this.el) {
        this.el.remove();
        this.el = null;
    }
};
Toolbar.prototype.renderSection = function (position) {
    var _this = this;
    var calendar = this.calendar;
    var theme = calendar.theme;
    var optionsManager = calendar.optionsManager;
    var viewSpecManager = calendar.viewSpecManager;
    var sectionEl = $(&#39;&lt;div class=&quot;fc-&#39; + position + &#39;&quot;/&gt;&#39;);
    var buttonStr = this.toolbarOptions.layout[position];
    var calendarCustomButtons = optionsManager.get(&#39;customButtons&#39;) || {};
    var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};
    var calendarButtonText = optionsManager.get(&#39;buttonText&#39;) || {};
    if (buttonStr) {
        $.each(buttonStr.split(&#39; &#39;), function (i, buttonGroupStr) {
            var groupChildren = $();
            var isOnlyButtons = true;
            var groupEl;
            $.each(buttonGroupStr.split(&#39;,&#39;), function (j, buttonName) {
                var customButtonProps;
                var viewSpec;
                var buttonClick;
                var buttonIcon; // only one of these will be set
                var buttonText; // &quot;
                var buttonInnerHtml;
                var buttonClasses;
                var buttonEl;
                var buttonAriaAttr;
                if (buttonName === &#39;title&#39;) {
                    groupChildren = groupChildren.add($(&#39;&lt;h2&gt;&amp;nbsp;&lt;/h2&gt;&#39;)); // we always want it to take up height
                    isOnlyButtons = false;
                }
                else {
                    if ((customButtonProps = calendarCustomButtons[buttonName])) {
                        buttonClick = function (ev) {
                            if (customButtonProps.click) {
                                customButtonProps.click.call(buttonEl[0], ev);
                            }
                        };
                        (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||
                            (buttonIcon = theme.getIconClass(buttonName)) ||
                            (buttonText = customButtonProps.text);
                    }
                    else if ((viewSpec = viewSpecManager.getViewSpec(buttonName))) {
                        _this.viewsWithButtons.push(buttonName);
                        buttonClick = function () {
                            calendar.changeView(buttonName);
                        };
                        (buttonText = viewSpec.buttonTextOverride) ||
                            (buttonIcon = theme.getIconClass(buttonName)) ||
                            (buttonText = viewSpec.buttonTextDefault);
                    }
                    else if (calendar[buttonName]) {
                        buttonClick = function () {
                            calendar[buttonName]();
                        };
                        (buttonText = calendarButtonTextOverrides[buttonName]) ||
                            (buttonIcon = theme.getIconClass(buttonName)) ||
                            (buttonText = calendarButtonText[buttonName]);
                        //            ^ everything else is considered default
                    }
                    if (buttonClick) {
                        buttonClasses = [
                            &#39;fc-&#39; + buttonName + &#39;-button&#39;,
                            theme.getClass(&#39;button&#39;),
                            theme.getClass(&#39;stateDefault&#39;)
                        ];
                        if (buttonText) {
                            buttonInnerHtml = util_1.htmlEscape(buttonText);
                            buttonAriaAttr = &#39;&#39;;
                        }
                        else if (buttonIcon) {
                            buttonInnerHtml = &quot;&lt;span class=&#39;&quot; + buttonIcon + &quot;&#39;&gt;&lt;/span&gt;&quot;;
                            buttonAriaAttr = &#39; aria-label=&quot;&#39; + buttonName + &#39;&quot;&#39;;
                        }
                        buttonEl = $(// type=&quot;button&quot; so that it doesn&#39;t submit a form
                        &#39;&lt;button type=&quot;button&quot; class=&quot;&#39; + buttonClasses.join(&#39; &#39;) + &#39;&quot;&#39; +
                            buttonAriaAttr +
                            &#39;&gt;&#39; + buttonInnerHtml + &#39;&lt;/button&gt;&#39;)
                            .click(function (ev) {
                            // don&#39;t process clicks for disabled buttons
                            if (!buttonEl.hasClass(theme.getClass(&#39;stateDisabled&#39;))) {
                                buttonClick(ev);
                                // after the click action, if the button becomes the &quot;active&quot; tab, or disabled,
                                // it should never have a hover class, so remove it now.
                                if (buttonEl.hasClass(theme.getClass(&#39;stateActive&#39;)) ||
                                    buttonEl.hasClass(theme.getClass(&#39;stateDisabled&#39;))) {
                                    buttonEl.removeClass(theme.getClass(&#39;stateHover&#39;));
                                }
                            }
                        })
                            .mousedown(function () {
                            // the *down* effect (mouse pressed in).
                            // only on buttons that are not the &quot;active&quot; tab, or disabled
                            buttonEl
                                .not(&#39;.&#39; + theme.getClass(&#39;stateActive&#39;))
                                .not(&#39;.&#39; + theme.getClass(&#39;stateDisabled&#39;))
                                .addClass(theme.getClass(&#39;stateDown&#39;));
                        })
                            .mouseup(function () {
                            // undo the *down* effect
                            buttonEl.removeClass(theme.getClass(&#39;stateDown&#39;));
                        })
                            .hover(function () {
                            // the *hover* effect.
                            // only on buttons that are not the &quot;active&quot; tab, or disabled
                            buttonEl
                                .not(&#39;.&#39; + theme.getClass(&#39;stateActive&#39;))
                                .not(&#39;.&#39; + theme.getClass(&#39;stateDisabled&#39;))
                                .addClass(theme.getClass(&#39;stateHover&#39;));
                        }, function () {
                            // undo the *hover* effect
                            buttonEl
                                .removeClass(theme.getClass(&#39;stateHover&#39;))
                                .removeClass(theme.getClass(&#39;stateDown&#39;)); // if mouseleave happens before mouseup
                        });
                        groupChildren = groupChildren.add(buttonEl);
                    }
                }
            });
            if (isOnlyButtons) {
                groupChildren
                    .first().addClass(theme.getClass(&#39;cornerLeft&#39;)).end()
                    .last().addClass(theme.getClass(&#39;cornerRight&#39;)).end();
            }
            if (groupChildren.length &gt; 1) {
                groupEl = $(&#39;&lt;div/&gt;&#39;);
                if (isOnlyButtons) {
                    groupEl.addClass(theme.getClass(&#39;buttonGroup&#39;));
                }
                groupEl.append(groupChildren);
                sectionEl.append(groupEl);
            }
            else {
                sectionEl.append(groupChildren); // 1 or 0 children
            }
        });
    }
    return sectionEl;
};
Toolbar.prototype.updateTitle = function (text) {
    if (this.el) {
        this.el.find(&#39;h2&#39;).text(text);
    }
};
Toolbar.prototype.activateButton = function (buttonName) {
    if (this.el) {
        this.el.find(&#39;.fc-&#39; + buttonName + &#39;-button&#39;)
            .addClass(this.calendar.theme.getClass(&#39;stateActive&#39;));
    }
};
Toolbar.prototype.deactivateButton = function (buttonName) {
    if (this.el) {
        this.el.find(&#39;.fc-&#39; + buttonName + &#39;-button&#39;)
            .removeClass(this.calendar.theme.getClass(&#39;stateActive&#39;));
    }
};
Toolbar.prototype.disableButton = function (buttonName) {
    if (this.el) {
        this.el.find(&#39;.fc-&#39; + buttonName + &#39;-button&#39;)
            .prop(&#39;disabled&#39;, true)
            .addClass(this.calendar.theme.getClass(&#39;stateDisabled&#39;));
    }
};
Toolbar.prototype.enableButton = function (buttonName) {
    if (this.el) {
        this.el.find(&#39;.fc-&#39; + buttonName + &#39;-button&#39;)
            .prop(&#39;disabled&#39;, false)
            .removeClass(this.calendar.theme.getClass(&#39;stateDisabled&#39;));
    }
};
Toolbar.prototype.getViewsWithButtons = function () {
    return this.viewsWithButtons;
};
return Toolbar;</pre>

<p>}()); exports.default = Toolbar;</p>

<p>/***/ }), /* 240 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var options_1 =
<em>webpack_require</em>(32); var locale_1 = <em>webpack_require</em>(31);
var Model_1 = <em>webpack_require</em>(48); var OptionsManager = /** @class
*/ (function (_super) {</p>

<pre>tslib_1.__extends(OptionsManager, _super);
function OptionsManager(_calendar, overrides) {
    var _this = _super.call(this) || this;
    _this._calendar = _calendar;
    _this.overrides = $.extend({}, overrides); // make a copy
    _this.dynamicOverrides = {};
    _this.compute();
    return _this;
}
OptionsManager.prototype.add = function (newOptionHash) {
    var optionCnt = 0;
    var optionName;
    this.recordOverrides(newOptionHash); // will trigger this model&#39;s watchers
    for (optionName in newOptionHash) {
        optionCnt++;
    }
    // special-case handling of single option change.
    // if only one option change, `optionName` will be its name.
    if (optionCnt === 1) {
        if (optionName === &#39;height&#39; || optionName === &#39;contentHeight&#39; || optionName === &#39;aspectRatio&#39;) {
            this._calendar.updateViewSize(true); // isResize=true
            return;
        }
        else if (optionName === &#39;defaultDate&#39;) {
            return; // can&#39;t change date this way. use gotoDate instead
        }
        else if (optionName === &#39;businessHours&#39;) {
            return; // this model already reacts to this
        }
        else if (/^(event|select)(Overlap|Constraint|Allow)$/.test(optionName)) {
            return; // doesn&#39;t affect rendering. only interactions.
        }
        else if (optionName === &#39;timezone&#39;) {
            this._calendar.view.flash(&#39;initialEvents&#39;);
            return;
        }
    }
    // catch-all. rerender the header and footer and rebuild/rerender the current view
    this._calendar.renderHeader();
    this._calendar.renderFooter();
    // even non-current views will be affected by this option change. do before rerender
    // TODO: detangle
    this._calendar.viewsByType = {};
    this._calendar.reinitView();
};
// Computes the flattened options hash for the calendar and assigns to `this.options`.
// Assumes this.overrides and this.dynamicOverrides have already been initialized.
OptionsManager.prototype.compute = function () {
    var locale;
    var localeDefaults;
    var isRTL;
    var dirDefaults;
    var rawOptions;
    locale = util_1.firstDefined(// explicit locale option given?
    this.dynamicOverrides.locale, this.overrides.locale);
    localeDefaults = locale_1.localeOptionHash[locale];
    if (!localeDefaults) {
        locale = options_1.globalDefaults.locale;
        localeDefaults = locale_1.localeOptionHash[locale] || {};
    }
    isRTL = util_1.firstDefined(// based on options computed so far, is direction RTL?
    this.dynamicOverrides.isRTL, this.overrides.isRTL, localeDefaults.isRTL, options_1.globalDefaults.isRTL);
    dirDefaults = isRTL ? options_1.rtlDefaults : {};
    this.dirDefaults = dirDefaults;
    this.localeDefaults = localeDefaults;
    rawOptions = options_1.mergeOptions([
        options_1.globalDefaults,
        dirDefaults,
        localeDefaults,
        this.overrides,
        this.dynamicOverrides
    ]);
    locale_1.populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options
    this.reset(rawOptions);
};
// stores the new options internally, but does not rerender anything.
OptionsManager.prototype.recordOverrides = function (newOptionHash) {
    var optionName;
    for (optionName in newOptionHash) {
        this.dynamicOverrides[optionName] = newOptionHash[optionName];
    }
    this._calendar.viewSpecManager.clearCache(); // the dynamic override invalidates the options in this cache, so just clear it
    this.compute(); // this.options needs to be recomputed after the dynamic override
};
return OptionsManager;</pre>

<p>}(Model_1.default)); exports.default = OptionsManager;</p>

<p>/***/ }), /* 241 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var moment =
<em>webpack_require</em>(0); var $ = <em>webpack_require</em>(3); var
ViewRegistry_1 = <em>webpack_require</em>(22); var util_1 =
<em>webpack_require</em>(4); var options_1 = <em>webpack_require</em>(32);
var locale_1 = <em>webpack_require</em>(31); var ViewSpecManager = /**
@class */ (function () {</p>

<pre>function ViewSpecManager(optionsManager, _calendar) {
    this.optionsManager = optionsManager;
    this._calendar = _calendar;
    this.clearCache();
}
ViewSpecManager.prototype.clearCache = function () {
    this.viewSpecCache = {};
};
// Gets information about how to create a view. Will use a cache.
ViewSpecManager.prototype.getViewSpec = function (viewType) {
    var cache = this.viewSpecCache;
    return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
};
// Given a duration singular unit, like &quot;week&quot; or &quot;day&quot;, finds a matching view spec.
// Preference is given to views that have corresponding buttons.
ViewSpecManager.prototype.getUnitViewSpec = function (unit) {
    var viewTypes;
    var i;
    var spec;
    if ($.inArray(unit, util_1.unitsDesc) !== -1) {
        // put views that have buttons first. there will be duplicates, but oh well
        viewTypes = this._calendar.header.getViewsWithButtons(); // TODO: include footer as well?
        $.each(ViewRegistry_1.viewHash, function (viewType) {
            viewTypes.push(viewType);
        });
        for (i = 0; i &lt; viewTypes.length; i++) {
            spec = this.getViewSpec(viewTypes[i]);
            if (spec) {
                if (spec.singleUnit === unit) {
                    return spec;
                }
            }
        }
    }
};
// Builds an object with information on how to create a given view
ViewSpecManager.prototype.buildViewSpec = function (requestedViewType) {
    var viewOverrides = this.optionsManager.overrides.views || {};
    var specChain = []; // for the view. lowest to highest priority
    var defaultsChain = []; // for the view. lowest to highest priority
    var overridesChain = []; // for the view. lowest to highest priority
    var viewType = requestedViewType;
    var spec; // for the view
    var overrides; // for the view
    var durationInput;
    var duration;
    var unit;
    // iterate from the specific view definition to a more general one until we hit an actual View class
    while (viewType) {
        spec = ViewRegistry_1.viewHash[viewType];
        overrides = viewOverrides[viewType];
        viewType = null; // clear. might repopulate for another iteration
        if (typeof spec === &#39;function&#39;) {
            spec = { &#39;class&#39;: spec };
        }
        if (spec) {
            specChain.unshift(spec);
            defaultsChain.unshift(spec.defaults || {});
            durationInput = durationInput || spec.duration;
            viewType = viewType || spec.type;
        }
        if (overrides) {
            overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
            durationInput = durationInput || overrides.duration;
            viewType = viewType || overrides.type;
        }
    }
    spec = util_1.mergeProps(specChain);
    spec.type = requestedViewType;
    if (!spec[&#39;class&#39;]) {
        return false;
    }
    // fall back to top-level `duration` option
    durationInput = durationInput ||
        this.optionsManager.dynamicOverrides.duration ||
        this.optionsManager.overrides.duration;
    if (durationInput) {
        duration = moment.duration(durationInput);
        if (duration.valueOf()) {
            unit = util_1.computeDurationGreatestUnit(duration, durationInput);
            spec.duration = duration;
            spec.durationUnit = unit;
            // view is a single-unit duration, like &quot;week&quot; or &quot;day&quot;
            // incorporate options for this. lowest priority
            if (duration.as(unit) === 1) {
                spec.singleUnit = unit;
                overridesChain.unshift(viewOverrides[unit] || {});
            }
        }
    }
    spec.defaults = options_1.mergeOptions(defaultsChain);
    spec.overrides = options_1.mergeOptions(overridesChain);
    this.buildViewSpecOptions(spec);
    this.buildViewSpecButtonText(spec, requestedViewType);
    return spec;
};
// Builds and assigns a view spec&#39;s options object from its already-assigned defaults and overrides
ViewSpecManager.prototype.buildViewSpecOptions = function (spec) {
    var optionsManager = this.optionsManager;
    spec.options = options_1.mergeOptions([
        options_1.globalDefaults,
        spec.defaults,
        optionsManager.dirDefaults,
        optionsManager.localeDefaults,
        optionsManager.overrides,
        spec.overrides,
        optionsManager.dynamicOverrides // dynamically set via setter. highest precedence
    ]);
    locale_1.populateInstanceComputableOptions(spec.options);
};
// Computes and assigns a view spec&#39;s buttonText-related options
ViewSpecManager.prototype.buildViewSpecButtonText = function (spec, requestedViewType) {
    var optionsManager = this.optionsManager;
    // given an options object with a possible `buttonText` hash, lookup the buttonText for the
    // requested view, falling back to a generic unit entry like &quot;week&quot; or &quot;day&quot;
    function queryButtonText(options) {
        var buttonText = options.buttonText || {};
        return buttonText[requestedViewType] ||
            // view can decide to look up a certain key
            (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||
            // a key like &quot;month&quot;
            (spec.singleUnit ? buttonText[spec.singleUnit] : null);
    }
    // highest to lowest priority
    spec.buttonTextOverride =
        queryButtonText(optionsManager.dynamicOverrides) ||
            queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence
            spec.overrides.buttonText; // `buttonText` for view-specific options is a string
    // highest to lowest priority. mirrors buildViewSpecOptions
    spec.buttonTextDefault =
        queryButtonText(optionsManager.localeDefaults) ||
            queryButtonText(optionsManager.dirDefaults) ||
            spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
            queryButtonText(options_1.globalDefaults) ||
            (spec.duration ? this._calendar.humanizeDuration(spec.duration) : null) || // like &quot;3 days&quot;
            requestedViewType; // fall back to given view name
};
return ViewSpecManager;</pre>

<p>}()); exports.default = ViewSpecManager;</p>

<p>/***/ }), /* 242 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var util_1 = <em>webpack_require</em>(4); var
EventPeriod_1 = <em>webpack_require</em>(243); var ArrayEventSource_1 =
<em>webpack_require</em>(52); var EventSource_1 =
<em>webpack_require</em>(6); var EventSourceParser_1 =
<em>webpack_require</em>(38); var SingleEventDef_1 =
<em>webpack_require</em>(13); var EventInstanceGroup_1 =
<em>webpack_require</em>(18); var EmitterMixin_1 =
<em>webpack_require</em>(11); var ListenerMixin_1 =
<em>webpack_require</em>(7); var EventManager = /** @class */ (function ()
{</p>

<pre>function EventManager(calendar) {
    this.calendar = calendar;
    this.stickySource = new ArrayEventSource_1.default(calendar);
    this.otherSources = [];
}
EventManager.prototype.requestEvents = function (start, end, timezone, force) {
    if (force ||
        !this.currentPeriod ||
        !this.currentPeriod.isWithinRange(start, end) ||
        timezone !== this.currentPeriod.timezone) {
        this.setPeriod(// will change this.currentPeriod
        new EventPeriod_1.default(start, end, timezone));
    }
    return this.currentPeriod.whenReleased();
};
// Source Adding/Removing
// -----------------------------------------------------------------------------------------------------------------
EventManager.prototype.addSource = function (eventSource) {
    this.otherSources.push(eventSource);
    if (this.currentPeriod) {
        this.currentPeriod.requestSource(eventSource); // might release
    }
};
EventManager.prototype.removeSource = function (doomedSource) {
    util_1.removeExact(this.otherSources, doomedSource);
    if (this.currentPeriod) {
        this.currentPeriod.purgeSource(doomedSource); // might release
    }
};
EventManager.prototype.removeAllSources = function () {
    this.otherSources = [];
    if (this.currentPeriod) {
        this.currentPeriod.purgeAllSources(); // might release
    }
};
// Source Refetching
// -----------------------------------------------------------------------------------------------------------------
EventManager.prototype.refetchSource = function (eventSource) {
    var currentPeriod = this.currentPeriod;
    if (currentPeriod) {
        currentPeriod.freeze();
        currentPeriod.purgeSource(eventSource);
        currentPeriod.requestSource(eventSource);
        currentPeriod.thaw();
    }
};
EventManager.prototype.refetchAllSources = function () {
    var currentPeriod = this.currentPeriod;
    if (currentPeriod) {
        currentPeriod.freeze();
        currentPeriod.purgeAllSources();
        currentPeriod.requestSources(this.getSources());
        currentPeriod.thaw();
    }
};
// Source Querying
// -----------------------------------------------------------------------------------------------------------------
EventManager.prototype.getSources = function () {
    return [this.stickySource].concat(this.otherSources);
};
// like querySources, but accepts multple match criteria (like multiple IDs)
EventManager.prototype.multiQuerySources = function (matchInputs) {
    // coerce into an array
    if (!matchInputs) {
        matchInputs = [];
    }
    else if (!$.isArray(matchInputs)) {
        matchInputs = [matchInputs];
    }
    var matchingSources = [];
    var i;
    // resolve raw inputs to real event source objects
    for (i = 0; i &lt; matchInputs.length; i++) {
        matchingSources.push.apply(// append
        matchingSources, this.querySources(matchInputs[i]));
    }
    return matchingSources;
};
// matchInput can either by a real event source object, an ID, or the function/URL for the source.
// returns an array of matching source objects.
EventManager.prototype.querySources = function (matchInput) {
    var sources = this.otherSources;
    var i;
    var source;
    // given a proper event source object
    for (i = 0; i &lt; sources.length; i++) {
        source = sources[i];
        if (source === matchInput) {
            return [source];
        }
    }
    // an ID match
    source = this.getSourceById(EventSource_1.default.normalizeId(matchInput));
    if (source) {
        return [source];
    }
    // parse as an event source
    matchInput = EventSourceParser_1.default.parse(matchInput, this.calendar);
    if (matchInput) {
        return $.grep(sources, function (source) {
            return isSourcesEquivalent(matchInput, source);
        });
    }
};
/*
ID assumed to already be normalized
 /
EventManager.prototype.getSourceById = function (id) {
    return $.grep(this.otherSources, function (source) {
        return source.id &amp;&amp; source.id === id;
    })[0];
};
// Event-Period
// -----------------------------------------------------------------------------------------------------------------
EventManager.prototype.setPeriod = function (eventPeriod) {
    if (this.currentPeriod) {
        this.unbindPeriod(this.currentPeriod);
        this.currentPeriod = null;
    }
    this.currentPeriod = eventPeriod;
    this.bindPeriod(eventPeriod);
    eventPeriod.requestSources(this.getSources());
};
EventManager.prototype.bindPeriod = function (eventPeriod) {
    this.listenTo(eventPeriod, &#39;release&#39;, function (eventsPayload) {
        this.trigger(&#39;release&#39;, eventsPayload);
    });
};
EventManager.prototype.unbindPeriod = function (eventPeriod) {
    this.stopListeningTo(eventPeriod);
};
// Event Getting/Adding/Removing
// -----------------------------------------------------------------------------------------------------------------
EventManager.prototype.getEventDefByUid = function (uid) {
    if (this.currentPeriod) {
        return this.currentPeriod.getEventDefByUid(uid);
    }
};
EventManager.prototype.addEventDef = function (eventDef, isSticky) {
    if (isSticky) {
        this.stickySource.addEventDef(eventDef);
    }
    if (this.currentPeriod) {
        this.currentPeriod.addEventDef(eventDef); // might release
    }
};
EventManager.prototype.removeEventDefsById = function (eventId) {
    this.getSources().forEach(function (eventSource) {
        eventSource.removeEventDefsById(eventId);
    });
    if (this.currentPeriod) {
        this.currentPeriod.removeEventDefsById(eventId); // might release
    }
};
EventManager.prototype.removeAllEventDefs = function () {
    this.getSources().forEach(function (eventSource) {
        eventSource.removeAllEventDefs();
    });
    if (this.currentPeriod) {
        this.currentPeriod.removeAllEventDefs();
    }
};
// Event Mutating
// -----------------------------------------------------------------------------------------------------------------
/*
Returns an undo function.
 /
EventManager.prototype.mutateEventsWithId = function (eventDefId, eventDefMutation) {
    var currentPeriod = this.currentPeriod;
    var eventDefs;
    var undoFuncs = [];
    if (currentPeriod) {
        currentPeriod.freeze();
        eventDefs = currentPeriod.getEventDefsById(eventDefId);
        eventDefs.forEach(function (eventDef) {
            // add/remove esp because id might change
            currentPeriod.removeEventDef(eventDef);
            undoFuncs.push(eventDefMutation.mutateSingle(eventDef));
            currentPeriod.addEventDef(eventDef);
        });
        currentPeriod.thaw();
        return function () {
            currentPeriod.freeze();
            for (var i = 0; i &lt; eventDefs.length; i++) {
                currentPeriod.removeEventDef(eventDefs[i]);
                undoFuncs[i]();
                currentPeriod.addEventDef(eventDefs[i]);
            }
            currentPeriod.thaw();
        };
    }
    return function () { };
};
/*
copies and then mutates
 /
EventManager.prototype.buildMutatedEventInstanceGroup = function (eventDefId, eventDefMutation) {
    var eventDefs = this.getEventDefsById(eventDefId);
    var i;
    var defCopy;
    var allInstances = [];
    for (i = 0; i &lt; eventDefs.length; i++) {
        defCopy = eventDefs[i].clone();
        if (defCopy instanceof SingleEventDef_1.default) {
            eventDefMutation.mutateSingle(defCopy);
            allInstances.push.apply(allInstances, // append
            defCopy.buildInstances());
        }
    }
    return new EventInstanceGroup_1.default(allInstances);
};
// Freezing
// -----------------------------------------------------------------------------------------------------------------
EventManager.prototype.freeze = function () {
    if (this.currentPeriod) {
        this.currentPeriod.freeze();
    }
};
EventManager.prototype.thaw = function () {
    if (this.currentPeriod) {
        this.currentPeriod.thaw();
    }
};
// methods that simply forward to EventPeriod
EventManager.prototype.getEventDefsById = function (eventDefId) {
    return this.currentPeriod.getEventDefsById(eventDefId);
};
EventManager.prototype.getEventInstances = function () {
    return this.currentPeriod.getEventInstances();
};
EventManager.prototype.getEventInstancesWithId = function (eventDefId) {
    return this.currentPeriod.getEventInstancesWithId(eventDefId);
};
EventManager.prototype.getEventInstancesWithoutId = function (eventDefId) {
    return this.currentPeriod.getEventInstancesWithoutId(eventDefId);
};
return EventManager;</pre>

<p>}()); exports.default = EventManager;
EmitterMixin_1.default.mixInto(EventManager);
ListenerMixin_1.default.mixInto(EventManager); function
isSourcesEquivalent(source0, source1) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">source0</span>.<span class="ruby-identifier">getPrimitive</span>() <span class="ruby-operator">===</span> <span class="ruby-identifier">source1</span>.<span class="ruby-identifier">getPrimitive</span>();
</pre>

<p>}</p>

<p>/***/ }), /* 243 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var util_1 = <em>webpack_require</em>(4); var
Promise_1 = <em>webpack_require</em>(20); var EmitterMixin_1 =
<em>webpack_require</em>(11); var UnzonedRange_1 =
<em>webpack_require</em>(5); var EventInstanceGroup_1 =
<em>webpack_require</em>(18); var EventPeriod = /** @class */ (function ()
{</p>

<pre>function EventPeriod(start, end, timezone) {
    this.pendingCnt = 0;
    this.freezeDepth = 0;
    this.stuntedReleaseCnt = 0;
    this.releaseCnt = 0;
    this.start = start;
    this.end = end;
    this.timezone = timezone;
    this.unzonedRange = new UnzonedRange_1.default(start.clone().stripZone(), end.clone().stripZone());
    this.requestsByUid = {};
    this.eventDefsByUid = {};
    this.eventDefsById = {};
    this.eventInstanceGroupsById = {};
}
EventPeriod.prototype.isWithinRange = function (start, end) {
    // TODO: use a range util function?
    return !start.isBefore(this.start) &amp;&amp; !end.isAfter(this.end);
};
// Requesting and Purging
// -----------------------------------------------------------------------------------------------------------------
EventPeriod.prototype.requestSources = function (sources) {
    this.freeze();
    for (var i = 0; i &lt; sources.length; i++) {
        this.requestSource(sources[i]);
    }
    this.thaw();
};
EventPeriod.prototype.requestSource = function (source) {
    var _this = this;
    var request = { source: source, status: &#39;pending&#39;, eventDefs: null };
    this.requestsByUid[source.uid] = request;
    this.pendingCnt += 1;
    source.fetch(this.start, this.end, this.timezone).then(function (eventDefs) {
        if (request.status !== &#39;cancelled&#39;) {
            request.status = &#39;completed&#39;;
            request.eventDefs = eventDefs;
            _this.addEventDefs(eventDefs);
            _this.pendingCnt--;
            _this.tryRelease();
        }
    }, function () {
        if (request.status !== &#39;cancelled&#39;) {
            request.status = &#39;failed&#39;;
            _this.pendingCnt--;
            _this.tryRelease();
        }
    });
};
EventPeriod.prototype.purgeSource = function (source) {
    var request = this.requestsByUid[source.uid];
    if (request) {
        delete this.requestsByUid[source.uid];
        if (request.status === &#39;pending&#39;) {
            request.status = &#39;cancelled&#39;;
            this.pendingCnt--;
            this.tryRelease();
        }
        else if (request.status === &#39;completed&#39;) {
            request.eventDefs.forEach(this.removeEventDef.bind(this));
        }
    }
};
EventPeriod.prototype.purgeAllSources = function () {
    var requestsByUid = this.requestsByUid;
    var uid;
    var request;
    var completedCnt = 0;
    for (uid in requestsByUid) {
        request = requestsByUid[uid];
        if (request.status === &#39;pending&#39;) {
            request.status = &#39;cancelled&#39;;
        }
        else if (request.status === &#39;completed&#39;) {
            completedCnt++;
        }
    }
    this.requestsByUid = {};
    this.pendingCnt = 0;
    if (completedCnt) {
        this.removeAllEventDefs(); // might release
    }
};
// Event Definitions
// -----------------------------------------------------------------------------------------------------------------
EventPeriod.prototype.getEventDefByUid = function (eventDefUid) {
    return this.eventDefsByUid[eventDefUid];
};
EventPeriod.prototype.getEventDefsById = function (eventDefId) {
    var a = this.eventDefsById[eventDefId];
    if (a) {
        return a.slice(); // clone
    }
    return [];
};
EventPeriod.prototype.addEventDefs = function (eventDefs) {
    for (var i = 0; i &lt; eventDefs.length; i++) {
        this.addEventDef(eventDefs[i]);
    }
};
EventPeriod.prototype.addEventDef = function (eventDef) {
    var eventDefsById = this.eventDefsById;
    var eventDefId = eventDef.id;
    var eventDefs = eventDefsById[eventDefId] || (eventDefsById[eventDefId] = []);
    var eventInstances = eventDef.buildInstances(this.unzonedRange);
    var i;
    eventDefs.push(eventDef);
    this.eventDefsByUid[eventDef.uid] = eventDef;
    for (i = 0; i &lt; eventInstances.length; i++) {
        this.addEventInstance(eventInstances[i], eventDefId);
    }
};
EventPeriod.prototype.removeEventDefsById = function (eventDefId) {
    var _this = this;
    this.getEventDefsById(eventDefId).forEach(function (eventDef) {
        _this.removeEventDef(eventDef);
    });
};
EventPeriod.prototype.removeAllEventDefs = function () {
    var isEmpty = $.isEmptyObject(this.eventDefsByUid);
    this.eventDefsByUid = {};
    this.eventDefsById = {};
    this.eventInstanceGroupsById = {};
    if (!isEmpty) {
        this.tryRelease();
    }
};
EventPeriod.prototype.removeEventDef = function (eventDef) {
    var eventDefsById = this.eventDefsById;
    var eventDefs = eventDefsById[eventDef.id];
    delete this.eventDefsByUid[eventDef.uid];
    if (eventDefs) {
        util_1.removeExact(eventDefs, eventDef);
        if (!eventDefs.length) {
            delete eventDefsById[eventDef.id];
        }
        this.removeEventInstancesForDef(eventDef);
    }
};
// Event Instances
// -----------------------------------------------------------------------------------------------------------------
EventPeriod.prototype.getEventInstances = function () {
    var eventInstanceGroupsById = this.eventInstanceGroupsById;
    var eventInstances = [];
    var id;
    for (id in eventInstanceGroupsById) {
        eventInstances.push.apply(eventInstances, // append
        eventInstanceGroupsById[id].eventInstances);
    }
    return eventInstances;
};
EventPeriod.prototype.getEventInstancesWithId = function (eventDefId) {
    var eventInstanceGroup = this.eventInstanceGroupsById[eventDefId];
    if (eventInstanceGroup) {
        return eventInstanceGroup.eventInstances.slice(); // clone
    }
    return [];
};
EventPeriod.prototype.getEventInstancesWithoutId = function (eventDefId) {
    var eventInstanceGroupsById = this.eventInstanceGroupsById;
    var matchingInstances = [];
    var id;
    for (id in eventInstanceGroupsById) {
        if (id !== eventDefId) {
            matchingInstances.push.apply(matchingInstances, // append
            eventInstanceGroupsById[id].eventInstances);
        }
    }
    return matchingInstances;
};
EventPeriod.prototype.addEventInstance = function (eventInstance, eventDefId) {
    var eventInstanceGroupsById = this.eventInstanceGroupsById;
    var eventInstanceGroup = eventInstanceGroupsById[eventDefId] ||
        (eventInstanceGroupsById[eventDefId] = new EventInstanceGroup_1.default());
    eventInstanceGroup.eventInstances.push(eventInstance);
    this.tryRelease();
};
EventPeriod.prototype.removeEventInstancesForDef = function (eventDef) {
    var eventInstanceGroupsById = this.eventInstanceGroupsById;
    var eventInstanceGroup = eventInstanceGroupsById[eventDef.id];
    var removeCnt;
    if (eventInstanceGroup) {
        removeCnt = util_1.removeMatching(eventInstanceGroup.eventInstances, function (currentEventInstance) {
            return currentEventInstance.def === eventDef;
        });
        if (!eventInstanceGroup.eventInstances.length) {
            delete eventInstanceGroupsById[eventDef.id];
        }
        if (removeCnt) {
            this.tryRelease();
        }
    }
};
// Releasing and Freezing
// -----------------------------------------------------------------------------------------------------------------
EventPeriod.prototype.tryRelease = function () {
    if (!this.pendingCnt) {
        if (!this.freezeDepth) {
            this.release();
        }
        else {
            this.stuntedReleaseCnt++;
        }
    }
};
EventPeriod.prototype.release = function () {
    this.releaseCnt++;
    this.trigger(&#39;release&#39;, this.eventInstanceGroupsById);
};
EventPeriod.prototype.whenReleased = function () {
    var _this = this;
    if (this.releaseCnt) {
        return Promise_1.default.resolve(this.eventInstanceGroupsById);
    }
    else {
        return Promise_1.default.construct(function (onResolve) {
            _this.one(&#39;release&#39;, onResolve);
        });
    }
};
EventPeriod.prototype.freeze = function () {
    if (!(this.freezeDepth++)) {
        this.stuntedReleaseCnt = 0;
    }
};
EventPeriod.prototype.thaw = function () {
    if (!(--this.freezeDepth) &amp;&amp; this.stuntedReleaseCnt &amp;&amp; !this.pendingCnt) {
        this.release();
    }
};
return EventPeriod;</pre>

<p>}()); exports.default = EventPeriod;
EmitterMixin_1.default.mixInto(EventPeriod);</p>

<p>/***/ }), /* 244 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var util_1 = <em>webpack_require</em>(4); var
ListenerMixin_1 = <em>webpack_require</em>(7); /* Creates a clone of an
element and lets it track the mouse as it moves
———————————————————————————————————————-*/ var MouseFollower = /** @class
*/ (function () {</p>

<pre>function MouseFollower(sourceEl, options) {
    this.isFollowing = false;
    this.isHidden = false;
    this.isAnimating = false; // doing the revert animation?
    this.options = options = options || {};
    this.sourceEl = sourceEl;
    this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl&#39;s parent
}
// Causes the element to start following the mouse
MouseFollower.prototype.start = function (ev) {
    if (!this.isFollowing) {
        this.isFollowing = true;
        this.y0 = util_1.getEvY(ev);
        this.x0 = util_1.getEvX(ev);
        this.topDelta = 0;
        this.leftDelta = 0;
        if (!this.isHidden) {
            this.updatePosition();
        }
        if (util_1.getEvIsTouch(ev)) {
            this.listenTo($(document), &#39;touchmove&#39;, this.handleMove);
        }
        else {
            this.listenTo($(document), &#39;mousemove&#39;, this.handleMove);
        }
    }
};
// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
MouseFollower.prototype.stop = function (shouldRevert, callback) {
    var _this = this;
    var revertDuration = this.options.revertDuration;
    var complete = function () {
        _this.isAnimating = false;
        _this.removeElement();
        _this.top0 = _this.left0 = null; // reset state for future updatePosition calls
        if (callback) {
            callback();
        }
    };
    if (this.isFollowing &amp;&amp; !this.isAnimating) {
        this.isFollowing = false;
        this.stopListeningTo($(document));
        if (shouldRevert &amp;&amp; revertDuration &amp;&amp; !this.isHidden) {
            this.isAnimating = true;
            this.el.animate({
                top: this.top0,
                left: this.left0
            }, {
                duration: revertDuration,
                complete: complete
            });
        }
        else {
            complete();
        }
    }
};
// Gets the tracking element. Create it if necessary
MouseFollower.prototype.getEl = function () {
    var el = this.el;
    if (!el) {
        el = this.el = this.sourceEl.clone()
            .addClass(this.options.additionalClass || &#39;&#39;)
            .css({
            position: &#39;absolute&#39;,
            visibility: &#39;&#39;,
            display: this.isHidden ? &#39;none&#39; : &#39;&#39;,
            margin: 0,
            right: &#39;auto&#39;,
            bottom: &#39;auto&#39;,
            width: this.sourceEl.width(),
            height: this.sourceEl.height(),
            opacity: this.options.opacity || &#39;&#39;,
            zIndex: this.options.zIndex
        });
        // we don&#39;t want long taps or any mouse interaction causing selection/menus.
        // would use preventSelection(), but that prevents selectstart, causing problems.
        el.addClass(&#39;fc-unselectable&#39;);
        el.appendTo(this.parentEl);
    }
    return el;
};
// Removes the tracking element if it has already been created
MouseFollower.prototype.removeElement = function () {
    if (this.el) {
        this.el.remove();
        this.el = null;
    }
};
// Update the CSS position of the tracking element
MouseFollower.prototype.updatePosition = function () {
    var sourceOffset;
    var origin;
    this.getEl(); // ensure this.el
    // make sure origin info was computed
    if (this.top0 == null) {
        sourceOffset = this.sourceEl.offset();
        origin = this.el.offsetParent().offset();
        this.top0 = sourceOffset.top - origin.top;
        this.left0 = sourceOffset.left - origin.left;
    }
    this.el.css({
        top: this.top0 + this.topDelta,
        left: this.left0 + this.leftDelta
    });
};
// Gets called when the user moves the mouse
MouseFollower.prototype.handleMove = function (ev) {
    this.topDelta = util_1.getEvY(ev) - this.y0;
    this.leftDelta = util_1.getEvX(ev) - this.x0;
    if (!this.isHidden) {
        this.updatePosition();
    }
};
// Temporarily makes the tracking element invisible. Can be called before following starts
MouseFollower.prototype.hide = function () {
    if (!this.isHidden) {
        this.isHidden = true;
        if (this.el) {
            this.el.hide();
        }
    }
};
// Show the tracking element after it has been temporarily hidden
MouseFollower.prototype.show = function () {
    if (this.isHidden) {
        this.isHidden = false;
        this.updatePosition();
        this.getEl().show();
    }
};
return MouseFollower;</pre>

<p>}()); exports.default = MouseFollower;
ListenerMixin_1.default.mixInto(MouseFollower);</p>

<p>/***/ }), /* 245 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var HitDragListener_1 =
<em>webpack_require</em>(23); var Interaction_1 =
<em>webpack_require</em>(15); var DateClicking = /** @class */ (function
(_super) {</p>

<pre>tslib_1.__extends(DateClicking, _super);
/*
component must implement:
  - bindDateHandlerToEl
  - getSafeHitFootprint
  - getHitEl
 /
function DateClicking(component) {
    var _this = _super.call(this, component) || this;
    _this.dragListener = _this.buildDragListener();
    return _this;
}
DateClicking.prototype.end = function () {
    this.dragListener.endInteraction();
};
DateClicking.prototype.bindToEl = function (el) {
    var component = this.component;
    var dragListener = this.dragListener;
    component.bindDateHandlerToEl(el, &#39;mousedown&#39;, function (ev) {
        if (!component.shouldIgnoreMouse()) {
            dragListener.startInteraction(ev);
        }
    });
    component.bindDateHandlerToEl(el, &#39;touchstart&#39;, function (ev) {
        if (!component.shouldIgnoreTouch()) {
            dragListener.startInteraction(ev);
        }
    });
};
// Creates a listener that tracks the user&#39;s drag across day elements, for day clicking.
DateClicking.prototype.buildDragListener = function () {
    var _this = this;
    var component = this.component;
    var dayClickHit; // null if invalid dayClick
    var dragListener = new HitDragListener_1.default(component, {
        scroll: this.opt(&#39;dragScroll&#39;),
        interactionStart: function () {
            dayClickHit = dragListener.origHit;
        },
        hitOver: function (hit, isOrig, origHit) {
            // if user dragged to another cell at any point, it can no longer be a dayClick
            if (!isOrig) {
                dayClickHit = null;
            }
        },
        hitOut: function () {
            dayClickHit = null;
        },
        interactionEnd: function (ev, isCancelled) {
            var componentFootprint;
            if (!isCancelled &amp;&amp; dayClickHit) {
                componentFootprint = component.getSafeHitFootprint(dayClickHit);
                if (componentFootprint) {
                    _this.view.triggerDayClick(componentFootprint, component.getHitEl(dayClickHit), ev);
                }
            }
        }
    });
    // because dragListener won&#39;t be called with any time delay, &quot;dragging&quot; will begin immediately,
    // which will kill any touchmoving/scrolling. Prevent this.
    dragListener.shouldCancelTouchScroll = false;
    dragListener.scrollAlwaysKills = true;
    return dragListener;
};
return DateClicking;</pre>

<p>}(Interaction_1.default)); exports.default = DateClicking;</p>

<p>/***/ }), /* 246 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var util_1 = <em>webpack_require</em>(4);
var EventRenderer_1 = <em>webpack_require</em>(42); /* Only handles
foreground segs. Does not own rendering. Use for low-level util methods by
TimeGrid.</p>

<pre>/</pre>

<p>var TimeGridEventRenderer = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(TimeGridEventRenderer, _super);
function TimeGridEventRenderer(timeGrid, fillRenderer) {
    var _this = _super.call(this, timeGrid, fillRenderer) || this;
    _this.timeGrid = timeGrid;
    return _this;
}
TimeGridEventRenderer.prototype.renderFgSegs = function (segs) {
    this.renderFgSegsIntoContainers(segs, this.timeGrid.fgContainerEls);
};
// Given an array of foreground segments, render a DOM element for each, computes position,
// and attaches to the column inner-container elements.
TimeGridEventRenderer.prototype.renderFgSegsIntoContainers = function (segs, containerEls) {
    var segsByCol;
    var col;
    segsByCol = this.timeGrid.groupSegsByCol(segs);
    for (col = 0; col &lt; this.timeGrid.colCnt; col++) {
        this.updateFgSegCoords(segsByCol[col]);
    }
    this.timeGrid.attachSegsByCol(segsByCol, containerEls);
};
TimeGridEventRenderer.prototype.unrenderFgSegs = function () {
    if (this.fgSegs) {
        this.fgSegs.forEach(function (seg) {
            seg.el.remove();
        });
    }
};
// Computes a default event time formatting string if `timeFormat` is not explicitly defined
TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {
    return this.opt(&#39;noMeridiemTimeFormat&#39;); // like &quot;6:30&quot; (no AM/PM)
};
// Computes a default `displayEventEnd` value if one is not expliclty defined
TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {
    return true;
};
// Renders the HTML for a single event segment&#39;s default rendering
TimeGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
    var view = this.view;
    var calendar = view.calendar;
    var componentFootprint = seg.footprint.componentFootprint;
    var isAllDay = componentFootprint.isAllDay;
    var eventDef = seg.footprint.eventDef;
    var isDraggable = view.isEventDefDraggable(eventDef);
    var isResizableFromStart = !disableResizing &amp;&amp; seg.isStart &amp;&amp; view.isEventDefResizableFromStart(eventDef);
    var isResizableFromEnd = !disableResizing &amp;&amp; seg.isEnd &amp;&amp; view.isEventDefResizableFromEnd(eventDef);
    var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
    var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));
    var timeText;
    var fullTimeText; // more verbose time text. for the print stylesheet
    var startTimeText; // just the start time text
    classes.unshift(&#39;fc-time-grid-event&#39;, &#39;fc-v-event&#39;);
    // if the event appears to span more than one day...
    if (view.isMultiDayRange(componentFootprint.unzonedRange)) {
        // Don&#39;t display time text on segments that run entirely through a day.
        // That would appear as midnight-midnight and would look dumb.
        // Otherwise, display the time text for the *segment&#39;s* times (like 6pm-midnight or midnight-10am)
        if (seg.isStart || seg.isEnd) {
            var zonedStart = calendar.msToMoment(seg.startMs);
            var zonedEnd = calendar.msToMoment(seg.endMs);
            timeText = this._getTimeText(zonedStart, zonedEnd, isAllDay);
            fullTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, &#39;LT&#39;);
            startTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, null, false); // displayEnd=false
        }
    }
    else {
        // Display the normal time text for the *event&#39;s* times
        timeText = this.getTimeText(seg.footprint);
        fullTimeText = this.getTimeText(seg.footprint, &#39;LT&#39;);
        startTimeText = this.getTimeText(seg.footprint, null, false); // displayEnd=false
    }
    return &#39;&lt;a class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&#39; +
        (eventDef.url ?
            &#39; href=&quot;&#39; + util_1.htmlEscape(eventDef.url) + &#39;&quot;&#39; :
            &#39;&#39;) +
        (skinCss ?
            &#39; style=&quot;&#39; + skinCss + &#39;&quot;&#39; :
            &#39;&#39;) +
        &#39;&gt;&#39; +
        &#39;&lt;div class=&quot;fc-content&quot;&gt;&#39; +
        (timeText ?
            &#39;&lt;div class=&quot;fc-time&quot;&#39; +
                &#39; data-start=&quot;&#39; + util_1.htmlEscape(startTimeText) + &#39;&quot;&#39; +
                &#39; data-full=&quot;&#39; + util_1.htmlEscape(fullTimeText) + &#39;&quot;&#39; +
                &#39;&gt;&#39; +
                &#39;&lt;span&gt;&#39; + util_1.htmlEscape(timeText) + &#39;&lt;/span&gt;&#39; +
                &#39;&lt;/div&gt;&#39; :
            &#39;&#39;) +
        (eventDef.title ?
            &#39;&lt;div class=&quot;fc-title&quot;&gt;&#39; +
                util_1.htmlEscape(eventDef.title) +
                &#39;&lt;/div&gt;&#39; :
            &#39;&#39;) +
        &#39;&lt;/div&gt;&#39; +
        &#39;&lt;div class=&quot;fc-bg&quot;/&gt;&#39; +
        /* TODO: write CSS for this
        (isResizableFromStart ?
          &#39;&lt;div class=&quot;fc-resizer fc-start-resizer&quot; /&gt;&#39; :
          &#39;&#39;
          ) +
         /
        (isResizableFromEnd ?
            &#39;&lt;div class=&quot;fc-resizer fc-end-resizer&quot; /&gt;&#39; :
            &#39;&#39;) +
        &#39;&lt;/a&gt;&#39;;
};
// Given segments that are assumed to all live in the *same column*,
// compute their verical/horizontal coordinates and assign to their elements.
TimeGridEventRenderer.prototype.updateFgSegCoords = function (segs) {
    this.timeGrid.computeSegVerticals(segs); // horizontals relies on this
    this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index&#39;s, and reorder the array
    this.timeGrid.assignSegVerticals(segs);
    this.assignFgSegHorizontals(segs);
};
// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
// NOTE: Also reorders the given array by date!
TimeGridEventRenderer.prototype.computeFgSegHorizontals = function (segs) {
    var levels;
    var level0;
    var i;
    this.sortEventSegs(segs); // order by certain criteria
    levels = buildSlotSegLevels(segs);
    computeForwardSlotSegs(levels);
    if ((level0 = levels[0])) {
        for (i = 0; i &lt; level0.length; i++) {
            computeSlotSegPressures(level0[i]);
        }
        for (i = 0; i &lt; level0.length; i++) {
            this.computeFgSegForwardBack(level0[i], 0, 0);
        }
    }
};
// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to &quot;left&quot; and
// seg.forwardCoord maps to &quot;right&quot; (via percentage). Vice-versa if the calendar is right-to-left.
//
// The segment might be part of a &quot;series&quot;, which means consecutive segments with the same pressure
// who&#39;s width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
// coordinate of the first segment in the series.
TimeGridEventRenderer.prototype.computeFgSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {
    var forwardSegs = seg.forwardSegs;
    var i;
    if (seg.forwardCoord === undefined) {
        if (!forwardSegs.length) {
            // if there are no forward segments, this segment should butt up against the edge
            seg.forwardCoord = 1;
        }
        else {
            // sort highest pressure first
            this.sortForwardSegs(forwardSegs);
            // this segment&#39;s forwardCoord will be calculated from the backwardCoord of the
            // highest-pressure forward segment.
            this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
            seg.forwardCoord = forwardSegs[0].backwardCoord;
        }
        // calculate the backwardCoord from the forwardCoord. consider the series
        seg.backwardCoord = seg.forwardCoord -
            (seg.forwardCoord - seriesBackwardCoord) / // available width for series
                (seriesBackwardPressure + 1); // # of segments in the series
        // use this segment&#39;s coordinates to computed the coordinates of the less-pressurized
        // forward segments
        for (i = 0; i &lt; forwardSegs.length; i++) {
            this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
        }
    }
};
TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {
    forwardSegs.sort(util_1.proxy(this, &#39;compareForwardSegs&#39;));
};
// A cmp function for determining which forward segment to rely on more when computing coordinates.
TimeGridEventRenderer.prototype.compareForwardSegs = function (seg1, seg2) {
    // put higher-pressure first
    return seg2.forwardPressure - seg1.forwardPressure ||
        // put segments that are closer to initial edge first (and favor ones with no coords yet)
        (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
        // do normal sorting...
        this.compareEventSegs(seg1, seg2);
};
// Given foreground event segments that have already had their position coordinates computed,
// assigns position-related CSS values to their elements.
TimeGridEventRenderer.prototype.assignFgSegHorizontals = function (segs) {
    var i;
    var seg;
    for (i = 0; i &lt; segs.length; i++) {
        seg = segs[i];
        seg.el.css(this.generateFgSegHorizontalCss(seg));
        // if the height is short, add a className for alternate styling
        if (seg.bottom - seg.top &lt; 30) {
            seg.el.addClass(&#39;fc-short&#39;);
        }
    }
};
// Generates an object with CSS properties/values that should be applied to an event segment element.
// Contains important positioning-related properties that should be applied to any event element, customized or not.
TimeGridEventRenderer.prototype.generateFgSegHorizontalCss = function (seg) {
    var shouldOverlap = this.opt(&#39;slotEventOverlap&#39;);
    var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
    var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
    var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first
    var isRTL = this.timeGrid.isRTL;
    var left; // amount of space from left edge, a fraction of the total width
    var right; // amount of space from right edge, a fraction of the total width
    if (shouldOverlap) {
        // double the width, but don&#39;t go beyond the maximum forward coordinate (1.0)
        forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
    }
    if (isRTL) {
        left = 1 - forwardCoord;
        right = backwardCoord;
    }
    else {
        left = backwardCoord;
        right = 1 - forwardCoord;
    }
    props.zIndex = seg.level + 1; // convert from 0-base to 1-based
    props.left = left * 100 + &#39;%&#39;;
    props.right = right * 100 + &#39;%&#39;;
    if (shouldOverlap &amp;&amp; seg.forwardPressure) {
        // add padding to the edge so that forward stacked events don&#39;t cover the resizer&#39;s icon
        props[isRTL ? &#39;marginLeft&#39; : &#39;marginRight&#39;] = 10 * 2; // 10 is a guesstimate of the icon&#39;s width
    }
    return props;
};
return TimeGridEventRenderer;</pre>

<p>}(EventRenderer_1.default)); exports.default = TimeGridEventRenderer; //
Builds an array of segments “levels”. The first level will be the leftmost
tier of segments if the calendar is // left-to-right, or the rightmost if
the calendar is right-to-left. Assumes the segments are already ordered by
date. function buildSlotSegLevels(segs) {</p>

<pre>var levels = [];
var i;
var seg;
var j;
for (i = 0; i &lt; segs.length; i++) {
    seg = segs[i];
    // go through all the levels and stop on the first level where there are no collisions
    for (j = 0; j &lt; levels.length; j++) {
        if (!computeSlotSegCollisions(seg, levels[j]).length) {
            break;
        }
    }
    seg.level = j;
    (levels[j] || (levels[j] = [])).push(seg);
}
return levels;</pre>

<p>} // For every segment, figure out the other segments that are in
subsequent // levels that also occupy the same vertical space. Accumulate
in seg.forwardSegs function computeForwardSlotSegs(levels) {</p>

<pre>var i;
var level;
var j;
var seg;
var k;
for (i = 0; i &lt; levels.length; i++) {
    level = levels[i];
    for (j = 0; j &lt; level.length; j++) {
        seg = level[j];
        seg.forwardSegs = [];
        for (k = i + 1; k &lt; levels.length; k++) {
            computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
        }
    }
}</pre>

<p>} // Figure out which path forward (via seg.forwardSegs) results in the
longest path until // the furthest edge is reached. The number of segments
in this path will be seg.forwardPressure function
computeSlotSegPressures(seg) {</p>

<pre>var forwardSegs = seg.forwardSegs;
var forwardPressure = 0;
var i;
var forwardSeg;
if (seg.forwardPressure === undefined) {
    for (i = 0; i &lt; forwardSegs.length; i++) {
        forwardSeg = forwardSegs[i];
        // figure out the child&#39;s maximum forward path
        computeSlotSegPressures(forwardSeg);
        // either use the existing maximum, or use the child&#39;s forward pressure
        // plus one (for the forwardSeg itself)
        forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);
    }
    seg.forwardPressure = forwardPressure;
}</pre>

<p>} // Find all the segments in `otherSegs` that vertically collide with
`seg`. // Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {</p>

<pre>if (results === void 0) { results = []; }
for (var i = 0; i &lt; otherSegs.length; i++) {
    if (isSlotSegCollision(seg, otherSegs[i])) {
        results.push(otherSegs[i]);
    }
}
return results;</pre>

<p>} // Do these segments occupy the same vertical space? function
isSlotSegCollision(seg1, seg2) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">seg1</span>.<span class="ruby-identifier">bottom</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">seg2</span>.<span class="ruby-identifier">top</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">seg1</span>.<span class="ruby-identifier">top</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">seg2</span>.<span class="ruby-identifier">bottom</span>;
</pre>

<p>}</p>

<p>/***/ }), /* 247 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
HelperRenderer_1 = <em>webpack_require</em>(58); var TimeGridHelperRenderer
= /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(TimeGridHelperRenderer, _super);
function TimeGridHelperRenderer() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
TimeGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
    var helperNodes = [];
    var i;
    var seg;
    var sourceEl;
    // TODO: not good to call eventRenderer this way
    this.eventRenderer.renderFgSegsIntoContainers(segs, this.component.helperContainerEls);
    // Try to make the segment that is in the same row as sourceSeg look the same
    for (i = 0; i &lt; segs.length; i++) {
        seg = segs[i];
        if (sourceSeg &amp;&amp; sourceSeg.col === seg.col) {
            sourceEl = sourceSeg.el;
            seg.el.css({
                left: sourceEl.css(&#39;left&#39;),
                right: sourceEl.css(&#39;right&#39;),
                &#39;margin-left&#39;: sourceEl.css(&#39;margin-left&#39;),
                &#39;margin-right&#39;: sourceEl.css(&#39;margin-right&#39;)
            });
        }
        helperNodes.push(seg.el[0]);
    }
    return $(helperNodes); // must return the elements rendered
};
return TimeGridHelperRenderer;</pre>

<p>}(HelperRenderer_1.default)); exports.default = TimeGridHelperRenderer;</p>

<p>/***/ }), /* 248 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var FillRenderer_1 =
<em>webpack_require</em>(57); var TimeGridFillRenderer = /** @class */
(function (_super) {</p>

<pre>tslib_1.__extends(TimeGridFillRenderer, _super);
function TimeGridFillRenderer() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
TimeGridFillRenderer.prototype.attachSegEls = function (type, segs) {
    var timeGrid = this.component;
    var containerEls;
    // TODO: more efficient lookup
    if (type === &#39;bgEvent&#39;) {
        containerEls = timeGrid.bgContainerEls;
    }
    else if (type === &#39;businessHours&#39;) {
        containerEls = timeGrid.businessContainerEls;
    }
    else if (type === &#39;highlight&#39;) {
        containerEls = timeGrid.highlightContainerEls;
    }
    timeGrid.updateSegVerticals(segs);
    timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);
    return segs.map(function (seg) {
        return seg.el[0];
    });
};
return TimeGridFillRenderer;</pre>

<p>}(FillRenderer_1.default)); exports.default = TimeGridFillRenderer;</p>

<p>/***/ }), /* 249 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>/* A rectangular panel that is absolutely positioned over other content</p>
<hr>

<p>Options:</p>

<pre> - className (string)
 - content (HTML string or jQuery element set)
 - parentEl
 - top
 - left
 - right (the x coord of where the right edge should be. not a &quot;CSS&quot; right)
 - autoHide (boolean)
 - show (callback)
 - hide (callback)
/</pre>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var $ =
<em>webpack_require</em>(3); var util_1 = <em>webpack_require</em>(4); var
ListenerMixin_1 = <em>webpack_require</em>(7); var Popover = /** @class */
(function () {</p>

<pre>function Popover(options) {
    this.isHidden = true;
    this.margin = 10; // the space required between the popover and the edges of the scroll container
    this.options = options || {};
}
// Shows the popover on the specified position. Renders it if not already
Popover.prototype.show = function () {
    if (this.isHidden) {
        if (!this.el) {
            this.render();
        }
        this.el.show();
        this.position();
        this.isHidden = false;
        this.trigger(&#39;show&#39;);
    }
};
// Hides the popover, through CSS, but does not remove it from the DOM
Popover.prototype.hide = function () {
    if (!this.isHidden) {
        this.el.hide();
        this.isHidden = true;
        this.trigger(&#39;hide&#39;);
    }
};
// Creates `this.el` and renders content inside of it
Popover.prototype.render = function () {
    var _this = this;
    var options = this.options;
    this.el = $(&#39;&lt;div class=&quot;fc-popover&quot;/&gt;&#39;)
        .addClass(options.className || &#39;&#39;)
        .css({
        // position initially to the top left to avoid creating scrollbars
        top: 0,
        left: 0
    })
        .append(options.content)
        .appendTo(options.parentEl);
    // when a click happens on anything inside with a &#39;fc-close&#39; className, hide the popover
    this.el.on(&#39;click&#39;, &#39;.fc-close&#39;, function () {
        _this.hide();
    });
    if (options.autoHide) {
        this.listenTo($(document), &#39;mousedown&#39;, this.documentMousedown);
    }
};
// Triggered when the user clicks *anywhere* in the document, for the autoHide feature
Popover.prototype.documentMousedown = function (ev) {
    // only hide the popover if the click happened outside the popover
    if (this.el &amp;&amp; !$(ev.target).closest(this.el).length) {
        this.hide();
    }
};
// Hides and unregisters any handlers
Popover.prototype.removeElement = function () {
    this.hide();
    if (this.el) {
        this.el.remove();
        this.el = null;
    }
    this.stopListeningTo($(document), &#39;mousedown&#39;);
};
// Positions the popover optimally, using the top/left/right options
Popover.prototype.position = function () {
    var options = this.options;
    var origin = this.el.offsetParent().offset();
    var width = this.el.outerWidth();
    var height = this.el.outerHeight();
    var windowEl = $(window);
    var viewportEl = util_1.getScrollParent(this.el);
    var viewportTop;
    var viewportLeft;
    var viewportOffset;
    var top; // the &quot;position&quot; (not &quot;offset&quot;) values for the popover
    var left; //
    // compute top and left
    top = options.top || 0;
    if (options.left !== undefined) {
        left = options.left;
    }
    else if (options.right !== undefined) {
        left = options.right - width; // derive the left value from the right value
    }
    else {
        left = 0;
    }
    if (viewportEl.is(window) || viewportEl.is(document)) {
        viewportEl = windowEl;
        viewportTop = 0; // the window is always at the top left
        viewportLeft = 0; // (and .offset() won&#39;t work if called here)
    }
    else {
        viewportOffset = viewportEl.offset();
        viewportTop = viewportOffset.top;
        viewportLeft = viewportOffset.left;
    }
    // if the window is scrolled, it causes the visible area to be further down
    viewportTop += windowEl.scrollTop();
    viewportLeft += windowEl.scrollLeft();
    // constrain to the view port. if constrained by two edges, give precedence to top/left
    if (options.viewportConstrain !== false) {
        top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
        top = Math.max(top, viewportTop + this.margin);
        left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
        left = Math.max(left, viewportLeft + this.margin);
    }
    this.el.css({
        top: top - origin.top,
        left: left - origin.left
    });
};
// Triggers a callback. Calls a function in the option hash of the same name.
// Arguments beyond the first `name` are forwarded on.
// TODO: better code reuse for this. Repeat code
Popover.prototype.trigger = function (name) {
    if (this.options[name]) {
        this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
    }
};
return Popover;</pre>

<p>}()); exports.default = Popover; ListenerMixin_1.default.mixInto(Popover);</p>

<p>/***/ }), /* 250 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
util_1 = <em>webpack_require</em>(4); var EventRenderer_1 =
<em>webpack_require</em>(42); /* Event-rendering methods for the DayGrid
class ———————————————————————————————————————-*/ var DayGridEventRenderer =
/** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(DayGridEventRenderer, _super);
function DayGridEventRenderer(dayGrid, fillRenderer) {
    var _this = _super.call(this, dayGrid, fillRenderer) || this;
    _this.dayGrid = dayGrid;
    return _this;
}
DayGridEventRenderer.prototype.renderBgRanges = function (eventRanges) {
    // don&#39;t render timed background events
    eventRanges = $.grep(eventRanges, function (eventRange) {
        return eventRange.eventDef.isAllDay();
    });
    _super.prototype.renderBgRanges.call(this, eventRanges);
};
// Renders the given foreground event segments onto the grid
DayGridEventRenderer.prototype.renderFgSegs = function (segs) {
    var rowStructs = this.rowStructs = this.renderSegRows(segs);
    // append to each row&#39;s content skeleton
    this.dayGrid.rowEls.each(function (i, rowNode) {
        $(rowNode).find(&#39;.fc-content-skeleton &gt; table&#39;).append(rowStructs[i].tbodyEl);
    });
};
// Unrenders all currently rendered foreground event segments
DayGridEventRenderer.prototype.unrenderFgSegs = function () {
    var rowStructs = this.rowStructs || [];
    var rowStruct;
    while ((rowStruct = rowStructs.pop())) {
        rowStruct.tbodyEl.remove();
    }
    this.rowStructs = null;
};
// Uses the given events array to generate &lt;tbody&gt; elements that should be appended to each row&#39;s content skeleton.
// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
// PRECONDITION: each segment shoud already have a rendered and assigned `.el`
DayGridEventRenderer.prototype.renderSegRows = function (segs) {
    var rowStructs = [];
    var segRows;
    var row;
    segRows = this.groupSegRows(segs); // group into nested arrays
    // iterate each row of segment groupings
    for (row = 0; row &lt; segRows.length; row++) {
        rowStructs.push(this.renderSegRow(row, segRows[row]));
    }
    return rowStructs;
};
// Given a row # and an array of segments all in the same row, render a &lt;tbody&gt; element, a skeleton that contains
// the segments. Returns object with a bunch of internal data about how the render was calculated.
// NOTE: modifies rowSegs
DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {
    var colCnt = this.dayGrid.colCnt;
    var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
    var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
    var tbody = $(&#39;&lt;tbody/&gt;&#39;);
    var segMatrix = []; // lookup for which segments are rendered into which level+col cells
    var cellMatrix = []; // lookup for all &lt;td&gt; elements of the level+col matrix
    var loneCellMatrix = []; // lookup for &lt;td&gt; elements that only take up a single column
    var i;
    var levelSegs;
    var col;
    var tr;
    var j;
    var seg;
    var td;
    // populates empty cells from the current column (`col`) to `endCol`
    function emptyCellsUntil(endCol) {
        while (col &lt; endCol) {
            // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
            td = (loneCellMatrix[i - 1] || [])[col];
            if (td) {
                td.attr(&#39;rowspan&#39;, parseInt(td.attr(&#39;rowspan&#39;) || 1, 10) + 1);
            }
            else {
                td = $(&#39;&lt;td/&gt;&#39;);
                tr.append(td);
            }
            cellMatrix[i][col] = td;
            loneCellMatrix[i][col] = td;
            col++;
        }
    }
    for (i = 0; i &lt; levelCnt; i++) {
        levelSegs = segLevels[i];
        col = 0;
        tr = $(&#39;&lt;tr/&gt;&#39;);
        segMatrix.push([]);
        cellMatrix.push([]);
        loneCellMatrix.push([]);
        // levelCnt might be 1 even though there are no actual levels. protect against this.
        // this single empty row is useful for styling.
        if (levelSegs) {
            for (j = 0; j &lt; levelSegs.length; j++) {
                seg = levelSegs[j];
                emptyCellsUntil(seg.leftCol);
                // create a container that occupies or more columns. append the event element.
                td = $(&#39;&lt;td class=&quot;fc-event-container&quot;/&gt;&#39;).append(seg.el);
                if (seg.leftCol !== seg.rightCol) {
                    td.attr(&#39;colspan&#39;, seg.rightCol - seg.leftCol + 1);
                }
                else {
                    loneCellMatrix[i][col] = td;
                }
                while (col &lt;= seg.rightCol) {
                    cellMatrix[i][col] = td;
                    segMatrix[i][col] = seg;
                    col++;
                }
                tr.append(td);
            }
        }
        emptyCellsUntil(colCnt); // finish off the row
        this.dayGrid.bookendCells(tr);
        tbody.append(tr);
    }
    return {
        row: row,
        tbodyEl: tbody,
        cellMatrix: cellMatrix,
        segMatrix: segMatrix,
        segLevels: segLevels,
        segs: rowSegs
    };
};
// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
// NOTE: modifies segs
DayGridEventRenderer.prototype.buildSegLevels = function (segs) {
    var levels = [];
    var i;
    var seg;
    var j;
    // Give preference to elements with certain criteria, so they have
    // a chance to be closer to the top.
    this.sortEventSegs(segs);
    for (i = 0; i &lt; segs.length; i++) {
        seg = segs[i];
        // loop through levels, starting with the topmost, until the segment doesn&#39;t collide with other segments
        for (j = 0; j &lt; levels.length; j++) {
            if (!isDaySegCollision(seg, levels[j])) {
                break;
            }
        }
        // `j` now holds the desired subrow index
        seg.level = j;
        // create new level array if needed and append segment
        (levels[j] || (levels[j] = [])).push(seg);
    }
    // order segments left-to-right. very important if calendar is RTL
    for (j = 0; j &lt; levels.length; j++) {
        levels[j].sort(compareDaySegCols);
    }
    return levels;
};
// Given a flat array of segments, return an array of sub-arrays, grouped by each segment&#39;s row
DayGridEventRenderer.prototype.groupSegRows = function (segs) {
    var segRows = [];
    var i;
    for (i = 0; i &lt; this.dayGrid.rowCnt; i++) {
        segRows.push([]);
    }
    for (i = 0; i &lt; segs.length; i++) {
        segRows[segs[i].row].push(segs[i]);
    }
    return segRows;
};
// Computes a default event time formatting string if `timeFormat` is not explicitly defined
DayGridEventRenderer.prototype.computeEventTimeFormat = function () {
    return this.opt(&#39;extraSmallTimeFormat&#39;); // like &quot;6p&quot; or &quot;6:30p&quot;
};
// Computes a default `displayEventEnd` value if one is not expliclty defined
DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
    return this.dayGrid.colCnt === 1; // we&#39;ll likely have space if there&#39;s only one day
};
// Builds the HTML to be used for the default element for an individual segment
DayGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
    var view = this.view;
    var eventDef = seg.footprint.eventDef;
    var isAllDay = seg.footprint.componentFootprint.isAllDay;
    var isDraggable = view.isEventDefDraggable(eventDef);
    var isResizableFromStart = !disableResizing &amp;&amp; isAllDay &amp;&amp;
        seg.isStart &amp;&amp; view.isEventDefResizableFromStart(eventDef);
    var isResizableFromEnd = !disableResizing &amp;&amp; isAllDay &amp;&amp;
        seg.isEnd &amp;&amp; view.isEventDefResizableFromEnd(eventDef);
    var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
    var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));
    var timeHtml = &#39;&#39;;
    var timeText;
    var titleHtml;
    classes.unshift(&#39;fc-day-grid-event&#39;, &#39;fc-h-event&#39;);
    // Only display a timed events time if it is the starting segment
    if (seg.isStart) {
        timeText = this.getTimeText(seg.footprint);
        if (timeText) {
            timeHtml = &#39;&lt;span class=&quot;fc-time&quot;&gt;&#39; + util_1.htmlEscape(timeText) + &#39;&lt;/span&gt;&#39;;
        }
    }
    titleHtml =
        &#39;&lt;span class=&quot;fc-title&quot;&gt;&#39; +
            (util_1.htmlEscape(eventDef.title || &#39;&#39;) || &#39;&amp;nbsp;&#39;) + // we always want one line of height
            &#39;&lt;/span&gt;&#39;;
    return &#39;&lt;a class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&#39; +
        (eventDef.url ?
            &#39; href=&quot;&#39; + util_1.htmlEscape(eventDef.url) + &#39;&quot;&#39; :
            &#39;&#39;) +
        (skinCss ?
            &#39; style=&quot;&#39; + skinCss + &#39;&quot;&#39; :
            &#39;&#39;) +
        &#39;&gt;&#39; +
        &#39;&lt;div class=&quot;fc-content&quot;&gt;&#39; +
        (this.dayGrid.isRTL ?
            titleHtml + &#39; &#39; + timeHtml : // put a natural space in between
            timeHtml + &#39; &#39; + titleHtml //
        ) +
        &#39;&lt;/div&gt;&#39; +
        (isResizableFromStart ?
            &#39;&lt;div class=&quot;fc-resizer fc-start-resizer&quot; /&gt;&#39; :
            &#39;&#39;) +
        (isResizableFromEnd ?
            &#39;&lt;div class=&quot;fc-resizer fc-end-resizer&quot; /&gt;&#39; :
            &#39;&#39;) +
        &#39;&lt;/a&gt;&#39;;
};
return DayGridEventRenderer;</pre>

<p>}(EventRenderer_1.default)); exports.default = DayGridEventRenderer; //
Computes whether two segments&#39; columns collide. They are assumed to be
in the same row. function isDaySegCollision(seg, otherSegs) {</p>

<pre>var i;
var otherSeg;
for (i = 0; i &lt; otherSegs.length; i++) {
    otherSeg = otherSegs[i];
    if (otherSeg.leftCol &lt;= seg.rightCol &amp;&amp;
        otherSeg.rightCol &gt;= seg.leftCol) {
        return true;
    }
}
return false;</pre>

<p>} // A cmp function for determining the leftmost event function
compareDaySegCols(a, b) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">leftCol</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">leftCol</span>;
</pre>

<p>}</p>

<p>/***/ }), /* 251 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
HelperRenderer_1 = <em>webpack_require</em>(58); var DayGridHelperRenderer
= /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(DayGridHelperRenderer, _super);
function DayGridHelperRenderer() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
// Renders a mock &quot;helper&quot; event. `sourceSeg` is the associated internal segment object. It can be null.
DayGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
    var helperNodes = [];
    var rowStructs;
    // TODO: not good to call eventRenderer this way
    rowStructs = this.eventRenderer.renderSegRows(segs);
    // inject each new event skeleton into each associated row
    this.component.rowEls.each(function (row, rowNode) {
        var rowEl = $(rowNode); // the .fc-row
        var skeletonEl = $(&#39;&lt;div class=&quot;fc-helper-skeleton&quot;&gt;&lt;table/&gt;&lt;/div&gt;&#39;); // will be absolutely positioned
        var skeletonTopEl;
        var skeletonTop;
        // If there is an original segment, match the top position. Otherwise, put it at the row&#39;s top level
        if (sourceSeg &amp;&amp; sourceSeg.row === row) {
            skeletonTop = sourceSeg.el.position().top;
        }
        else {
            skeletonTopEl = rowEl.find(&#39;.fc-content-skeleton tbody&#39;);
            if (!skeletonTopEl.length) {
                skeletonTopEl = rowEl.find(&#39;.fc-content-skeleton table&#39;);
            }
            skeletonTop = skeletonTopEl.position().top;
        }
        skeletonEl.css(&#39;top&#39;, skeletonTop)
            .find(&#39;table&#39;)
            .append(rowStructs[row].tbodyEl);
        rowEl.append(skeletonEl);
        helperNodes.push(skeletonEl[0]);
    });
    return $(helperNodes); // must return the elements rendered
};
return DayGridHelperRenderer;</pre>

<p>}(HelperRenderer_1.default)); exports.default = DayGridHelperRenderer;</p>

<p>/***/ }), /* 252 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
FillRenderer_1 = <em>webpack_require</em>(57); var DayGridFillRenderer =
/** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(DayGridFillRenderer, _super);
function DayGridFillRenderer() {
    var _this = _super !== null &amp;&amp; _super.apply(this, arguments) || this;
    _this.fillSegTag = &#39;td&#39;; // override the default tag name
    return _this;
}
DayGridFillRenderer.prototype.attachSegEls = function (type, segs) {
    var nodes = [];
    var i;
    var seg;
    var skeletonEl;
    for (i = 0; i &lt; segs.length; i++) {
        seg = segs[i];
        skeletonEl = this.renderFillRow(type, seg);
        this.component.rowEls.eq(seg.row).append(skeletonEl);
        nodes.push(skeletonEl[0]);
    }
    return nodes;
};
// Generates the HTML needed for one row of a fill. Requires the seg&#39;s el to be rendered.
DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {
    var colCnt = this.component.colCnt;
    var startCol = seg.leftCol;
    var endCol = seg.rightCol + 1;
    var className;
    var skeletonEl;
    var trEl;
    if (type === &#39;businessHours&#39;) {
        className = &#39;bgevent&#39;;
    }
    else {
        className = type.toLowerCase();
    }
    skeletonEl = $(&#39;&lt;div class=&quot;fc-&#39; + className + &#39;-skeleton&quot;&gt;&#39; +
        &#39;&lt;table&gt;&lt;tr/&gt;&lt;/table&gt;&#39; +
        &#39;&lt;/div&gt;&#39;);
    trEl = skeletonEl.find(&#39;tr&#39;);
    if (startCol &gt; 0) {
        trEl.append(&#39;&lt;td colspan=&quot;&#39; + startCol + &#39;&quot;/&gt;&#39;);
    }
    trEl.append(seg.el.attr(&#39;colspan&#39;, endCol - startCol));
    if (endCol &lt; colCnt) {
        trEl.append(&#39;&lt;td colspan=&quot;&#39; + (colCnt - endCol) + &#39;&quot;/&gt;&#39;);
    }
    this.component.bookendCells(trEl);
    return skeletonEl;
};
return DayGridFillRenderer;</pre>

<p>}(FillRenderer_1.default)); exports.default = DayGridFillRenderer;</p>

<p>/***/ }), /* 253 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var BasicViewDateProfileGenerator_1 =
<em>webpack_require</em>(228); var UnzonedRange_1 =
<em>webpack_require</em>(5); var MonthViewDateProfileGenerator = /** @class
*/ (function (_super) {</p>

<pre>tslib_1.__extends(MonthViewDateProfileGenerator, _super);
function MonthViewDateProfileGenerator() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
// Computes the date range that will be rendered.
MonthViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
    var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay);
    var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);
    var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);
    var rowCnt;
    // ensure 6 weeks
    if (this.opt(&#39;fixedWeekCount&#39;)) {
        rowCnt = Math.ceil(// could be partial weeks due to hiddenDays
        end.diff(start, &#39;weeks&#39;, true) // dontRound=true
        );
        end.add(6 - rowCnt, &#39;weeks&#39;);
    }
    return new UnzonedRange_1.default(start, end);
};
return MonthViewDateProfileGenerator;</pre>

<p>}(BasicViewDateProfileGenerator_1.default)); exports.default =
MonthViewDateProfileGenerator;</p>

<p>/***/ }), /* 254 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var util_1 = <em>webpack_require</em>(4);
var EventRenderer_1 = <em>webpack_require</em>(42); var ListEventRenderer =
/** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(ListEventRenderer, _super);
function ListEventRenderer() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
ListEventRenderer.prototype.renderFgSegs = function (segs) {
    if (!segs.length) {
        this.component.renderEmptyMessage();
    }
    else {
        this.component.renderSegList(segs);
    }
};
// generates the HTML for a single event row
ListEventRenderer.prototype.fgSegHtml = function (seg) {
    var view = this.view;
    var calendar = view.calendar;
    var theme = calendar.theme;
    var eventFootprint = seg.footprint;
    var eventDef = eventFootprint.eventDef;
    var componentFootprint = eventFootprint.componentFootprint;
    var url = eventDef.url;
    var classes = [&#39;fc-list-item&#39;].concat(this.getClasses(eventDef));
    var bgColor = this.getBgColor(eventDef);
    var timeHtml;
    if (componentFootprint.isAllDay) {
        timeHtml = view.getAllDayHtml();
    }
    else if (view.isMultiDayRange(componentFootprint.unzonedRange)) {
        if (seg.isStart || seg.isEnd) {
            timeHtml = util_1.htmlEscape(this._getTimeText(calendar.msToMoment(seg.startMs), calendar.msToMoment(seg.endMs), componentFootprint.isAllDay));
        }
        else {
            timeHtml = view.getAllDayHtml();
        }
    }
    else {
        // Display the normal time text for the *event&#39;s* times
        timeHtml = util_1.htmlEscape(this.getTimeText(eventFootprint));
    }
    if (url) {
        classes.push(&#39;fc-has-url&#39;);
    }
    return &#39;&lt;tr class=&quot;&#39; + classes.join(&#39; &#39;) + &#39;&quot;&gt;&#39; +
        (this.displayEventTime ?
            &#39;&lt;td class=&quot;fc-list-item-time &#39; + theme.getClass(&#39;widgetContent&#39;) + &#39;&quot;&gt;&#39; +
                (timeHtml || &#39;&#39;) +
                &#39;&lt;/td&gt;&#39; :
            &#39;&#39;) +
        &#39;&lt;td class=&quot;fc-list-item-marker &#39; + theme.getClass(&#39;widgetContent&#39;) + &#39;&quot;&gt;&#39; +
        &#39;&lt;span class=&quot;fc-event-dot&quot;&#39; +
        (bgColor ?
            &#39; style=&quot;background-color:&#39; + bgColor + &#39;&quot;&#39; :
            &#39;&#39;) +
        &#39;&gt;&lt;/span&gt;&#39; +
        &#39;&lt;/td&gt;&#39; +
        &#39;&lt;td class=&quot;fc-list-item-title &#39; + theme.getClass(&#39;widgetContent&#39;) + &#39;&quot;&gt;&#39; +
        &#39;&lt;a&#39; + (url ? &#39; href=&quot;&#39; + util_1.htmlEscape(url) + &#39;&quot;&#39; : &#39;&#39;) + &#39;&gt;&#39; +
        util_1.htmlEscape(eventDef.title || &#39;&#39;) +
        &#39;&lt;/a&gt;&#39; +
        &#39;&lt;/td&gt;&#39; +
        &#39;&lt;/tr&gt;&#39;;
};
// like &quot;4:00am&quot;
ListEventRenderer.prototype.computeEventTimeFormat = function () {
    return this.opt(&#39;mediumTimeFormat&#39;);
};
return ListEventRenderer;</pre>

<p>}(EventRenderer_1.default)); exports.default = ListEventRenderer;</p>

<p>/***/ }), /* 255 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var $ = <em>webpack_require</em>(3); var
EventPointing_1 = <em>webpack_require</em>(59); var ListEventPointing = /**
@class */ (function (_super) {</p>

<pre>tslib_1.__extends(ListEventPointing, _super);
function ListEventPointing() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
// for events with a url, the whole &lt;tr&gt; should be clickable,
// but it&#39;s impossible to wrap with an &lt;a&gt; tag. simulate this.
ListEventPointing.prototype.handleClick = function (seg, ev) {
    var url;
    _super.prototype.handleClick.call(this, seg, ev); // might prevent the default action
    // not clicking on or within an &lt;a&gt; with an href
    if (!$(ev.target).closest(&#39;a[href]&#39;).length) {
        url = seg.footprint.eventDef.url;
        if (url &amp;&amp; !ev.isDefaultPrevented()) {
            window.location.href = url; // simulate link click
        }
    }
};
return ListEventPointing;</pre>

<p>}(EventPointing_1.default)); exports.default = ListEventPointing;</p>

<p>/***/ }), /* 256 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
EventSourceParser_1 = <em>webpack_require</em>(38); var ArrayEventSource_1
= <em>webpack_require</em>(52); var FuncEventSource_1 =
<em>webpack_require</em>(215); var JsonFeedEventSource_1 =
<em>webpack_require</em>(216);
EventSourceParser_1.default.registerClass(ArrayEventSource_1.default);
EventSourceParser_1.default.registerClass(FuncEventSource_1.default);
EventSourceParser_1.default.registerClass(JsonFeedEventSource_1.default);</p>

<p>/***/ }), /* 257 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
ThemeRegistry_1 = <em>webpack_require</em>(51); var StandardTheme_1 =
<em>webpack_require</em>(213); var JqueryUiTheme_1 =
<em>webpack_require</em>(214); var Bootstrap3Theme_1 =
<em>webpack_require</em>(258); var Bootstrap4Theme_1 =
<em>webpack_require</em>(259);
ThemeRegistry_1.defineThemeSystem(&#39;standard&#39;,
StandardTheme_1.default);
ThemeRegistry_1.defineThemeSystem(&#39;jquery-ui&#39;,
JqueryUiTheme_1.default);
ThemeRegistry_1.defineThemeSystem(&#39;bootstrap3&#39;,
Bootstrap3Theme_1.default);
ThemeRegistry_1.defineThemeSystem(&#39;bootstrap4&#39;,
Bootstrap4Theme_1.default);</p>

<p>/***/ }), /* 258 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var Theme_1 = <em>webpack_require</em>(19);
var Bootstrap3Theme = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(Bootstrap3Theme, _super);
function Bootstrap3Theme() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
return Bootstrap3Theme;</pre>

<p>}(Theme_1.default)); exports.default = Bootstrap3Theme;
Bootstrap3Theme.prototype.classes = {</p>

<pre>widget: &#39;fc-bootstrap3&#39;,
tableGrid: &#39;table-bordered&#39;,
tableList: &#39;table&#39;,
tableListHeading: &#39;active&#39;,
buttonGroup: &#39;btn-group&#39;,
button: &#39;btn btn-default&#39;,
stateActive: &#39;active&#39;,
stateDisabled: &#39;disabled&#39;,
today: &#39;alert alert-info&#39;,
popover: &#39;panel panel-default&#39;,
popoverHeader: &#39;panel-heading&#39;,
popoverContent: &#39;panel-body&#39;,
// day grid
// for left/right border color when border is inset from edges (all-day in agenda view)
// avoid `panel` class b/c don&#39;t want margins/radius. only border color.
headerRow: &#39;panel-default&#39;,
dayRow: &#39;panel-default&#39;,
// list view
listView: &#39;panel panel-default&#39;</pre>

<p>}; Bootstrap3Theme.prototype.baseIconClass = &#39;glyphicon&#39;;
Bootstrap3Theme.prototype.iconClasses = {</p>

<pre>close: &#39;glyphicon-remove&#39;,
prev: &#39;glyphicon-chevron-left&#39;,
next: &#39;glyphicon-chevron-right&#39;,
prevYear: &#39;glyphicon-backward&#39;,
nextYear: &#39;glyphicon-forward&#39;</pre>

<p>}; Bootstrap3Theme.prototype.iconOverrideOption =
&#39;bootstrapGlyphicons&#39;;
Bootstrap3Theme.prototype.iconOverrideCustomButtonOption =
&#39;bootstrapGlyphicon&#39;; Bootstrap3Theme.prototype.iconOverridePrefix
= &#39;glyphicon-&#39;;</p>

<p>/***/ }), /* 259 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var tslib_1
= <em>webpack_require</em>(2); var Theme_1 = <em>webpack_require</em>(19);
var Bootstrap4Theme = /** @class */ (function (_super) {</p>

<pre>tslib_1.__extends(Bootstrap4Theme, _super);
function Bootstrap4Theme() {
    return _super !== null &amp;&amp; _super.apply(this, arguments) || this;
}
return Bootstrap4Theme;</pre>

<p>}(Theme_1.default)); exports.default = Bootstrap4Theme;
Bootstrap4Theme.prototype.classes = {</p>

<pre>widget: &#39;fc-bootstrap4&#39;,
tableGrid: &#39;table-bordered&#39;,
tableList: &#39;table&#39;,
tableListHeading: &#39;table-active&#39;,
buttonGroup: &#39;btn-group&#39;,
button: &#39;btn btn-primary&#39;,
stateActive: &#39;active&#39;,
stateDisabled: &#39;disabled&#39;,
today: &#39;alert alert-info&#39;,
popover: &#39;card card-primary&#39;,
popoverHeader: &#39;card-header&#39;,
popoverContent: &#39;card-body&#39;,
// day grid
// for left/right border color when border is inset from edges (all-day in agenda view)
// avoid `table` class b/c don&#39;t want margins/padding/structure. only border color.
headerRow: &#39;table-bordered&#39;,
dayRow: &#39;table-bordered&#39;,
// list view
listView: &#39;card card-primary&#39;</pre>

<p>}; Bootstrap4Theme.prototype.baseIconClass = &#39;fa&#39;;
Bootstrap4Theme.prototype.iconClasses = {</p>

<pre>close: &#39;fa-times&#39;,
prev: &#39;fa-chevron-left&#39;,
next: &#39;fa-chevron-right&#39;,
prevYear: &#39;fa-angle-double-left&#39;,
nextYear: &#39;fa-angle-double-right&#39;</pre>

<p>}; Bootstrap4Theme.prototype.iconOverrideOption =
&#39;bootstrapFontAwesome&#39;;
Bootstrap4Theme.prototype.iconOverrideCustomButtonOption =
&#39;bootstrapFontAwesome&#39;;
Bootstrap4Theme.prototype.iconOverridePrefix = &#39;fa-&#39;;</p>

<p>/***/ }), /* 260 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
ViewRegistry_1 = <em>webpack_require</em>(22); var BasicView_1 =
<em>webpack_require</em>(62); var MonthView_1 =
<em>webpack_require</em>(229); ViewRegistry_1.defineView(&#39;basic&#39;, {</p>

<pre>&#39;class&#39;: BasicView_1.default</pre>

<p>}); ViewRegistry_1.defineView(&#39;basicDay&#39;, {</p>

<pre>type: &#39;basic&#39;,
duration: { days: 1 }</pre>

<p>}); ViewRegistry_1.defineView(&#39;basicWeek&#39;, {</p>

<pre>type: &#39;basic&#39;,
duration: { weeks: 1 }</pre>

<p>}); ViewRegistry_1.defineView(&#39;month&#39;, {</p>

<pre>&#39;class&#39;: MonthView_1.default,
duration: { months: 1 },
defaults: {
    fixedWeekCount: true
}</pre>

<p>});</p>

<p>/***/ }), /* 261 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
ViewRegistry_1 = <em>webpack_require</em>(22); var AgendaView_1 =
<em>webpack_require</em>(226); ViewRegistry_1.defineView(&#39;agenda&#39;,
{</p>

<pre>&#39;class&#39;: AgendaView_1.default,
defaults: {
    allDaySlot: true,
    slotDuration: &#39;00:30:00&#39;,
    slotEventOverlap: true // a bad name. confused with overlap/constraint system
}</pre>

<p>}); ViewRegistry_1.defineView(&#39;agendaDay&#39;, {</p>

<pre>type: &#39;agenda&#39;,
duration: { days: 1 }</pre>

<p>}); ViewRegistry_1.defineView(&#39;agendaWeek&#39;, {</p>

<pre>type: &#39;agenda&#39;,
duration: { weeks: 1 }</pre>

<p>});</p>

<p>/***/ }), /* 262 */ /***/ (function(module, exports,
<em>webpack_require</em>) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true }); var
ViewRegistry_1 = <em>webpack_require</em>(22); var ListView_1 =
<em>webpack_require</em>(230); ViewRegistry_1.defineView(&#39;list&#39;, {</p>

<pre>&#39;class&#39;: ListView_1.default,
buttonTextKey: &#39;list&#39;,
defaults: {
    buttonText: &#39;list&#39;,
    listDayFormat: &#39;LL&#39;,
    noEventsMessage: &#39;No events to display&#39;
}</pre>

<p>}); ViewRegistry_1.defineView(&#39;listDay&#39;, {</p>

<pre>type: &#39;list&#39;,
duration: { days: 1 },
defaults: {
    listDayFormat: &#39;dddd&#39; // day-of-week is all we need. full date is probably in header
}</pre>

<p>}); ViewRegistry_1.defineView(&#39;listWeek&#39;, {</p>

<pre>type: &#39;list&#39;,
duration: { weeks: 1 },
defaults: {
    listDayFormat: &#39;dddd&#39;,
    listDayAltFormat: &#39;LL&#39;
}</pre>

<p>}); ViewRegistry_1.defineView(&#39;listMonth&#39;, {</p>

<pre>type: &#39;list&#39;,
duration: { month: 1 },
defaults: {
    listDayAltFormat: &#39;dddd&#39; // day-of-week is nice-to-have
}</pre>

<p>}); ViewRegistry_1.defineView(&#39;listYear&#39;, {</p>

<pre>type: &#39;list&#39;,
duration: { year: 1 },
defaults: {
    listDayAltFormat: &#39;dddd&#39; // day-of-week is nice-to-have
}</pre>

<p>});</p>

<p>/***/ }), /* 263 */ /***/ (function(module, exports) {</p>

<p>Object.defineProperty(exports, “__esModule”, { value: true });</p>

<p>/***/ }) /******/ ]); });</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.0.4.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

